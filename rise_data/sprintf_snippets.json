{
  "metadata": {
    "repository": "https://github.com/aravindkrishnaswamy/RISE",
    "commit": "297d0339a7f7acd1418e322a30a21f44c7dbbb1d",
    "extraction_date": "Tue Sep 30 12:14:44 MDT 2025",
    "total_snippets": 66,
    "total_files": 35,
    "total_lines": 1119,
    "total_matched_lines": 147,
    "total_context_lines": 972,
    "description": "Code snippets containing sprintf calls from RISE repository"
  },
  "snippets": [
    {
      "file_path": "extlib/libpng/png.c",
      "matched_lines": [
        641,
        652,
        660
      ],
      "context_lines": [
        636,
        637,
        638,
        639,
        640,
        642,
        643,
        644,
        645,
        646,
        647,
        648,
        649,
        650,
        651,
        653,
        654,
        655,
        656,
        657,
        658,
        659,
        661,
        662,
        663,
        664,
        665
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/libpng/png.c-636-   }",
        "extlib/libpng/png.c-637-",
        "extlib/libpng/png.c-638-#if defined(_WIN32_WCE)",
        "extlib/libpng/png.c-639-   {",
        "extlib/libpng/png.c-640-      wchar_t time_buf[29];",
        "extlib/libpng/png.c:641:      wsprintf(time_buf, TEXT(\"%d %S %d %02d:%02d:%02d +0000\"),",
        "extlib/libpng/png.c-642-          ptime->day % 32, short_months[(ptime->month - 1) % 12],",
        "extlib/libpng/png.c-643-        ptime->year, ptime->hour % 24, ptime->minute % 60,",
        "extlib/libpng/png.c-644-          ptime->second % 61);",
        "extlib/libpng/png.c-645-      WideCharToMultiByte(CP_ACP, 0, time_buf, -1, png_ptr->time_buffer, 29,",
        "extlib/libpng/png.c-646-          NULL, NULL);",
        "extlib/libpng/png.c-647-   }",
        "extlib/libpng/png.c-648-#else",
        "extlib/libpng/png.c-649-#ifdef USE_FAR_KEYWORD",
        "extlib/libpng/png.c-650-   {",
        "extlib/libpng/png.c-651-      char near_time_buf[29];",
        "extlib/libpng/png.c:652:      sprintf(near_time_buf, \"%d %s %d %02d:%02d:%02d +0000\",",
        "extlib/libpng/png.c-653-          ptime->day % 32, short_months[(ptime->month - 1) % 12],",
        "extlib/libpng/png.c-654-          ptime->year, ptime->hour % 24, ptime->minute % 60,",
        "extlib/libpng/png.c-655-          ptime->second % 61);",
        "extlib/libpng/png.c-656-      png_memcpy(png_ptr->time_buffer, near_time_buf,",
        "extlib/libpng/png.c-657-          29*png_sizeof(char));",
        "extlib/libpng/png.c-658-   }",
        "extlib/libpng/png.c-659-#else",
        "extlib/libpng/png.c:660:   sprintf(png_ptr->time_buffer, \"%d %s %d %02d:%02d:%02d +0000\",",
        "extlib/libpng/png.c-661-       ptime->day % 32, short_months[(ptime->month - 1) % 12],",
        "extlib/libpng/png.c-662-       ptime->year, ptime->hour % 24, ptime->minute % 60,",
        "extlib/libpng/png.c-663-       ptime->second % 61);",
        "extlib/libpng/png.c-664-#endif",
        "extlib/libpng/png.c-665-#endif /* _WIN32_WCE */"
      ],
      "raw_content": [
        "   }",
        "",
        "#if defined(_WIN32_WCE)",
        "   {",
        "      wchar_t time_buf[29];",
        "      wsprintf(time_buf, TEXT(\"%d %S %d %02d:%02d:%02d +0000\"),",
        "          ptime->day % 32, short_months[(ptime->month - 1) % 12],",
        "        ptime->year, ptime->hour % 24, ptime->minute % 60,",
        "          ptime->second % 61);",
        "      WideCharToMultiByte(CP_ACP, 0, time_buf, -1, png_ptr->time_buffer, 29,",
        "          NULL, NULL);",
        "   }",
        "#else",
        "#ifdef USE_FAR_KEYWORD",
        "   {",
        "      char near_time_buf[29];",
        "      sprintf(near_time_buf, \"%d %s %d %02d:%02d:%02d +0000\",",
        "          ptime->day % 32, short_months[(ptime->month - 1) % 12],",
        "          ptime->year, ptime->hour % 24, ptime->minute % 60,",
        "          ptime->second % 61);",
        "      png_memcpy(png_ptr->time_buffer, near_time_buf,",
        "          29*png_sizeof(char));",
        "   }",
        "#else",
        "   sprintf(png_ptr->time_buffer, \"%d %s %d %02d:%02d:%02d +0000\",",
        "       ptime->day % 32, short_months[(ptime->month - 1) % 12],",
        "       ptime->year, ptime->hour % 24, ptime->minute % 60,",
        "       ptime->second % 61);",
        "#endif",
        "#endif /* _WIN32_WCE */"
      ],
      "_frozen": true
    },
    {
      "file_path": "extlib/libpng/pnggccrd.c",
      "matched_lines": [
        5100,
        5102,
        5110,
        5118,
        5126,
        5134
      ],
      "context_lines": [
        5095,
        5096,
        5097,
        5098,
        5099,
        5101,
        5103,
        5104,
        5105,
        5106,
        5107,
        5108,
        5109,
        5111,
        5112,
        5113,
        5114,
        5115,
        5116,
        5117,
        5119,
        5120,
        5121,
        5122,
        5123,
        5124,
        5125,
        5127,
        5128,
        5129,
        5130,
        5131,
        5132,
        5133,
        5135,
        5136,
        5137,
        5138,
        5139
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/libpng/pnggccrd.c-5095-",
        "extlib/libpng/pnggccrd.c-5096-#ifdef PNG_DEBUG",
        "extlib/libpng/pnggccrd.c-5097-   png_debug(1, \"in png_read_filter_row (pnggccrd.c)\\n\");",
        "extlib/libpng/pnggccrd.c-5098-   switch (filter)",
        "extlib/libpng/pnggccrd.c-5099-   {",
        "extlib/libpng/pnggccrd.c:5100:      case 0: sprintf(filnm, \"none\");",
        "extlib/libpng/pnggccrd.c-5101-         break;",
        "extlib/libpng/pnggccrd.c:5102:      case 1: sprintf(filnm, \"sub-%s\",",
        "extlib/libpng/pnggccrd.c-5103-#if defined(PNG_ASSEMBLER_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)",
        "extlib/libpng/pnggccrd.c-5104-#if !defined(PNG_1_0_X)",
        "extlib/libpng/pnggccrd.c-5105-        (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_SUB)? \"MMX\" : ",
        "extlib/libpng/pnggccrd.c-5106-#endif",
        "extlib/libpng/pnggccrd.c-5107-#endif",
        "extlib/libpng/pnggccrd.c-5108-\"x86\");",
        "extlib/libpng/pnggccrd.c-5109-         break;",
        "extlib/libpng/pnggccrd.c:5110:      case 2: sprintf(filnm, \"up-%s\",",
        "extlib/libpng/pnggccrd.c-5111-#ifdef PNG_ASSEMBLER_CODE_SUPPORTED",
        "extlib/libpng/pnggccrd.c-5112-#if !defined(PNG_1_0_X)",
        "extlib/libpng/pnggccrd.c-5113-        (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_UP)? \"MMX\" :",
        "extlib/libpng/pnggccrd.c-5114-#endif",
        "extlib/libpng/pnggccrd.c-5115-#endif",
        "extlib/libpng/pnggccrd.c-5116- \"x86\");",
        "extlib/libpng/pnggccrd.c-5117-         break;",
        "extlib/libpng/pnggccrd.c:5118:      case 3: sprintf(filnm, \"avg-%s\",",
        "extlib/libpng/pnggccrd.c-5119-#if defined(PNG_ASSEMBLER_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)",
        "extlib/libpng/pnggccrd.c-5120-#if !defined(PNG_1_0_X)",
        "extlib/libpng/pnggccrd.c-5121-        (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_AVG)? \"MMX\" :",
        "extlib/libpng/pnggccrd.c-5122-#endif",
        "extlib/libpng/pnggccrd.c-5123-#endif",
        "extlib/libpng/pnggccrd.c-5124- \"x86\");",
        "extlib/libpng/pnggccrd.c-5125-         break;",
        "extlib/libpng/pnggccrd.c:5126:      case 4: sprintf(filnm, \"Paeth-%s\",",
        "extlib/libpng/pnggccrd.c-5127-#if defined(PNG_ASSEMBLER_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)",
        "extlib/libpng/pnggccrd.c-5128-#if !defined(PNG_1_0_X)",
        "extlib/libpng/pnggccrd.c-5129-        (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_PAETH)? \"MMX\":",
        "extlib/libpng/pnggccrd.c-5130-#endif",
        "extlib/libpng/pnggccrd.c-5131-#endif",
        "extlib/libpng/pnggccrd.c-5132-\"x86\");",
        "extlib/libpng/pnggccrd.c-5133-         break;",
        "extlib/libpng/pnggccrd.c:5134:      default: sprintf(filnm, \"unknw\");",
        "extlib/libpng/pnggccrd.c-5135-         break;",
        "extlib/libpng/pnggccrd.c-5136-   }",
        "extlib/libpng/pnggccrd.c-5137-   png_debug2(0, \"row_number=%5ld, %5s, \", png_ptr->row_number, filnm);",
        "extlib/libpng/pnggccrd.c-5138-   png_debug1(0, \"row=0x%08lx, \", (unsigned long)row);",
        "extlib/libpng/pnggccrd.c-5139-   png_debug2(0, \"pixdepth=%2d, bytes=%d, \", (int)row_info->pixel_depth,"
      ],
      "raw_content": [
        "",
        "#ifdef PNG_DEBUG",
        "   png_debug(1, \"in png_read_filter_row (pnggccrd.c)\\n\");",
        "   switch (filter)",
        "   {",
        "      case 0: sprintf(filnm, \"none\");",
        "         break;",
        "      case 1: sprintf(filnm, \"sub-%s\",",
        "#if defined(PNG_ASSEMBLER_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)",
        "#if !defined(PNG_1_0_X)",
        "        (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_SUB)? \"MMX\" : ",
        "#endif",
        "#endif",
        "\"x86\");",
        "         break;",
        "      case 2: sprintf(filnm, \"up-%s\",",
        "#ifdef PNG_ASSEMBLER_CODE_SUPPORTED",
        "#if !defined(PNG_1_0_X)",
        "        (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_UP)? \"MMX\" :",
        "#endif",
        "#endif",
        " \"x86\");",
        "         break;",
        "      case 3: sprintf(filnm, \"avg-%s\",",
        "#if defined(PNG_ASSEMBLER_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)",
        "#if !defined(PNG_1_0_X)",
        "        (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_AVG)? \"MMX\" :",
        "#endif",
        "#endif",
        " \"x86\");",
        "         break;",
        "      case 4: sprintf(filnm, \"Paeth-%s\",",
        "#if defined(PNG_ASSEMBLER_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)",
        "#if !defined(PNG_1_0_X)",
        "        (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_PAETH)? \"MMX\":",
        "#endif",
        "#endif",
        "\"x86\");",
        "         break;",
        "      default: sprintf(filnm, \"unknw\");",
        "         break;",
        "   }",
        "   png_debug2(0, \"row_number=%5ld, %5s, \", png_ptr->row_number, filnm);",
        "   png_debug1(0, \"row=0x%08lx, \", (unsigned long)row);",
        "   png_debug2(0, \"pixdepth=%2d, bytes=%d, \", (int)row_info->pixel_depth,"
      ],
      "_frozen": true
    },
    {
      "file_path": "extlib/libpng/pngread.c",
      "matched_lines": [
        118,
        122
      ],
      "context_lines": [
        113,
        114,
        115,
        116,
        117,
        119,
        120,
        121,
        123,
        124,
        125,
        126,
        127
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/libpng/pngread.c-113-     {",
        "extlib/libpng/pngread.c-114-#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)",
        "extlib/libpng/pngread.c-115-        char msg[80];",
        "extlib/libpng/pngread.c-116-        if (user_png_ver)",
        "extlib/libpng/pngread.c-117-        {",
        "extlib/libpng/pngread.c:118:          sprintf(msg, \"Application was compiled with png.h from libpng-%.20s\",",
        "extlib/libpng/pngread.c-119-             user_png_ver);",
        "extlib/libpng/pngread.c-120-          png_warning(png_ptr, msg);",
        "extlib/libpng/pngread.c-121-        }",
        "extlib/libpng/pngread.c:122:        sprintf(msg, \"Application  is  running with png.c from libpng-%.20s\",",
        "extlib/libpng/pngread.c-123-           png_libpng_ver);",
        "extlib/libpng/pngread.c-124-        png_warning(png_ptr, msg);",
        "extlib/libpng/pngread.c-125-#endif",
        "extlib/libpng/pngread.c-126-#ifdef PNG_ERROR_NUMBERS_SUPPORTED",
        "extlib/libpng/pngread.c-127-        png_ptr->flags=0;"
      ],
      "raw_content": [
        "     {",
        "#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)",
        "        char msg[80];",
        "        if (user_png_ver)",
        "        {",
        "          sprintf(msg, \"Application was compiled with png.h from libpng-%.20s\",",
        "             user_png_ver);",
        "          png_warning(png_ptr, msg);",
        "        }",
        "        sprintf(msg, \"Application  is  running with png.c from libpng-%.20s\",",
        "           png_libpng_ver);",
        "        png_warning(png_ptr, msg);",
        "#endif",
        "#ifdef PNG_ERROR_NUMBERS_SUPPORTED",
        "        png_ptr->flags=0;"
      ],
      "_frozen": true
    },
    {
      "file_path": "extlib/libpng/pngread.c",
      "matched_lines": [
        198,
        202
      ],
      "context_lines": [
        193,
        194,
        195,
        196,
        197,
        199,
        200,
        201,
        203,
        204,
        205,
        206,
        207
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/libpng/pngread.c-193-   {",
        "extlib/libpng/pngread.c-194-      char msg[80];",
        "extlib/libpng/pngread.c-195-      png_ptr->warning_fn=NULL;",
        "extlib/libpng/pngread.c-196-      if (user_png_ver)",
        "extlib/libpng/pngread.c-197-      {",
        "extlib/libpng/pngread.c:198:        sprintf(msg, \"Application was compiled with png.h from libpng-%.20s\",",
        "extlib/libpng/pngread.c-199-           user_png_ver);",
        "extlib/libpng/pngread.c-200-        png_warning(png_ptr, msg);",
        "extlib/libpng/pngread.c-201-      }",
        "extlib/libpng/pngread.c:202:      sprintf(msg, \"Application  is  running with png.c from libpng-%.20s\",",
        "extlib/libpng/pngread.c-203-         png_libpng_ver);",
        "extlib/libpng/pngread.c-204-      png_warning(png_ptr, msg);",
        "extlib/libpng/pngread.c-205-   }",
        "extlib/libpng/pngread.c-206-#endif",
        "extlib/libpng/pngread.c-207-   if(png_sizeof(png_struct) > png_struct_size)"
      ],
      "raw_content": [
        "   {",
        "      char msg[80];",
        "      png_ptr->warning_fn=NULL;",
        "      if (user_png_ver)",
        "      {",
        "        sprintf(msg, \"Application was compiled with png.h from libpng-%.20s\",",
        "           user_png_ver);",
        "        png_warning(png_ptr, msg);",
        "      }",
        "      sprintf(msg, \"Application  is  running with png.c from libpng-%.20s\",",
        "         png_libpng_ver);",
        "      png_warning(png_ptr, msg);",
        "   }",
        "#endif",
        "   if(png_sizeof(png_struct) > png_struct_size)"
      ],
      "_frozen": true
    },
    {
      "file_path": "extlib/libpng/pngrtran.c",
      "matched_lines": [
        1182
      ],
      "context_lines": [
        1177,
        1178,
        1179,
        1180,
        1181,
        1183,
        1184,
        1185,
        1186,
        1187
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/libpng/pngrtran.c-1177-   if (png_ptr->row_buf == NULL)",
        "extlib/libpng/pngrtran.c-1178-   {",
        "extlib/libpng/pngrtran.c-1179-#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)",
        "extlib/libpng/pngrtran.c-1180-      char msg[50];",
        "extlib/libpng/pngrtran.c-1181-",
        "extlib/libpng/pngrtran.c:1182:      sprintf(msg, \"NULL row buffer for row %ld, pass %d\", png_ptr->row_number,",
        "extlib/libpng/pngrtran.c-1183-         png_ptr->pass);",
        "extlib/libpng/pngrtran.c-1184-      png_error(png_ptr, msg);",
        "extlib/libpng/pngrtran.c-1185-#else",
        "extlib/libpng/pngrtran.c-1186-      png_error(png_ptr, \"NULL row buffer\");",
        "extlib/libpng/pngrtran.c-1187-#endif"
      ],
      "raw_content": [
        "   if (png_ptr->row_buf == NULL)",
        "   {",
        "#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)",
        "      char msg[50];",
        "",
        "      sprintf(msg, \"NULL row buffer for row %ld, pass %d\", png_ptr->row_number,",
        "         png_ptr->pass);",
        "      png_error(png_ptr, msg);",
        "#else",
        "      png_error(png_ptr, \"NULL row buffer\");",
        "#endif"
      ],
      "_frozen": true
    },
    {
      "file_path": "extlib/libpng/pngrutil.c",
      "matched_lines": [
        281,
        284,
        287
      ],
      "context_lines": [
        276,
        277,
        278,
        279,
        280,
        282,
        283,
        285,
        286,
        288,
        289,
        290,
        291,
        292
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/libpng/pngrutil.c-276-      {",
        "extlib/libpng/pngrutil.c-277-#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)",
        "extlib/libpng/pngrutil.c-278-         char umsg[50];",
        "extlib/libpng/pngrutil.c-279-",
        "extlib/libpng/pngrutil.c-280-         if (ret == Z_BUF_ERROR)",
        "extlib/libpng/pngrutil.c:281:            sprintf(umsg,\"Buffer error in compressed datastream in %s chunk\",",
        "extlib/libpng/pngrutil.c-282-                png_ptr->chunk_name);",
        "extlib/libpng/pngrutil.c-283-         else if (ret == Z_DATA_ERROR)",
        "extlib/libpng/pngrutil.c:284:            sprintf(umsg,\"Data error in compressed datastream in %s chunk\",",
        "extlib/libpng/pngrutil.c-285-                png_ptr->chunk_name);",
        "extlib/libpng/pngrutil.c-286-         else",
        "extlib/libpng/pngrutil.c:287:            sprintf(umsg,\"Incomplete compressed datastream in %s chunk\",",
        "extlib/libpng/pngrutil.c-288-                png_ptr->chunk_name);",
        "extlib/libpng/pngrutil.c-289-         png_warning(png_ptr, umsg);",
        "extlib/libpng/pngrutil.c-290-#else",
        "extlib/libpng/pngrutil.c-291-         png_warning(png_ptr,",
        "extlib/libpng/pngrutil.c-292-            \"Incomplete compressed datastream in chunk other than IDAT\");"
      ],
      "raw_content": [
        "      {",
        "#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)",
        "         char umsg[50];",
        "",
        "         if (ret == Z_BUF_ERROR)",
        "            sprintf(umsg,\"Buffer error in compressed datastream in %s chunk\",",
        "                png_ptr->chunk_name);",
        "         else if (ret == Z_DATA_ERROR)",
        "            sprintf(umsg,\"Data error in compressed datastream in %s chunk\",",
        "                png_ptr->chunk_name);",
        "         else",
        "            sprintf(umsg,\"Incomplete compressed datastream in %s chunk\",",
        "                png_ptr->chunk_name);",
        "         png_warning(png_ptr, umsg);",
        "#else",
        "         png_warning(png_ptr,",
        "            \"Incomplete compressed datastream in chunk other than IDAT\");"
      ],
      "_frozen": true
    },
    {
      "file_path": "extlib/libpng/pngrutil.c",
      "matched_lines": [
        320
      ],
      "context_lines": [
        315,
        316,
        317,
        318,
        319,
        321,
        322,
        323,
        324,
        325
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/libpng/pngrutil.c-315-   else /* if (comp_type != PNG_COMPRESSION_TYPE_BASE) */",
        "extlib/libpng/pngrutil.c-316-   {",
        "extlib/libpng/pngrutil.c-317-#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)",
        "extlib/libpng/pngrutil.c-318-      char umsg[50];",
        "extlib/libpng/pngrutil.c-319-",
        "extlib/libpng/pngrutil.c:320:      sprintf(umsg, \"Unknown zTXt compression type %d\", comp_type);",
        "extlib/libpng/pngrutil.c-321-      png_warning(png_ptr, umsg);",
        "extlib/libpng/pngrutil.c-322-#else",
        "extlib/libpng/pngrutil.c-323-      png_warning(png_ptr, \"Unknown zTXt compression type\");",
        "extlib/libpng/pngrutil.c-324-#endif",
        "extlib/libpng/pngrutil.c-325-"
      ],
      "raw_content": [
        "   else /* if (comp_type != PNG_COMPRESSION_TYPE_BASE) */",
        "   {",
        "#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)",
        "      char umsg[50];",
        "",
        "      sprintf(umsg, \"Unknown zTXt compression type %d\", comp_type);",
        "      png_warning(png_ptr, umsg);",
        "#else",
        "      png_warning(png_ptr, \"Unknown zTXt compression type\");",
        "#endif",
        ""
      ],
      "_frozen": true
    },
    {
      "file_path": "extlib/libpng/pngvcrd.c",
      "matched_lines": [
        3695,
        3698,
        3701,
        3704,
        3707,
        3711,
        3713,
        3715,
        3717,
        3720
      ],
      "context_lines": [
        3690,
        3691,
        3692,
        3693,
        3694,
        3696,
        3697,
        3699,
        3700,
        3702,
        3703,
        3705,
        3706,
        3708,
        3709,
        3710,
        3712,
        3714,
        3716,
        3718,
        3719,
        3721,
        3722,
        3723,
        3724,
        3725
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/libpng/pngvcrd.c-3690-",
        "extlib/libpng/pngvcrd.c-3691-#ifdef PNG_DEBUG",
        "extlib/libpng/pngvcrd.c-3692-   png_debug(1, \"in png_read_filter_row\\n\");",
        "extlib/libpng/pngvcrd.c-3693-   switch (filter)",
        "extlib/libpng/pngvcrd.c-3694-   {",
        "extlib/libpng/pngvcrd.c:3695:      case 0: sprintf(filnm, \"none\");",
        "extlib/libpng/pngvcrd.c-3696-         break;",
        "extlib/libpng/pngvcrd.c-3697-#if !defined(PNG_1_0_X)",
        "extlib/libpng/pngvcrd.c:3698:      case 1: sprintf(filnm, \"sub-%s\",",
        "extlib/libpng/pngvcrd.c-3699-        (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_SUB)? \"MMX\" : \"x86\");",
        "extlib/libpng/pngvcrd.c-3700-         break;",
        "extlib/libpng/pngvcrd.c:3701:      case 2: sprintf(filnm, \"up-%s\",",
        "extlib/libpng/pngvcrd.c-3702-        (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_UP)? \"MMX\" : \"x86\");",
        "extlib/libpng/pngvcrd.c-3703-         break;",
        "extlib/libpng/pngvcrd.c:3704:      case 3: sprintf(filnm, \"avg-%s\",",
        "extlib/libpng/pngvcrd.c-3705-        (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_AVG)? \"MMX\" : \"x86\");",
        "extlib/libpng/pngvcrd.c-3706-         break;",
        "extlib/libpng/pngvcrd.c:3707:      case 4: sprintf(filnm, \"Paeth-%s\",",
        "extlib/libpng/pngvcrd.c-3708-        (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_PAETH)? \"MMX\":\"x86\");",
        "extlib/libpng/pngvcrd.c-3709-         break;",
        "extlib/libpng/pngvcrd.c-3710-#else",
        "extlib/libpng/pngvcrd.c:3711:      case 1: sprintf(filnm, \"sub\");",
        "extlib/libpng/pngvcrd.c-3712-         break;",
        "extlib/libpng/pngvcrd.c:3713:      case 2: sprintf(filnm, \"up\");",
        "extlib/libpng/pngvcrd.c-3714-         break;",
        "extlib/libpng/pngvcrd.c:3715:      case 3: sprintf(filnm, \"avg\");",
        "extlib/libpng/pngvcrd.c-3716-         break;",
        "extlib/libpng/pngvcrd.c:3717:      case 4: sprintf(filnm, \"Paeth\");",
        "extlib/libpng/pngvcrd.c-3718-         break;",
        "extlib/libpng/pngvcrd.c-3719-#endif",
        "extlib/libpng/pngvcrd.c:3720:      default: sprintf(filnm, \"unknw\");",
        "extlib/libpng/pngvcrd.c-3721-         break;",
        "extlib/libpng/pngvcrd.c-3722-   }",
        "extlib/libpng/pngvcrd.c-3723-   png_debug2(0,\"row=%5d, %s, \", png_ptr->row_number, filnm);",
        "extlib/libpng/pngvcrd.c-3724-   png_debug2(0, \"pd=%2d, b=%d, \", (int)row_info->pixel_depth,",
        "extlib/libpng/pngvcrd.c-3725-      (int)((row_info->pixel_depth + 7) >> 3));"
      ],
      "raw_content": [
        "",
        "#ifdef PNG_DEBUG",
        "   png_debug(1, \"in png_read_filter_row\\n\");",
        "   switch (filter)",
        "   {",
        "      case 0: sprintf(filnm, \"none\");",
        "         break;",
        "#if !defined(PNG_1_0_X)",
        "      case 1: sprintf(filnm, \"sub-%s\",",
        "        (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_SUB)? \"MMX\" : \"x86\");",
        "         break;",
        "      case 2: sprintf(filnm, \"up-%s\",",
        "        (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_UP)? \"MMX\" : \"x86\");",
        "         break;",
        "      case 3: sprintf(filnm, \"avg-%s\",",
        "        (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_AVG)? \"MMX\" : \"x86\");",
        "         break;",
        "      case 4: sprintf(filnm, \"Paeth-%s\",",
        "        (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_PAETH)? \"MMX\":\"x86\");",
        "         break;",
        "#else",
        "      case 1: sprintf(filnm, \"sub\");",
        "         break;",
        "      case 2: sprintf(filnm, \"up\");",
        "         break;",
        "      case 3: sprintf(filnm, \"avg\");",
        "         break;",
        "      case 4: sprintf(filnm, \"Paeth\");",
        "         break;",
        "#endif",
        "      default: sprintf(filnm, \"unknw\");",
        "         break;",
        "   }",
        "   png_debug2(0,\"row=%5d, %s, \", png_ptr->row_number, filnm);",
        "   png_debug2(0, \"pd=%2d, b=%d, \", (int)row_info->pixel_depth,",
        "      (int)((row_info->pixel_depth + 7) >> 3));"
      ],
      "_frozen": true
    },
    {
      "file_path": "extlib/libpng/pngwrite.c",
      "matched_lines": [
        511,
        515
      ],
      "context_lines": [
        506,
        507,
        508,
        509,
        510,
        512,
        513,
        514,
        516,
        517,
        518,
        519,
        520
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/libpng/pngwrite.c-506-     {",
        "extlib/libpng/pngwrite.c-507-#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)",
        "extlib/libpng/pngwrite.c-508-        char msg[80];",
        "extlib/libpng/pngwrite.c-509-        if (user_png_ver)",
        "extlib/libpng/pngwrite.c-510-        {",
        "extlib/libpng/pngwrite.c:511:          sprintf(msg, \"Application was compiled with png.h from libpng-%.20s\",",
        "extlib/libpng/pngwrite.c-512-             user_png_ver);",
        "extlib/libpng/pngwrite.c-513-          png_warning(png_ptr, msg);",
        "extlib/libpng/pngwrite.c-514-        }",
        "extlib/libpng/pngwrite.c:515:        sprintf(msg, \"Application  is  running with png.c from libpng-%.20s\",",
        "extlib/libpng/pngwrite.c-516-           png_libpng_ver);",
        "extlib/libpng/pngwrite.c-517-        png_warning(png_ptr, msg);",
        "extlib/libpng/pngwrite.c-518-#endif",
        "extlib/libpng/pngwrite.c-519-#ifdef PNG_ERROR_NUMBERS_SUPPORTED",
        "extlib/libpng/pngwrite.c-520-        png_ptr->flags=0;"
      ],
      "raw_content": [
        "     {",
        "#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)",
        "        char msg[80];",
        "        if (user_png_ver)",
        "        {",
        "          sprintf(msg, \"Application was compiled with png.h from libpng-%.20s\",",
        "             user_png_ver);",
        "          png_warning(png_ptr, msg);",
        "        }",
        "        sprintf(msg, \"Application  is  running with png.c from libpng-%.20s\",",
        "           png_libpng_ver);",
        "        png_warning(png_ptr, msg);",
        "#endif",
        "#ifdef PNG_ERROR_NUMBERS_SUPPORTED",
        "        png_ptr->flags=0;"
      ],
      "_frozen": true
    },
    {
      "file_path": "extlib/libpng/pngwrite.c",
      "matched_lines": [
        578,
        582
      ],
      "context_lines": [
        573,
        574,
        575,
        576,
        577,
        579,
        580,
        581,
        583,
        584,
        585,
        586,
        587
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/libpng/pngwrite.c-573-   {",
        "extlib/libpng/pngwrite.c-574-      char msg[80];",
        "extlib/libpng/pngwrite.c-575-      png_ptr->warning_fn=NULL;",
        "extlib/libpng/pngwrite.c-576-      if (user_png_ver)",
        "extlib/libpng/pngwrite.c-577-      {",
        "extlib/libpng/pngwrite.c:578:        sprintf(msg, \"Application was compiled with png.h from libpng-%.20s\",",
        "extlib/libpng/pngwrite.c-579-           user_png_ver);",
        "extlib/libpng/pngwrite.c-580-        png_warning(png_ptr, msg);",
        "extlib/libpng/pngwrite.c-581-      }",
        "extlib/libpng/pngwrite.c:582:      sprintf(msg, \"Application  is  running with png.c from libpng-%.20s\",",
        "extlib/libpng/pngwrite.c-583-         png_libpng_ver);",
        "extlib/libpng/pngwrite.c-584-      png_warning(png_ptr, msg);",
        "extlib/libpng/pngwrite.c-585-   }",
        "extlib/libpng/pngwrite.c-586-#endif",
        "extlib/libpng/pngwrite.c-587-   if(png_sizeof(png_struct) > png_struct_size)"
      ],
      "raw_content": [
        "   {",
        "      char msg[80];",
        "      png_ptr->warning_fn=NULL;",
        "      if (user_png_ver)",
        "      {",
        "        sprintf(msg, \"Application was compiled with png.h from libpng-%.20s\",",
        "           user_png_ver);",
        "        png_warning(png_ptr, msg);",
        "      }",
        "      sprintf(msg, \"Application  is  running with png.c from libpng-%.20s\",",
        "         png_libpng_ver);",
        "      png_warning(png_ptr, msg);",
        "   }",
        "#endif",
        "   if(png_sizeof(png_struct) > png_struct_size)"
      ],
      "_frozen": true
    },
    {
      "file_path": "extlib/libpng/pngwutil.c",
      "matched_lines": [
        180
      ],
      "context_lines": [
        175,
        176,
        177,
        178,
        179,
        181,
        182,
        183,
        184,
        185
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/libpng/pngwutil.c-175-",
        "extlib/libpng/pngwutil.c-176-   if (compression >= PNG_TEXT_COMPRESSION_LAST)",
        "extlib/libpng/pngwutil.c-177-   {",
        "extlib/libpng/pngwutil.c-178-#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)",
        "extlib/libpng/pngwutil.c-179-      char msg[50];",
        "extlib/libpng/pngwutil.c:180:      sprintf(msg, \"Unknown compression type %d\", compression);",
        "extlib/libpng/pngwutil.c-181-      png_warning(png_ptr, msg);",
        "extlib/libpng/pngwutil.c-182-#else",
        "extlib/libpng/pngwutil.c-183-      png_warning(png_ptr, \"Unknown compression type\");",
        "extlib/libpng/pngwutil.c-184-#endif",
        "extlib/libpng/pngwutil.c-185-   }"
      ],
      "raw_content": [
        "",
        "   if (compression >= PNG_TEXT_COMPRESSION_LAST)",
        "   {",
        "#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)",
        "      char msg[50];",
        "      sprintf(msg, \"Unknown compression type %d\", compression);",
        "      png_warning(png_ptr, msg);",
        "#else",
        "      png_warning(png_ptr, \"Unknown compression type\");",
        "#endif",
        "   }"
      ],
      "_frozen": true
    },
    {
      "file_path": "extlib/libpng/pngwutil.c",
      "matched_lines": [
        1207
      ],
      "context_lines": [
        1202,
        1203,
        1204,
        1205,
        1206,
        1208,
        1209,
        1210,
        1211,
        1212
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/libpng/pngwutil.c-1202-      if (*kp < 0x20 || (*kp > 0x7E && (png_byte)*kp < 0xA1))",
        "extlib/libpng/pngwutil.c-1203-      {",
        "extlib/libpng/pngwutil.c-1204-#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)",
        "extlib/libpng/pngwutil.c-1205-         char msg[40];",
        "extlib/libpng/pngwutil.c-1206-",
        "extlib/libpng/pngwutil.c:1207:         sprintf(msg, \"invalid keyword character 0x%02X\", *kp);",
        "extlib/libpng/pngwutil.c-1208-         png_warning(png_ptr, msg);",
        "extlib/libpng/pngwutil.c-1209-#else",
        "extlib/libpng/pngwutil.c-1210-         png_warning(png_ptr, \"invalid character in keyword\");",
        "extlib/libpng/pngwutil.c-1211-#endif",
        "extlib/libpng/pngwutil.c-1212-         *dp = ' ';"
      ],
      "raw_content": [
        "      if (*kp < 0x20 || (*kp > 0x7E && (png_byte)*kp < 0xA1))",
        "      {",
        "#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)",
        "         char msg[40];",
        "",
        "         sprintf(msg, \"invalid keyword character 0x%02X\", *kp);",
        "         png_warning(png_ptr, msg);",
        "#else",
        "         png_warning(png_ptr, \"invalid character in keyword\");",
        "#endif",
        "         *dp = ' ';"
      ],
      "_frozen": true
    },
    {
      "file_path": "extlib/libpng/pngwutil.c",
      "matched_lines": [
        1567,
        1576,
        1577
      ],
      "context_lines": [
        1562,
        1563,
        1564,
        1565,
        1566,
        1568,
        1569,
        1570,
        1571,
        1572,
        1573,
        1574,
        1575,
        1578,
        1579,
        1580,
        1581,
        1582
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/libpng/pngwutil.c-1562-   png_byte bunit = unit;",
        "extlib/libpng/pngwutil.c-1563-",
        "extlib/libpng/pngwutil.c-1564-   png_debug(1, \"in png_write_sCAL\\n\");",
        "extlib/libpng/pngwutil.c-1565-",
        "extlib/libpng/pngwutil.c-1566-#if defined(_WIN32_WCE)",
        "extlib/libpng/pngwutil.c:1567:/* sprintf() function is not supported on WindowsCE */",
        "extlib/libpng/pngwutil.c-1568-   {",
        "extlib/libpng/pngwutil.c-1569-      wchar_t wc_buf[32];",
        "extlib/libpng/pngwutil.c-1570-      swprintf(wc_buf, TEXT(\"%12.12e\"), width);",
        "extlib/libpng/pngwutil.c-1571-      WideCharToMultiByte(CP_ACP, 0, wc_buf, -1, wbuf, 32, NULL, NULL);",
        "extlib/libpng/pngwutil.c-1572-      swprintf(wc_buf, TEXT(\"%12.12e\"), height);",
        "extlib/libpng/pngwutil.c-1573-      WideCharToMultiByte(CP_ACP, 0, wc_buf, -1, hbuf, 32, NULL, NULL);",
        "extlib/libpng/pngwutil.c-1574-   }",
        "extlib/libpng/pngwutil.c-1575-#else",
        "extlib/libpng/pngwutil.c:1576:   sprintf(wbuf, \"%12.12e\", width);",
        "extlib/libpng/pngwutil.c:1577:   sprintf(hbuf, \"%12.12e\", height);",
        "extlib/libpng/pngwutil.c-1578-#endif",
        "extlib/libpng/pngwutil.c-1579-   total_len = 1 + png_strlen(wbuf)+1 + png_strlen(hbuf);",
        "extlib/libpng/pngwutil.c-1580-",
        "extlib/libpng/pngwutil.c-1581-   png_debug1(3, \"sCAL total length = %d\\n\", (int)total_len);",
        "extlib/libpng/pngwutil.c-1582-   png_write_chunk_start(png_ptr, (png_bytep)png_sCAL, (png_uint_32)total_len);"
      ],
      "raw_content": [
        "   png_byte bunit = unit;",
        "",
        "   png_debug(1, \"in png_write_sCAL\\n\");",
        "",
        "#if defined(_WIN32_WCE)",
        "/* sprintf() function is not supported on WindowsCE */",
        "   {",
        "      wchar_t wc_buf[32];",
        "      swprintf(wc_buf, TEXT(\"%12.12e\"), width);",
        "      WideCharToMultiByte(CP_ACP, 0, wc_buf, -1, wbuf, 32, NULL, NULL);",
        "      swprintf(wc_buf, TEXT(\"%12.12e\"), height);",
        "      WideCharToMultiByte(CP_ACP, 0, wc_buf, -1, hbuf, 32, NULL, NULL);",
        "   }",
        "#else",
        "   sprintf(wbuf, \"%12.12e\", width);",
        "   sprintf(hbuf, \"%12.12e\", height);",
        "#endif",
        "   total_len = 1 + png_strlen(wbuf)+1 + png_strlen(hbuf);",
        "",
        "   png_debug1(3, \"sCAL total length = %d\\n\", (int)total_len);",
        "   png_write_chunk_start(png_ptr, (png_bytep)png_sCAL, (png_uint_32)total_len);"
      ],
      "_frozen": true
    },
    {
      "file_path": "extlib/libtiff/tif_dirinfo.c",
      "matched_lines": [
        841
      ],
      "context_lines": [
        836,
        837,
        838,
        839,
        840,
        842,
        843,
        844,
        845,
        846
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/libtiff/tif_dirinfo.c-836-\t}",
        "extlib/libtiff/tif_dirinfo.c-837-",
        "extlib/libtiff/tif_dirinfo.c-838-\t/* note that this name is a special sign to TIFFClose() and",
        "extlib/libtiff/tif_dirinfo.c-839-\t * _TIFFSetupFieldInfo() to free the field",
        "extlib/libtiff/tif_dirinfo.c-840-\t */",
        "extlib/libtiff/tif_dirinfo.c:841:\tsprintf(fld->field_name, \"Tag %d\", (int) tag);",
        "extlib/libtiff/tif_dirinfo.c-842-",
        "extlib/libtiff/tif_dirinfo.c-843-\treturn fld;    ",
        "extlib/libtiff/tif_dirinfo.c-844-}",
        "extlib/libtiff/tif_dirinfo.c-845-",
        "extlib/libtiff/tif_dirinfo.c-846-/* vim: set ts=8 sts=8 sw=8 noet: */"
      ],
      "raw_content": [
        "\t}",
        "",
        "\t/* note that this name is a special sign to TIFFClose() and",
        "\t * _TIFFSetupFieldInfo() to free the field",
        "\t */",
        "\tsprintf(fld->field_name, \"Tag %d\", (int) tag);",
        "",
        "\treturn fld;    ",
        "}",
        "",
        "/* vim: set ts=8 sts=8 sw=8 noet: */"
      ],
      "_frozen": true
    },
    {
      "file_path": "extlib/libtiff/tif_getimage.c",
      "matched_lines": [
        80,
        88
      ],
      "context_lines": [
        75,
        76,
        77,
        78,
        79,
        81,
        82,
        83,
        84,
        85,
        86,
        87,
        89,
        90,
        91,
        92,
        93
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/libtiff/tif_getimage.c-75-    TIFFDirectory* td = &tif->tif_dir;",
        "extlib/libtiff/tif_getimage.c-76-    uint16 photometric;",
        "extlib/libtiff/tif_getimage.c-77-    int colorchannels;",
        "extlib/libtiff/tif_getimage.c-78-",
        "extlib/libtiff/tif_getimage.c-79-    if (!tif->tif_decodestatus) {",
        "extlib/libtiff/tif_getimage.c:80:\tsprintf(emsg, \"Sorry, requested compression method is not configured\");",
        "extlib/libtiff/tif_getimage.c-81-\treturn (0);",
        "extlib/libtiff/tif_getimage.c-82-    }",
        "extlib/libtiff/tif_getimage.c-83-    switch (td->td_bitspersample) {",
        "extlib/libtiff/tif_getimage.c-84-    case 1: case 2: case 4:",
        "extlib/libtiff/tif_getimage.c-85-    case 8: case 16:",
        "extlib/libtiff/tif_getimage.c-86-\tbreak;",
        "extlib/libtiff/tif_getimage.c-87-    default:",
        "extlib/libtiff/tif_getimage.c:88:\tsprintf(emsg, \"Sorry, can not handle images with %d-bit samples\",",
        "extlib/libtiff/tif_getimage.c-89-\t    td->td_bitspersample);",
        "extlib/libtiff/tif_getimage.c-90-\treturn (0);",
        "extlib/libtiff/tif_getimage.c-91-    }",
        "extlib/libtiff/tif_getimage.c-92-    colorchannels = td->td_samplesperpixel - td->td_extrasamples;",
        "extlib/libtiff/tif_getimage.c-93-    if (!TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric)) {"
      ],
      "raw_content": [
        "    TIFFDirectory* td = &tif->tif_dir;",
        "    uint16 photometric;",
        "    int colorchannels;",
        "",
        "    if (!tif->tif_decodestatus) {",
        "\tsprintf(emsg, \"Sorry, requested compression method is not configured\");",
        "\treturn (0);",
        "    }",
        "    switch (td->td_bitspersample) {",
        "    case 1: case 2: case 4:",
        "    case 8: case 16:",
        "\tbreak;",
        "    default:",
        "\tsprintf(emsg, \"Sorry, can not handle images with %d-bit samples\",",
        "\t    td->td_bitspersample);",
        "\treturn (0);",
        "    }",
        "    colorchannels = td->td_samplesperpixel - td->td_extrasamples;",
        "    if (!TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric)) {"
      ],
      "_frozen": true
    },
    {
      "file_path": "extlib/libtiff/tif_getimage.c",
      "matched_lines": [
        102,
        113
      ],
      "context_lines": [
        97,
        98,
        99,
        100,
        101,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        111,
        112,
        114,
        115,
        116,
        117,
        118
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/libtiff/tif_getimage.c-97-\t    break;",
        "extlib/libtiff/tif_getimage.c-98-\tcase 3:",
        "extlib/libtiff/tif_getimage.c-99-\t    photometric = PHOTOMETRIC_RGB;",
        "extlib/libtiff/tif_getimage.c-100-\t    break;",
        "extlib/libtiff/tif_getimage.c-101-\tdefault:",
        "extlib/libtiff/tif_getimage.c:102:\t    sprintf(emsg, \"Missing needed %s tag\", photoTag);",
        "extlib/libtiff/tif_getimage.c-103-\t    return (0);",
        "extlib/libtiff/tif_getimage.c-104-\t}",
        "extlib/libtiff/tif_getimage.c-105-    }",
        "extlib/libtiff/tif_getimage.c-106-    switch (photometric) {",
        "extlib/libtiff/tif_getimage.c-107-    case PHOTOMETRIC_MINISWHITE:",
        "extlib/libtiff/tif_getimage.c-108-    case PHOTOMETRIC_MINISBLACK:",
        "extlib/libtiff/tif_getimage.c-109-    case PHOTOMETRIC_PALETTE:",
        "extlib/libtiff/tif_getimage.c-110-\tif (td->td_planarconfig == PLANARCONFIG_CONTIG ",
        "extlib/libtiff/tif_getimage.c-111-            && td->td_samplesperpixel != 1",
        "extlib/libtiff/tif_getimage.c-112-            && td->td_bitspersample < 8 ) {",
        "extlib/libtiff/tif_getimage.c:113:\t    sprintf(emsg,",
        "extlib/libtiff/tif_getimage.c-114-                    \"Sorry, can not handle contiguous data with %s=%d, \"",
        "extlib/libtiff/tif_getimage.c-115-                    \"and %s=%d and Bits/Sample=%d\",",
        "extlib/libtiff/tif_getimage.c-116-                    photoTag, photometric,",
        "extlib/libtiff/tif_getimage.c-117-                    \"Samples/pixel\", td->td_samplesperpixel,",
        "extlib/libtiff/tif_getimage.c-118-                    td->td_bitspersample);"
      ],
      "raw_content": [
        "\t    break;",
        "\tcase 3:",
        "\t    photometric = PHOTOMETRIC_RGB;",
        "\t    break;",
        "\tdefault:",
        "\t    sprintf(emsg, \"Missing needed %s tag\", photoTag);",
        "\t    return (0);",
        "\t}",
        "    }",
        "    switch (photometric) {",
        "    case PHOTOMETRIC_MINISWHITE:",
        "    case PHOTOMETRIC_MINISBLACK:",
        "    case PHOTOMETRIC_PALETTE:",
        "\tif (td->td_planarconfig == PLANARCONFIG_CONTIG ",
        "            && td->td_samplesperpixel != 1",
        "            && td->td_bitspersample < 8 ) {",
        "\t    sprintf(emsg,",
        "                    \"Sorry, can not handle contiguous data with %s=%d, \"",
        "                    \"and %s=%d and Bits/Sample=%d\",",
        "                    photoTag, photometric,",
        "                    \"Samples/pixel\", td->td_samplesperpixel,",
        "                    td->td_bitspersample);"
      ],
      "_frozen": true
    },
    {
      "file_path": "extlib/libtiff/tif_getimage.c",
      "matched_lines": [
        129,
        136,
        146,
        152,
        161,
        169,
        174,
        182
      ],
      "context_lines": [
        124,
        125,
        126,
        127,
        128,
        130,
        131,
        132,
        133,
        134,
        135,
        137,
        138,
        139,
        140,
        141,
        142,
        143,
        144,
        145,
        147,
        148,
        149,
        150,
        151,
        153,
        154,
        155,
        156,
        157,
        158,
        159,
        160,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        170,
        171,
        172,
        173,
        175,
        176,
        177,
        178,
        179,
        180,
        181,
        183,
        184,
        185,
        186,
        187
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/libtiff/tif_getimage.c-124-        ** them.  But for now we won't bother with this. ",
        "extlib/libtiff/tif_getimage.c-125-        */",
        "extlib/libtiff/tif_getimage.c-126-\tbreak;",
        "extlib/libtiff/tif_getimage.c-127-    case PHOTOMETRIC_YCBCR:",
        "extlib/libtiff/tif_getimage.c-128-\tif (td->td_planarconfig != PLANARCONFIG_CONTIG) {",
        "extlib/libtiff/tif_getimage.c:129:\t    sprintf(emsg, \"Sorry, can not handle YCbCr images with %s=%d\",",
        "extlib/libtiff/tif_getimage.c-130-\t\t\"Planarconfiguration\", td->td_planarconfig);",
        "extlib/libtiff/tif_getimage.c-131-\t    return (0);",
        "extlib/libtiff/tif_getimage.c-132-\t}",
        "extlib/libtiff/tif_getimage.c-133-\tbreak;",
        "extlib/libtiff/tif_getimage.c-134-    case PHOTOMETRIC_RGB: ",
        "extlib/libtiff/tif_getimage.c-135-\tif (colorchannels < 3) {",
        "extlib/libtiff/tif_getimage.c:136:\t    sprintf(emsg, \"Sorry, can not handle RGB image with %s=%d\",",
        "extlib/libtiff/tif_getimage.c-137-\t\t\"Color channels\", colorchannels);",
        "extlib/libtiff/tif_getimage.c-138-\t    return (0);",
        "extlib/libtiff/tif_getimage.c-139-\t}",
        "extlib/libtiff/tif_getimage.c-140-\tbreak;",
        "extlib/libtiff/tif_getimage.c-141-    case PHOTOMETRIC_SEPARATED:",
        "extlib/libtiff/tif_getimage.c-142-\t{",
        "extlib/libtiff/tif_getimage.c-143-\t\tuint16 inkset;",
        "extlib/libtiff/tif_getimage.c-144-\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_INKSET, &inkset);",
        "extlib/libtiff/tif_getimage.c-145-\t\tif (inkset != INKSET_CMYK) {",
        "extlib/libtiff/tif_getimage.c:146:\t\t    sprintf(emsg,",
        "extlib/libtiff/tif_getimage.c-147-\t\t\t    \"Sorry, can not handle separated image with %s=%d\",",
        "extlib/libtiff/tif_getimage.c-148-\t\t\t    \"InkSet\", inkset);",
        "extlib/libtiff/tif_getimage.c-149-\t\t    return 0;",
        "extlib/libtiff/tif_getimage.c-150-\t\t}",
        "extlib/libtiff/tif_getimage.c-151-\t\tif (td->td_samplesperpixel < 4) {",
        "extlib/libtiff/tif_getimage.c:152:\t\t    sprintf(emsg,",
        "extlib/libtiff/tif_getimage.c-153-\t\t\t    \"Sorry, can not handle separated image with %s=%d\",",
        "extlib/libtiff/tif_getimage.c-154-\t\t\t    \"Samples/pixel\", td->td_samplesperpixel);",
        "extlib/libtiff/tif_getimage.c-155-\t\t    return 0;",
        "extlib/libtiff/tif_getimage.c-156-\t\t}",
        "extlib/libtiff/tif_getimage.c-157-\t\tbreak;",
        "extlib/libtiff/tif_getimage.c-158-\t}",
        "extlib/libtiff/tif_getimage.c-159-    case PHOTOMETRIC_LOGL:",
        "extlib/libtiff/tif_getimage.c-160-\tif (td->td_compression != COMPRESSION_SGILOG) {",
        "extlib/libtiff/tif_getimage.c:161:\t    sprintf(emsg, \"Sorry, LogL data must have %s=%d\",",
        "extlib/libtiff/tif_getimage.c-162-\t\t\"Compression\", COMPRESSION_SGILOG);",
        "extlib/libtiff/tif_getimage.c-163-\t    return (0);",
        "extlib/libtiff/tif_getimage.c-164-\t}",
        "extlib/libtiff/tif_getimage.c-165-\tbreak;",
        "extlib/libtiff/tif_getimage.c-166-    case PHOTOMETRIC_LOGLUV:",
        "extlib/libtiff/tif_getimage.c-167-\tif (td->td_compression != COMPRESSION_SGILOG &&",
        "extlib/libtiff/tif_getimage.c-168-\t\ttd->td_compression != COMPRESSION_SGILOG24) {",
        "extlib/libtiff/tif_getimage.c:169:\t    sprintf(emsg, \"Sorry, LogLuv data must have %s=%d or %d\",",
        "extlib/libtiff/tif_getimage.c-170-\t\t\"Compression\", COMPRESSION_SGILOG, COMPRESSION_SGILOG24);",
        "extlib/libtiff/tif_getimage.c-171-\t    return (0);",
        "extlib/libtiff/tif_getimage.c-172-\t}",
        "extlib/libtiff/tif_getimage.c-173-\tif (td->td_planarconfig != PLANARCONFIG_CONTIG) {",
        "extlib/libtiff/tif_getimage.c:174:\t    sprintf(emsg, \"Sorry, can not handle LogLuv images with %s=%d\",",
        "extlib/libtiff/tif_getimage.c-175-\t\t\"Planarconfiguration\", td->td_planarconfig);",
        "extlib/libtiff/tif_getimage.c-176-\t    return (0);",
        "extlib/libtiff/tif_getimage.c-177-\t}",
        "extlib/libtiff/tif_getimage.c-178-\tbreak;",
        "extlib/libtiff/tif_getimage.c-179-    case PHOTOMETRIC_CIELAB:",
        "extlib/libtiff/tif_getimage.c-180-\tbreak;",
        "extlib/libtiff/tif_getimage.c-181-    default:",
        "extlib/libtiff/tif_getimage.c:182:\tsprintf(emsg, \"Sorry, can not handle image with %s=%d\",",
        "extlib/libtiff/tif_getimage.c-183-\t    photoTag, photometric);",
        "extlib/libtiff/tif_getimage.c-184-\treturn (0);",
        "extlib/libtiff/tif_getimage.c-185-    }",
        "extlib/libtiff/tif_getimage.c-186-    return (1);",
        "extlib/libtiff/tif_getimage.c-187-}"
      ],
      "raw_content": [
        "        ** them.  But for now we won't bother with this. ",
        "        */",
        "\tbreak;",
        "    case PHOTOMETRIC_YCBCR:",
        "\tif (td->td_planarconfig != PLANARCONFIG_CONTIG) {",
        "\t    sprintf(emsg, \"Sorry, can not handle YCbCr images with %s=%d\",",
        "\t\t\"Planarconfiguration\", td->td_planarconfig);",
        "\t    return (0);",
        "\t}",
        "\tbreak;",
        "    case PHOTOMETRIC_RGB: ",
        "\tif (colorchannels < 3) {",
        "\t    sprintf(emsg, \"Sorry, can not handle RGB image with %s=%d\",",
        "\t\t\"Color channels\", colorchannels);",
        "\t    return (0);",
        "\t}",
        "\tbreak;",
        "    case PHOTOMETRIC_SEPARATED:",
        "\t{",
        "\t\tuint16 inkset;",
        "\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_INKSET, &inkset);",
        "\t\tif (inkset != INKSET_CMYK) {",
        "\t\t    sprintf(emsg,",
        "\t\t\t    \"Sorry, can not handle separated image with %s=%d\",",
        "\t\t\t    \"InkSet\", inkset);",
        "\t\t    return 0;",
        "\t\t}",
        "\t\tif (td->td_samplesperpixel < 4) {",
        "\t\t    sprintf(emsg,",
        "\t\t\t    \"Sorry, can not handle separated image with %s=%d\",",
        "\t\t\t    \"Samples/pixel\", td->td_samplesperpixel);",
        "\t\t    return 0;",
        "\t\t}",
        "\t\tbreak;",
        "\t}",
        "    case PHOTOMETRIC_LOGL:",
        "\tif (td->td_compression != COMPRESSION_SGILOG) {",
        "\t    sprintf(emsg, \"Sorry, LogL data must have %s=%d\",",
        "\t\t\"Compression\", COMPRESSION_SGILOG);",
        "\t    return (0);",
        "\t}",
        "\tbreak;",
        "    case PHOTOMETRIC_LOGLUV:",
        "\tif (td->td_compression != COMPRESSION_SGILOG &&",
        "\t\ttd->td_compression != COMPRESSION_SGILOG24) {",
        "\t    sprintf(emsg, \"Sorry, LogLuv data must have %s=%d or %d\",",
        "\t\t\"Compression\", COMPRESSION_SGILOG, COMPRESSION_SGILOG24);",
        "\t    return (0);",
        "\t}",
        "\tif (td->td_planarconfig != PLANARCONFIG_CONTIG) {",
        "\t    sprintf(emsg, \"Sorry, can not handle LogLuv images with %s=%d\",",
        "\t\t\"Planarconfiguration\", td->td_planarconfig);",
        "\t    return (0);",
        "\t}",
        "\tbreak;",
        "    case PHOTOMETRIC_CIELAB:",
        "\tbreak;",
        "    default:",
        "\tsprintf(emsg, \"Sorry, can not handle image with %s=%d\",",
        "\t    photoTag, photometric);",
        "\treturn (0);",
        "    }",
        "    return (1);",
        "}"
      ],
      "_frozen": true
    },
    {
      "file_path": "extlib/libtiff/tif_getimage.c",
      "matched_lines": [
        248
      ],
      "context_lines": [
        243,
        244,
        245,
        246,
        247,
        249,
        250,
        251,
        252,
        253
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/libtiff/tif_getimage.c-243-    switch (img->bitspersample) {",
        "extlib/libtiff/tif_getimage.c-244-    case 1: case 2: case 4:",
        "extlib/libtiff/tif_getimage.c-245-    case 8: case 16:",
        "extlib/libtiff/tif_getimage.c-246-\tbreak;",
        "extlib/libtiff/tif_getimage.c-247-    default:",
        "extlib/libtiff/tif_getimage.c:248:\tsprintf(emsg, \"Sorry, can not handle images with %d-bit samples\",",
        "extlib/libtiff/tif_getimage.c-249-\t    img->bitspersample);",
        "extlib/libtiff/tif_getimage.c-250-\treturn (0);",
        "extlib/libtiff/tif_getimage.c-251-    }",
        "extlib/libtiff/tif_getimage.c-252-    img->alpha = 0;",
        "extlib/libtiff/tif_getimage.c-253-    TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &img->samplesperpixel);"
      ],
      "raw_content": [
        "    switch (img->bitspersample) {",
        "    case 1: case 2: case 4:",
        "    case 8: case 16:",
        "\tbreak;",
        "    default:",
        "\tsprintf(emsg, \"Sorry, can not handle images with %d-bit samples\",",
        "\t    img->bitspersample);",
        "\treturn (0);",
        "    }",
        "    img->alpha = 0;",
        "    TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &img->samplesperpixel);"
      ],
      "_frozen": true
    },
    {
      "file_path": "extlib/libtiff/tif_getimage.c",
      "matched_lines": [
        298,
        306,
        316
      ],
      "context_lines": [
        293,
        294,
        295,
        296,
        297,
        299,
        300,
        301,
        302,
        303,
        304,
        305,
        307,
        308,
        309,
        310,
        311,
        312,
        313,
        314,
        315,
        317,
        318,
        319,
        320,
        321
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/libtiff/tif_getimage.c-293-\t    break;",
        "extlib/libtiff/tif_getimage.c-294-\tcase 3:",
        "extlib/libtiff/tif_getimage.c-295-\t    img->photometric = PHOTOMETRIC_RGB;",
        "extlib/libtiff/tif_getimage.c-296-\t    break;",
        "extlib/libtiff/tif_getimage.c-297-\tdefault:",
        "extlib/libtiff/tif_getimage.c:298:\t    sprintf(emsg, \"Missing needed %s tag\", photoTag);",
        "extlib/libtiff/tif_getimage.c-299-\t    return (0);",
        "extlib/libtiff/tif_getimage.c-300-\t}",
        "extlib/libtiff/tif_getimage.c-301-    }",
        "extlib/libtiff/tif_getimage.c-302-    switch (img->photometric) {",
        "extlib/libtiff/tif_getimage.c-303-    case PHOTOMETRIC_PALETTE:",
        "extlib/libtiff/tif_getimage.c-304-\tif (!TIFFGetField(tif, TIFFTAG_COLORMAP,",
        "extlib/libtiff/tif_getimage.c-305-\t    &red_orig, &green_orig, &blue_orig)) {",
        "extlib/libtiff/tif_getimage.c:306:\t    sprintf(emsg, \"Missing required \\\"Colormap\\\" tag\");",
        "extlib/libtiff/tif_getimage.c-307-\t    return (0);",
        "extlib/libtiff/tif_getimage.c-308-\t}",
        "extlib/libtiff/tif_getimage.c-309-",
        "extlib/libtiff/tif_getimage.c-310-        /* copy the colormaps so we can modify them */",
        "extlib/libtiff/tif_getimage.c-311-        n_color = (1L << img->bitspersample);",
        "extlib/libtiff/tif_getimage.c-312-        img->redcmap = (uint16 *) _TIFFmalloc(sizeof(uint16)*n_color);",
        "extlib/libtiff/tif_getimage.c-313-        img->greencmap = (uint16 *) _TIFFmalloc(sizeof(uint16)*n_color);",
        "extlib/libtiff/tif_getimage.c-314-        img->bluecmap = (uint16 *) _TIFFmalloc(sizeof(uint16)*n_color);",
        "extlib/libtiff/tif_getimage.c-315-        if( !img->redcmap || !img->greencmap || !img->bluecmap ) {",
        "extlib/libtiff/tif_getimage.c:316:\t    sprintf(emsg, \"Out of memory for colormap copy\");",
        "extlib/libtiff/tif_getimage.c-317-\t    return (0);",
        "extlib/libtiff/tif_getimage.c-318-        }",
        "extlib/libtiff/tif_getimage.c-319-",
        "extlib/libtiff/tif_getimage.c-320-        _TIFFmemcpy( img->redcmap, red_orig, n_color * 2 );",
        "extlib/libtiff/tif_getimage.c-321-        _TIFFmemcpy( img->greencmap, green_orig, n_color * 2 );"
      ],
      "raw_content": [
        "\t    break;",
        "\tcase 3:",
        "\t    img->photometric = PHOTOMETRIC_RGB;",
        "\t    break;",
        "\tdefault:",
        "\t    sprintf(emsg, \"Missing needed %s tag\", photoTag);",
        "\t    return (0);",
        "\t}",
        "    }",
        "    switch (img->photometric) {",
        "    case PHOTOMETRIC_PALETTE:",
        "\tif (!TIFFGetField(tif, TIFFTAG_COLORMAP,",
        "\t    &red_orig, &green_orig, &blue_orig)) {",
        "\t    sprintf(emsg, \"Missing required \\\"Colormap\\\" tag\");",
        "\t    return (0);",
        "\t}",
        "",
        "        /* copy the colormaps so we can modify them */",
        "        n_color = (1L << img->bitspersample);",
        "        img->redcmap = (uint16 *) _TIFFmalloc(sizeof(uint16)*n_color);",
        "        img->greencmap = (uint16 *) _TIFFmalloc(sizeof(uint16)*n_color);",
        "        img->bluecmap = (uint16 *) _TIFFmalloc(sizeof(uint16)*n_color);",
        "        if( !img->redcmap || !img->greencmap || !img->bluecmap ) {",
        "\t    sprintf(emsg, \"Out of memory for colormap copy\");",
        "\t    return (0);",
        "        }",
        "",
        "        _TIFFmemcpy( img->redcmap, red_orig, n_color * 2 );",
        "        _TIFFmemcpy( img->greencmap, green_orig, n_color * 2 );"
      ],
      "_frozen": true
    },
    {
      "file_path": "extlib/libtiff/tif_getimage.c",
      "matched_lines": [
        330,
        341
      ],
      "context_lines": [
        325,
        326,
        327,
        328,
        329,
        331,
        332,
        333,
        334,
        335,
        336,
        337,
        338,
        339,
        340,
        342,
        343,
        344,
        345,
        346
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/libtiff/tif_getimage.c-325-    case PHOTOMETRIC_MINISWHITE:",
        "extlib/libtiff/tif_getimage.c-326-    case PHOTOMETRIC_MINISBLACK:",
        "extlib/libtiff/tif_getimage.c-327-\tif (planarconfig == PLANARCONFIG_CONTIG ",
        "extlib/libtiff/tif_getimage.c-328-            && img->samplesperpixel != 1",
        "extlib/libtiff/tif_getimage.c-329-            && img->bitspersample < 8 ) {",
        "extlib/libtiff/tif_getimage.c:330:\t    sprintf(emsg,",
        "extlib/libtiff/tif_getimage.c-331-                    \"Sorry, can not handle contiguous data with %s=%d, \"",
        "extlib/libtiff/tif_getimage.c-332-                    \"and %s=%d and Bits/Sample=%d\",",
        "extlib/libtiff/tif_getimage.c-333-                    photoTag, img->photometric,",
        "extlib/libtiff/tif_getimage.c-334-                    \"Samples/pixel\", img->samplesperpixel,",
        "extlib/libtiff/tif_getimage.c-335-                    img->bitspersample);",
        "extlib/libtiff/tif_getimage.c-336-\t    return (0);",
        "extlib/libtiff/tif_getimage.c-337-\t}",
        "extlib/libtiff/tif_getimage.c-338-\tbreak;",
        "extlib/libtiff/tif_getimage.c-339-    case PHOTOMETRIC_YCBCR:",
        "extlib/libtiff/tif_getimage.c-340-\tif (planarconfig != PLANARCONFIG_CONTIG) {",
        "extlib/libtiff/tif_getimage.c:341:\t    sprintf(emsg, \"Sorry, can not handle YCbCr images with %s=%d\",",
        "extlib/libtiff/tif_getimage.c-342-\t\t\"Planarconfiguration\", planarconfig);",
        "extlib/libtiff/tif_getimage.c-343-\t    return (0);",
        "extlib/libtiff/tif_getimage.c-344-\t}",
        "extlib/libtiff/tif_getimage.c-345-\t/* It would probably be nice to have a reality check here. */",
        "extlib/libtiff/tif_getimage.c-346-\tif (planarconfig == PLANARCONFIG_CONTIG)"
      ],
      "raw_content": [
        "    case PHOTOMETRIC_MINISWHITE:",
        "    case PHOTOMETRIC_MINISBLACK:",
        "\tif (planarconfig == PLANARCONFIG_CONTIG ",
        "            && img->samplesperpixel != 1",
        "            && img->bitspersample < 8 ) {",
        "\t    sprintf(emsg,",
        "                    \"Sorry, can not handle contiguous data with %s=%d, \"",
        "                    \"and %s=%d and Bits/Sample=%d\",",
        "                    photoTag, img->photometric,",
        "                    \"Samples/pixel\", img->samplesperpixel,",
        "                    img->bitspersample);",
        "\t    return (0);",
        "\t}",
        "\tbreak;",
        "    case PHOTOMETRIC_YCBCR:",
        "\tif (planarconfig != PLANARCONFIG_CONTIG) {",
        "\t    sprintf(emsg, \"Sorry, can not handle YCbCr images with %s=%d\",",
        "\t\t\"Planarconfiguration\", planarconfig);",
        "\t    return (0);",
        "\t}",
        "\t/* It would probably be nice to have a reality check here. */",
        "\tif (planarconfig == PLANARCONFIG_CONTIG)"
      ],
      "_frozen": true
    },
    {
      "file_path": "extlib/libtiff/tif_getimage.c",
      "matched_lines": [
        363,
        372,
        377,
        385,
        395,
        400,
        411
      ],
      "context_lines": [
        358,
        359,
        360,
        361,
        362,
        364,
        365,
        366,
        367,
        368,
        369,
        370,
        371,
        373,
        374,
        375,
        376,
        378,
        379,
        380,
        381,
        382,
        383,
        384,
        386,
        387,
        388,
        389,
        390,
        391,
        392,
        393,
        394,
        396,
        397,
        398,
        399,
        401,
        402,
        403,
        404,
        405,
        406,
        407,
        408,
        409,
        410,
        412,
        413,
        414,
        415,
        416
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/libtiff/tif_getimage.c-358-                    break;",
        "extlib/libtiff/tif_getimage.c-359-\t    }",
        "extlib/libtiff/tif_getimage.c-360-\tbreak;",
        "extlib/libtiff/tif_getimage.c-361-    case PHOTOMETRIC_RGB: ",
        "extlib/libtiff/tif_getimage.c-362-\tif (colorchannels < 3) {",
        "extlib/libtiff/tif_getimage.c:363:\t    sprintf(emsg, \"Sorry, can not handle RGB image with %s=%d\",",
        "extlib/libtiff/tif_getimage.c-364-\t\t\"Color channels\", colorchannels);",
        "extlib/libtiff/tif_getimage.c-365-\t    return (0);",
        "extlib/libtiff/tif_getimage.c-366-\t}",
        "extlib/libtiff/tif_getimage.c-367-\tbreak;",
        "extlib/libtiff/tif_getimage.c-368-    case PHOTOMETRIC_SEPARATED: {",
        "extlib/libtiff/tif_getimage.c-369-\tuint16 inkset;",
        "extlib/libtiff/tif_getimage.c-370-\tTIFFGetFieldDefaulted(tif, TIFFTAG_INKSET, &inkset);",
        "extlib/libtiff/tif_getimage.c-371-\tif (inkset != INKSET_CMYK) {",
        "extlib/libtiff/tif_getimage.c:372:\t    sprintf(emsg, \"Sorry, can not handle separated image with %s=%d\",",
        "extlib/libtiff/tif_getimage.c-373-\t\t\"InkSet\", inkset);",
        "extlib/libtiff/tif_getimage.c-374-\t    return (0);",
        "extlib/libtiff/tif_getimage.c-375-\t}",
        "extlib/libtiff/tif_getimage.c-376-\tif (img->samplesperpixel < 4) {",
        "extlib/libtiff/tif_getimage.c:377:\t    sprintf(emsg, \"Sorry, can not handle separated image with %s=%d\",",
        "extlib/libtiff/tif_getimage.c-378-\t\t\"Samples/pixel\", img->samplesperpixel);",
        "extlib/libtiff/tif_getimage.c-379-\t    return (0);",
        "extlib/libtiff/tif_getimage.c-380-\t}",
        "extlib/libtiff/tif_getimage.c-381-\tbreak;",
        "extlib/libtiff/tif_getimage.c-382-    }",
        "extlib/libtiff/tif_getimage.c-383-    case PHOTOMETRIC_LOGL:",
        "extlib/libtiff/tif_getimage.c-384-\tif (compress != COMPRESSION_SGILOG) {",
        "extlib/libtiff/tif_getimage.c:385:\t    sprintf(emsg, \"Sorry, LogL data must have %s=%d\",",
        "extlib/libtiff/tif_getimage.c-386-\t\t\"Compression\", COMPRESSION_SGILOG);",
        "extlib/libtiff/tif_getimage.c-387-\t    return (0);",
        "extlib/libtiff/tif_getimage.c-388-\t}",
        "extlib/libtiff/tif_getimage.c-389-\tTIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_8BIT);",
        "extlib/libtiff/tif_getimage.c-390-\timg->photometric = PHOTOMETRIC_MINISBLACK;\t/* little white lie */",
        "extlib/libtiff/tif_getimage.c-391-\timg->bitspersample = 8;",
        "extlib/libtiff/tif_getimage.c-392-\tbreak;",
        "extlib/libtiff/tif_getimage.c-393-    case PHOTOMETRIC_LOGLUV:",
        "extlib/libtiff/tif_getimage.c-394-\tif (compress != COMPRESSION_SGILOG && compress != COMPRESSION_SGILOG24) {",
        "extlib/libtiff/tif_getimage.c:395:\t    sprintf(emsg, \"Sorry, LogLuv data must have %s=%d or %d\",",
        "extlib/libtiff/tif_getimage.c-396-\t\t\"Compression\", COMPRESSION_SGILOG, COMPRESSION_SGILOG24);",
        "extlib/libtiff/tif_getimage.c-397-\t    return (0);",
        "extlib/libtiff/tif_getimage.c-398-\t}",
        "extlib/libtiff/tif_getimage.c-399-\tif (planarconfig != PLANARCONFIG_CONTIG) {",
        "extlib/libtiff/tif_getimage.c:400:\t    sprintf(emsg, \"Sorry, can not handle LogLuv images with %s=%d\",",
        "extlib/libtiff/tif_getimage.c-401-\t\t\"Planarconfiguration\", planarconfig);",
        "extlib/libtiff/tif_getimage.c-402-\t    return (0);",
        "extlib/libtiff/tif_getimage.c-403-\t}",
        "extlib/libtiff/tif_getimage.c-404-\tTIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_8BIT);",
        "extlib/libtiff/tif_getimage.c-405-\timg->photometric = PHOTOMETRIC_RGB;\t\t/* little white lie */",
        "extlib/libtiff/tif_getimage.c-406-\timg->bitspersample = 8;",
        "extlib/libtiff/tif_getimage.c-407-\tbreak;",
        "extlib/libtiff/tif_getimage.c-408-    case PHOTOMETRIC_CIELAB:",
        "extlib/libtiff/tif_getimage.c-409-\tbreak;",
        "extlib/libtiff/tif_getimage.c-410-    default:",
        "extlib/libtiff/tif_getimage.c:411:\tsprintf(emsg, \"Sorry, can not handle image with %s=%d\",",
        "extlib/libtiff/tif_getimage.c-412-\t    photoTag, img->photometric);",
        "extlib/libtiff/tif_getimage.c-413-\treturn (0);",
        "extlib/libtiff/tif_getimage.c-414-    }",
        "extlib/libtiff/tif_getimage.c-415-    img->Map = NULL;",
        "extlib/libtiff/tif_getimage.c-416-    img->BWmap = NULL;"
      ],
      "raw_content": [
        "                    break;",
        "\t    }",
        "\tbreak;",
        "    case PHOTOMETRIC_RGB: ",
        "\tif (colorchannels < 3) {",
        "\t    sprintf(emsg, \"Sorry, can not handle RGB image with %s=%d\",",
        "\t\t\"Color channels\", colorchannels);",
        "\t    return (0);",
        "\t}",
        "\tbreak;",
        "    case PHOTOMETRIC_SEPARATED: {",
        "\tuint16 inkset;",
        "\tTIFFGetFieldDefaulted(tif, TIFFTAG_INKSET, &inkset);",
        "\tif (inkset != INKSET_CMYK) {",
        "\t    sprintf(emsg, \"Sorry, can not handle separated image with %s=%d\",",
        "\t\t\"InkSet\", inkset);",
        "\t    return (0);",
        "\t}",
        "\tif (img->samplesperpixel < 4) {",
        "\t    sprintf(emsg, \"Sorry, can not handle separated image with %s=%d\",",
        "\t\t\"Samples/pixel\", img->samplesperpixel);",
        "\t    return (0);",
        "\t}",
        "\tbreak;",
        "    }",
        "    case PHOTOMETRIC_LOGL:",
        "\tif (compress != COMPRESSION_SGILOG) {",
        "\t    sprintf(emsg, \"Sorry, LogL data must have %s=%d\",",
        "\t\t\"Compression\", COMPRESSION_SGILOG);",
        "\t    return (0);",
        "\t}",
        "\tTIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_8BIT);",
        "\timg->photometric = PHOTOMETRIC_MINISBLACK;\t/* little white lie */",
        "\timg->bitspersample = 8;",
        "\tbreak;",
        "    case PHOTOMETRIC_LOGLUV:",
        "\tif (compress != COMPRESSION_SGILOG && compress != COMPRESSION_SGILOG24) {",
        "\t    sprintf(emsg, \"Sorry, LogLuv data must have %s=%d or %d\",",
        "\t\t\"Compression\", COMPRESSION_SGILOG, COMPRESSION_SGILOG24);",
        "\t    return (0);",
        "\t}",
        "\tif (planarconfig != PLANARCONFIG_CONTIG) {",
        "\t    sprintf(emsg, \"Sorry, can not handle LogLuv images with %s=%d\",",
        "\t\t\"Planarconfiguration\", planarconfig);",
        "\t    return (0);",
        "\t}",
        "\tTIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_8BIT);",
        "\timg->photometric = PHOTOMETRIC_RGB;\t\t/* little white lie */",
        "\timg->bitspersample = 8;",
        "\tbreak;",
        "    case PHOTOMETRIC_CIELAB:",
        "\tbreak;",
        "    default:",
        "\tsprintf(emsg, \"Sorry, can not handle image with %s=%d\",",
        "\t    photoTag, img->photometric);",
        "\treturn (0);",
        "    }",
        "    img->Map = NULL;",
        "    img->BWmap = NULL;"
      ],
      "_frozen": true
    },
    {
      "file_path": "extlib/libtiff/tif_getimage.c",
      "matched_lines": [
        428,
        434
      ],
      "context_lines": [
        423,
        424,
        425,
        426,
        427,
        429,
        430,
        431,
        432,
        433,
        435,
        436,
        437,
        438,
        439
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/libtiff/tif_getimage.c-423-    img->isContig =",
        "extlib/libtiff/tif_getimage.c-424-\t!(planarconfig == PLANARCONFIG_SEPARATE && colorchannels > 1);",
        "extlib/libtiff/tif_getimage.c-425-    if (img->isContig) {",
        "extlib/libtiff/tif_getimage.c-426-\timg->get = TIFFIsTiled(tif) ? gtTileContig : gtStripContig;",
        "extlib/libtiff/tif_getimage.c-427-\tif (!pickTileContigCase(img)) {",
        "extlib/libtiff/tif_getimage.c:428:\t\tsprintf(emsg, \"Sorry, can not handle image\");",
        "extlib/libtiff/tif_getimage.c-429-\t\treturn 0;",
        "extlib/libtiff/tif_getimage.c-430-\t}",
        "extlib/libtiff/tif_getimage.c-431-    } else {",
        "extlib/libtiff/tif_getimage.c-432-\timg->get = TIFFIsTiled(tif) ? gtTileSeparate : gtStripSeparate;",
        "extlib/libtiff/tif_getimage.c-433-\tif (!pickTileSeparateCase(img)) {",
        "extlib/libtiff/tif_getimage.c:434:\t\tsprintf(emsg, \"Sorry, can not handle image\");",
        "extlib/libtiff/tif_getimage.c-435-\t\treturn 0;",
        "extlib/libtiff/tif_getimage.c-436-\t}",
        "extlib/libtiff/tif_getimage.c-437-    }",
        "extlib/libtiff/tif_getimage.c-438-    return 1;",
        "extlib/libtiff/tif_getimage.c-439-}"
      ],
      "raw_content": [
        "    img->isContig =",
        "\t!(planarconfig == PLANARCONFIG_SEPARATE && colorchannels > 1);",
        "    if (img->isContig) {",
        "\timg->get = TIFFIsTiled(tif) ? gtTileContig : gtStripContig;",
        "\tif (!pickTileContigCase(img)) {",
        "\t\tsprintf(emsg, \"Sorry, can not handle image\");",
        "\t\treturn 0;",
        "\t}",
        "    } else {",
        "\timg->get = TIFFIsTiled(tif) ? gtTileSeparate : gtStripSeparate;",
        "\tif (!pickTileSeparateCase(img)) {",
        "\t\tsprintf(emsg, \"Sorry, can not handle image\");",
        "\t\treturn 0;",
        "\t}",
        "    }",
        "    return 1;",
        "}"
      ],
      "_frozen": true
    },
    {
      "file_path": "extlib/libtiff/tif_win3.c",
      "matched_lines": [
        208
      ],
      "context_lines": [
        203,
        204,
        205,
        206,
        207,
        209,
        210,
        211,
        212,
        213
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/libtiff/tif_win3.c-203-win3WarningHandler(const char* module, const char* fmt, va_list ap)",
        "extlib/libtiff/tif_win3.c-204-{",
        "extlib/libtiff/tif_win3.c-205-\tchar e[512] = { '\\0' };",
        "extlib/libtiff/tif_win3.c-206-\tif (module != NULL)",
        "extlib/libtiff/tif_win3.c-207-\t\tstrcat(strcpy(e, module), \":\");",
        "extlib/libtiff/tif_win3.c:208:\tvsprintf(e+strlen(e), fmt, ap);",
        "extlib/libtiff/tif_win3.c-209-\tstrcat(e, \".\");",
        "extlib/libtiff/tif_win3.c-210-\tMessageBox(GetActiveWindow(), e, \"LibTIFF Warning\",",
        "extlib/libtiff/tif_win3.c-211-\t    MB_OK|MB_ICONEXCLAMATION);",
        "extlib/libtiff/tif_win3.c-212-}",
        "extlib/libtiff/tif_win3.c-213-TIFFErrorHandler _TIFFwarningHandler = win3WarningHandler;"
      ],
      "raw_content": [
        "win3WarningHandler(const char* module, const char* fmt, va_list ap)",
        "{",
        "\tchar e[512] = { '\\0' };",
        "\tif (module != NULL)",
        "\t\tstrcat(strcpy(e, module), \":\");",
        "\tvsprintf(e+strlen(e), fmt, ap);",
        "\tstrcat(e, \".\");",
        "\tMessageBox(GetActiveWindow(), e, \"LibTIFF Warning\",",
        "\t    MB_OK|MB_ICONEXCLAMATION);",
        "}",
        "TIFFErrorHandler _TIFFwarningHandler = win3WarningHandler;"
      ],
      "_frozen": true
    },
    {
      "file_path": "extlib/libtiff/tif_win3.c",
      "matched_lines": [
        221
      ],
      "context_lines": [
        216,
        217,
        218,
        219,
        220,
        222,
        223,
        224,
        225
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/libtiff/tif_win3.c-216-win3ErrorHandler(const char* module, const char* fmt, va_list ap)",
        "extlib/libtiff/tif_win3.c-217-{",
        "extlib/libtiff/tif_win3.c-218-\tchar e[512] = { '\\0' };",
        "extlib/libtiff/tif_win3.c-219-\tif (module != NULL)",
        "extlib/libtiff/tif_win3.c-220-\t\tstrcat(strcpy(e, module), \":\");",
        "extlib/libtiff/tif_win3.c:221:\tvsprintf(e+strlen(e), fmt, ap);",
        "extlib/libtiff/tif_win3.c-222-\tstrcat(e, \".\");",
        "extlib/libtiff/tif_win3.c-223-\tMessageBox(GetActiveWindow(), e, \"LibTIFF Error\", MB_OK|MB_ICONSTOP);",
        "extlib/libtiff/tif_win3.c-224-}",
        "extlib/libtiff/tif_win3.c-225-TIFFErrorHandler _TIFFerrorHandler = win3ErrorHandler;"
      ],
      "raw_content": [
        "win3ErrorHandler(const char* module, const char* fmt, va_list ap)",
        "{",
        "\tchar e[512] = { '\\0' };",
        "\tif (module != NULL)",
        "\t\tstrcat(strcpy(e, module), \":\");",
        "\tvsprintf(e+strlen(e), fmt, ap);",
        "\tstrcat(e, \".\");",
        "\tMessageBox(GetActiveWindow(), e, \"LibTIFF Error\", MB_OK|MB_ICONSTOP);",
        "}",
        "TIFFErrorHandler _TIFFerrorHandler = win3ErrorHandler;"
      ],
      "_frozen": true
    },
    {
      "file_path": "extlib/libtiff/tif_win32.c",
      "matched_lines": [
        349,
        351
      ],
      "context_lines": [
        344,
        345,
        346,
        347,
        348,
        350,
        352,
        353,
        354,
        355,
        356
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/libtiff/tif_win32.c-344-\tLPCTSTR szDefaultModule = \"LIBTIFF\";",
        "extlib/libtiff/tif_win32.c-345-\tLPCTSTR szTmpModule = (module == NULL) ? szDefaultModule : module;",
        "extlib/libtiff/tif_win32.c-346-\tif ((szTitle = (LPTSTR)LocalAlloc(LMEM_FIXED, (strlen(szTmpModule) +",
        "extlib/libtiff/tif_win32.c-347-\t\tstrlen(szTitleText) + strlen(fmt) + 128)*sizeof(char))) == NULL)",
        "extlib/libtiff/tif_win32.c-348-\t\treturn;",
        "extlib/libtiff/tif_win32.c:349:\tsprintf(szTitle, szTitleText, szTmpModule);",
        "extlib/libtiff/tif_win32.c-350-\tszTmp = szTitle + (strlen(szTitle)+2)*sizeof(char);",
        "extlib/libtiff/tif_win32.c:351:\tvsprintf(szTmp, fmt, ap);",
        "extlib/libtiff/tif_win32.c-352-\tMessageBoxA(GetFocus(), szTmp, szTitle, MB_OK | MB_ICONINFORMATION);",
        "extlib/libtiff/tif_win32.c-353-\tLocalFree(szTitle);",
        "extlib/libtiff/tif_win32.c-354-\treturn;",
        "extlib/libtiff/tif_win32.c-355-#else",
        "extlib/libtiff/tif_win32.c-356-\tif (module != NULL)"
      ],
      "raw_content": [
        "\tLPCTSTR szDefaultModule = \"LIBTIFF\";",
        "\tLPCTSTR szTmpModule = (module == NULL) ? szDefaultModule : module;",
        "\tif ((szTitle = (LPTSTR)LocalAlloc(LMEM_FIXED, (strlen(szTmpModule) +",
        "\t\tstrlen(szTitleText) + strlen(fmt) + 128)*sizeof(char))) == NULL)",
        "\t\treturn;",
        "\tsprintf(szTitle, szTitleText, szTmpModule);",
        "\tszTmp = szTitle + (strlen(szTitle)+2)*sizeof(char);",
        "\tvsprintf(szTmp, fmt, ap);",
        "\tMessageBoxA(GetFocus(), szTmp, szTitle, MB_OK | MB_ICONINFORMATION);",
        "\tLocalFree(szTitle);",
        "\treturn;",
        "#else",
        "\tif (module != NULL)"
      ],
      "_frozen": true
    },
    {
      "file_path": "extlib/libtiff/tif_win32.c",
      "matched_lines": [
        377,
        379
      ],
      "context_lines": [
        372,
        373,
        374,
        375,
        376,
        378,
        380,
        381,
        382,
        383,
        384
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/libtiff/tif_win32.c-372-\tLPCTSTR szDefaultModule = \"LIBTIFF\";",
        "extlib/libtiff/tif_win32.c-373-\tLPCTSTR szTmpModule = (module == NULL) ? szDefaultModule : module;",
        "extlib/libtiff/tif_win32.c-374-\tif ((szTitle = (LPTSTR)LocalAlloc(LMEM_FIXED, (strlen(szTmpModule) +",
        "extlib/libtiff/tif_win32.c-375-\t\tstrlen(szTitleText) + strlen(fmt) + 128)*sizeof(char))) == NULL)",
        "extlib/libtiff/tif_win32.c-376-\t\treturn;",
        "extlib/libtiff/tif_win32.c:377:\tsprintf(szTitle, szTitleText, szTmpModule);",
        "extlib/libtiff/tif_win32.c-378-\tszTmp = szTitle + (strlen(szTitle)+2)*sizeof(char);",
        "extlib/libtiff/tif_win32.c:379:\tvsprintf(szTmp, fmt, ap);",
        "extlib/libtiff/tif_win32.c-380-\tMessageBoxA(GetFocus(), szTmp, szTitle, MB_OK | MB_ICONEXCLAMATION);",
        "extlib/libtiff/tif_win32.c-381-\tLocalFree(szTitle);",
        "extlib/libtiff/tif_win32.c-382-\treturn;",
        "extlib/libtiff/tif_win32.c-383-#else",
        "extlib/libtiff/tif_win32.c-384-\tif (module != NULL)"
      ],
      "raw_content": [
        "\tLPCTSTR szDefaultModule = \"LIBTIFF\";",
        "\tLPCTSTR szTmpModule = (module == NULL) ? szDefaultModule : module;",
        "\tif ((szTitle = (LPTSTR)LocalAlloc(LMEM_FIXED, (strlen(szTmpModule) +",
        "\t\tstrlen(szTitleText) + strlen(fmt) + 128)*sizeof(char))) == NULL)",
        "\t\treturn;",
        "\tsprintf(szTitle, szTitleText, szTmpModule);",
        "\tszTmp = szTitle + (strlen(szTitle)+2)*sizeof(char);",
        "\tvsprintf(szTmp, fmt, ap);",
        "\tMessageBoxA(GetFocus(), szTmp, szTitle, MB_OK | MB_ICONEXCLAMATION);",
        "\tLocalFree(szTitle);",
        "\treturn;",
        "#else",
        "\tif (module != NULL)"
      ],
      "_frozen": true
    },
    {
      "file_path": "extlib/zlib/gzio.c",
      "matched_lines": [
        226
      ],
      "context_lines": [
        221,
        222,
        223,
        224,
        225,
        227,
        228,
        229,
        230,
        231
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/zlib/gzio.c-221-    const char *mode;",
        "extlib/zlib/gzio.c-222-{",
        "extlib/zlib/gzio.c-223-    char name[46];      /* allow for up to 128-bit integers */",
        "extlib/zlib/gzio.c-224-",
        "extlib/zlib/gzio.c-225-    if (fd < 0) return (gzFile)Z_NULL;",
        "extlib/zlib/gzio.c:226:    sprintf(name, \"<fd:%d>\", fd); /* for debugging */",
        "extlib/zlib/gzio.c-227-",
        "extlib/zlib/gzio.c-228-    return gz_open (name, mode, fd);",
        "extlib/zlib/gzio.c-229-}",
        "extlib/zlib/gzio.c-230-",
        "extlib/zlib/gzio.c-231-/* ==========================================================================="
      ],
      "raw_content": [
        "    const char *mode;",
        "{",
        "    char name[46];      /* allow for up to 128-bit integers */",
        "",
        "    if (fd < 0) return (gzFile)Z_NULL;",
        "    sprintf(name, \"<fd:%d>\", fd); /* for debugging */",
        "",
        "    return gz_open (name, mode, fd);",
        "}",
        "",
        "/* ==========================================================================="
      ],
      "_frozen": true
    },
    {
      "file_path": "extlib/zlib/gzio.c",
      "matched_lines": [
        612,
        613,
        618
      ],
      "context_lines": [
        607,
        608,
        609,
        610,
        611,
        614,
        615,
        616,
        617,
        619,
        620,
        621,
        622,
        623
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/zlib/gzio.c-607-    int len;",
        "extlib/zlib/gzio.c-608-",
        "extlib/zlib/gzio.c-609-    buf[sizeof(buf) - 1] = 0;",
        "extlib/zlib/gzio.c-610-    va_start(va, format);",
        "extlib/zlib/gzio.c-611-#ifdef NO_vsnprintf",
        "extlib/zlib/gzio.c:612:#  ifdef HAS_vsprintf_void",
        "extlib/zlib/gzio.c:613:    (void)vsprintf(buf, format, va);",
        "extlib/zlib/gzio.c-614-    va_end(va);",
        "extlib/zlib/gzio.c-615-    for (len = 0; len < sizeof(buf); len++)",
        "extlib/zlib/gzio.c-616-        if (buf[len] == 0) break;",
        "extlib/zlib/gzio.c-617-#  else",
        "extlib/zlib/gzio.c:618:    len = vsprintf(buf, format, va);",
        "extlib/zlib/gzio.c-619-    va_end(va);",
        "extlib/zlib/gzio.c-620-#  endif",
        "extlib/zlib/gzio.c-621-#else",
        "extlib/zlib/gzio.c-622-#  ifdef HAS_vsnprintf_void",
        "extlib/zlib/gzio.c-623-    (void)vsnprintf(buf, sizeof(buf), format, va);"
      ],
      "raw_content": [
        "    int len;",
        "",
        "    buf[sizeof(buf) - 1] = 0;",
        "    va_start(va, format);",
        "#ifdef NO_vsnprintf",
        "#  ifdef HAS_vsprintf_void",
        "    (void)vsprintf(buf, format, va);",
        "    va_end(va);",
        "    for (len = 0; len < sizeof(buf); len++)",
        "        if (buf[len] == 0) break;",
        "#  else",
        "    len = vsprintf(buf, format, va);",
        "    va_end(va);",
        "#  endif",
        "#else",
        "#  ifdef HAS_vsnprintf_void",
        "    (void)vsnprintf(buf, sizeof(buf), format, va);"
      ],
      "_frozen": true
    },
    {
      "file_path": "extlib/zlib/gzio.c",
      "matched_lines": [
        649,
        650,
        655
      ],
      "context_lines": [
        644,
        645,
        646,
        647,
        648,
        651,
        652,
        653,
        654,
        656,
        657,
        658,
        659,
        660
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/zlib/gzio.c-644-    char buf[Z_PRINTF_BUFSIZE];",
        "extlib/zlib/gzio.c-645-    int len;",
        "extlib/zlib/gzio.c-646-",
        "extlib/zlib/gzio.c-647-    buf[sizeof(buf) - 1] = 0;",
        "extlib/zlib/gzio.c-648-#ifdef NO_snprintf",
        "extlib/zlib/gzio.c:649:#  ifdef HAS_sprintf_void",
        "extlib/zlib/gzio.c:650:    sprintf(buf, format, a1, a2, a3, a4, a5, a6, a7, a8,",
        "extlib/zlib/gzio.c-651-            a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);",
        "extlib/zlib/gzio.c-652-    for (len = 0; len < sizeof(buf); len++)",
        "extlib/zlib/gzio.c-653-        if (buf[len] == 0) break;",
        "extlib/zlib/gzio.c-654-#  else",
        "extlib/zlib/gzio.c:655:    len = sprintf(buf, format, a1, a2, a3, a4, a5, a6, a7, a8,",
        "extlib/zlib/gzio.c-656-                a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);",
        "extlib/zlib/gzio.c-657-#  endif",
        "extlib/zlib/gzio.c-658-#else",
        "extlib/zlib/gzio.c-659-#  ifdef HAS_snprintf_void",
        "extlib/zlib/gzio.c-660-    snprintf(buf, sizeof(buf), format, a1, a2, a3, a4, a5, a6, a7, a8,"
      ],
      "raw_content": [
        "    char buf[Z_PRINTF_BUFSIZE];",
        "    int len;",
        "",
        "    buf[sizeof(buf) - 1] = 0;",
        "#ifdef NO_snprintf",
        "#  ifdef HAS_sprintf_void",
        "    sprintf(buf, format, a1, a2, a3, a4, a5, a6, a7, a8,",
        "            a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);",
        "    for (len = 0; len < sizeof(buf); len++)",
        "        if (buf[len] == 0) break;",
        "#  else",
        "    len = sprintf(buf, format, a1, a2, a3, a4, a5, a6, a7, a8,",
        "                a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);",
        "#  endif",
        "#else",
        "#  ifdef HAS_snprintf_void",
        "    snprintf(buf, sizeof(buf), format, a1, a2, a3, a4, a5, a6, a7, a8,"
      ],
      "_frozen": true
    },
    {
      "file_path": "extlib/zlib/zlib.h",
      "matched_lines": [
        989
      ],
      "context_lines": [
        984,
        985,
        986,
        987,
        988,
        990,
        991,
        992,
        993,
        994
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/zlib/zlib.h-984-    Operation variations (changes in library functionality):",
        "extlib/zlib/zlib.h-985-     20: PKZIP_BUG_WORKAROUND -- slightly more permissive inflate",
        "extlib/zlib/zlib.h-986-     21: FASTEST -- deflate algorithm with only one, lowest compression level",
        "extlib/zlib/zlib.h-987-     22,23: 0 (reserved)",
        "extlib/zlib/zlib.h-988-",
        "extlib/zlib/zlib.h:989:    The sprintf variant used by gzprintf (zero is best):",
        "extlib/zlib/zlib.h-990-     24: 0 = vs*, 1 = s* -- 1 means limited to 20 arguments after the format",
        "extlib/zlib/zlib.h-991-     25: 0 = *nprintf, 1 = *printf -- 1 means gzprintf() not secure!",
        "extlib/zlib/zlib.h-992-     26: 0 = returns value, 1 = void -- 1 means inferred string length returned",
        "extlib/zlib/zlib.h-993-",
        "extlib/zlib/zlib.h-994-    Remainder:"
      ],
      "raw_content": [
        "    Operation variations (changes in library functionality):",
        "     20: PKZIP_BUG_WORKAROUND -- slightly more permissive inflate",
        "     21: FASTEST -- deflate algorithm with only one, lowest compression level",
        "     22,23: 0 (reserved)",
        "",
        "    The sprintf variant used by gzprintf (zero is best):",
        "     24: 0 = vs*, 1 = s* -- 1 means limited to 20 arguments after the format",
        "     25: 0 = *nprintf, 1 = *printf -- 1 means gzprintf() not secure!",
        "     26: 0 = returns value, 1 = void -- 1 means inferred string length returned",
        "",
        "    Remainder:"
      ],
      "_frozen": true
    },
    {
      "file_path": "extlib/zlib/zlib.h",
      "matched_lines": [
        1131
      ],
      "context_lines": [
        1126,
        1127,
        1128,
        1129,
        1130,
        1132,
        1133,
        1134,
        1135,
        1136
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/zlib/zlib.h-1126-   uncompressed bytes actually written (0 in case of error).  The number of",
        "extlib/zlib/zlib.h-1127-   uncompressed bytes written is limited to 4095. The caller should assure that",
        "extlib/zlib/zlib.h-1128-   this limit is not exceeded. If it is exceeded, then gzprintf() will return",
        "extlib/zlib/zlib.h-1129-   return an error (0) with nothing written. In this case, there may also be a",
        "extlib/zlib/zlib.h-1130-   buffer overflow with unpredictable consequences, which is possible only if",
        "extlib/zlib/zlib.h:1131:   zlib was compiled with the insecure functions sprintf() or vsprintf()",
        "extlib/zlib/zlib.h-1132-   because the secure snprintf() or vsnprintf() functions were not available.",
        "extlib/zlib/zlib.h-1133-*/",
        "extlib/zlib/zlib.h-1134-",
        "extlib/zlib/zlib.h-1135-ZEXTERN int ZEXPORT gzputs OF((gzFile file, const char *s));",
        "extlib/zlib/zlib.h-1136-/*"
      ],
      "raw_content": [
        "   uncompressed bytes actually written (0 in case of error).  The number of",
        "   uncompressed bytes written is limited to 4095. The caller should assure that",
        "   this limit is not exceeded. If it is exceeded, then gzprintf() will return",
        "   return an error (0) with nothing written. In this case, there may also be a",
        "   buffer overflow with unpredictable consequences, which is possible only if",
        "   zlib was compiled with the insecure functions sprintf() or vsprintf()",
        "   because the secure snprintf() or vsnprintf() functions were not available.",
        "*/",
        "",
        "ZEXTERN int ZEXPORT gzputs OF((gzFile file, const char *s));",
        "/*"
      ],
      "_frozen": true
    },
    {
      "file_path": "extlib/zlib/zutil.c",
      "matched_lines": [
        91
      ],
      "context_lines": [
        86,
        87,
        88,
        89,
        90,
        92,
        93,
        94,
        95,
        96
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/zlib/zutil.c-86-    flags += 1L << 21;",
        "extlib/zlib/zutil.c-87-#endif",
        "extlib/zlib/zutil.c-88-#ifdef STDC",
        "extlib/zlib/zutil.c-89-#  ifdef NO_vsnprintf",
        "extlib/zlib/zutil.c-90-        flags += 1L << 25;",
        "extlib/zlib/zutil.c:91:#    ifdef HAS_vsprintf_void",
        "extlib/zlib/zutil.c-92-        flags += 1L << 26;",
        "extlib/zlib/zutil.c-93-#    endif",
        "extlib/zlib/zutil.c-94-#  else",
        "extlib/zlib/zutil.c-95-#    ifdef HAS_vsnprintf_void",
        "extlib/zlib/zutil.c-96-        flags += 1L << 26;"
      ],
      "raw_content": [
        "    flags += 1L << 21;",
        "#endif",
        "#ifdef STDC",
        "#  ifdef NO_vsnprintf",
        "        flags += 1L << 25;",
        "#    ifdef HAS_vsprintf_void",
        "        flags += 1L << 26;",
        "#    endif",
        "#  else",
        "#    ifdef HAS_vsnprintf_void",
        "        flags += 1L << 26;"
      ],
      "_frozen": true
    },
    {
      "file_path": "extlib/zlib/zutil.c",
      "matched_lines": [
        103
      ],
      "context_lines": [
        98,
        99,
        100,
        101,
        102,
        104,
        105,
        106,
        107,
        108
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/zlib/zutil.c-98-#  endif",
        "extlib/zlib/zutil.c-99-#else",
        "extlib/zlib/zutil.c-100-        flags += 1L << 24;",
        "extlib/zlib/zutil.c-101-#  ifdef NO_snprintf",
        "extlib/zlib/zutil.c-102-        flags += 1L << 25;",
        "extlib/zlib/zutil.c:103:#    ifdef HAS_sprintf_void",
        "extlib/zlib/zutil.c-104-        flags += 1L << 26;",
        "extlib/zlib/zutil.c-105-#    endif",
        "extlib/zlib/zutil.c-106-#  else",
        "extlib/zlib/zutil.c-107-#    ifdef HAS_snprintf_void",
        "extlib/zlib/zutil.c-108-        flags += 1L << 26;"
      ],
      "raw_content": [
        "#  endif",
        "#else",
        "        flags += 1L << 24;",
        "#  ifdef NO_snprintf",
        "        flags += 1L << 25;",
        "#    ifdef HAS_sprintf_void",
        "        flags += 1L << 26;",
        "#    endif",
        "#  else",
        "#    ifdef HAS_snprintf_void",
        "        flags += 1L << 26;"
      ],
      "_frozen": true
    },
    {
      "file_path": "src/3DSMax/RISERenderImage.cpp",
      "matched_lines": [
        133,
        143,
        153,
        163,
        173,
        183
      ],
      "context_lines": [
        128,
        129,
        130,
        131,
        132,
        134,
        135,
        136,
        137,
        138,
        139,
        140,
        141,
        142,
        144,
        145,
        146,
        147,
        148,
        149,
        150,
        151,
        152,
        154,
        155,
        156,
        157,
        158,
        159,
        160,
        161,
        162,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        174,
        175,
        176,
        177,
        178,
        179,
        180,
        181,
        182,
        184,
        185,
        186,
        187,
        188
      ],
      "raw_surrounding_git_grep_lines": [
        "src/3DSMax/RISERenderImage.cpp-128-\t\t// to change the existing camera setting's parameters",
        "src/3DSMax/RISERenderImage.cpp-129-\t\tchar val[256] = {0};",
        "src/3DSMax/RISERenderImage.cpp-130-",
        "src/3DSMax/RISERenderImage.cpp-131-\t\t// Location",
        "src/3DSMax/RISERenderImage.cpp-132-\t\t{",
        "src/3DSMax/RISERenderImage.cpp:133:\t\t\tsprintf( val, \"%lf %lf %lf\", loc[0], loc[1], loc[2] );",
        "src/3DSMax/RISERenderImage.cpp-134-\t\t\tRISE::IKeyframeParameter* p = pCamera->KeyframeFromParameters( \"location\", val );",
        "src/3DSMax/RISERenderImage.cpp-135-\t\t\tif( p ) {",
        "src/3DSMax/RISERenderImage.cpp-136-\t\t\t\tpCamera->SetIntermediateValue( *p );",
        "src/3DSMax/RISERenderImage.cpp-137-\t\t\t\tp->release();",
        "src/3DSMax/RISERenderImage.cpp-138-\t\t\t}",
        "src/3DSMax/RISERenderImage.cpp-139-\t\t}",
        "src/3DSMax/RISERenderImage.cpp-140-",
        "src/3DSMax/RISERenderImage.cpp-141-\t\t// Look at",
        "src/3DSMax/RISERenderImage.cpp-142-\t\t{",
        "src/3DSMax/RISERenderImage.cpp:143:\t\t\tsprintf( val, \"%lf %lf %lf\", lookat[0], lookat[1], lookat[2] );",
        "src/3DSMax/RISERenderImage.cpp-144-\t\t\tRISE::IKeyframeParameter* p = pCamera->KeyframeFromParameters( \"lookat\", val );",
        "src/3DSMax/RISERenderImage.cpp-145-\t\t\tif( p ) {",
        "src/3DSMax/RISERenderImage.cpp-146-\t\t\t\tpCamera->SetIntermediateValue( *p );",
        "src/3DSMax/RISERenderImage.cpp-147-\t\t\t\tp->release();",
        "src/3DSMax/RISERenderImage.cpp-148-\t\t\t}",
        "src/3DSMax/RISERenderImage.cpp-149-\t\t}",
        "src/3DSMax/RISERenderImage.cpp-150-",
        "src/3DSMax/RISERenderImage.cpp-151-\t\t// Up vector",
        "src/3DSMax/RISERenderImage.cpp-152-\t\t{",
        "src/3DSMax/RISERenderImage.cpp:153:\t\t\tsprintf( val, \"%lf %lf %lf\", up[0], up[1], up[2] );",
        "src/3DSMax/RISERenderImage.cpp-154-\t\t\tRISE::IKeyframeParameter* p = pCamera->KeyframeFromParameters( \"up\", val );",
        "src/3DSMax/RISERenderImage.cpp-155-\t\t\tif( p ) {",
        "src/3DSMax/RISERenderImage.cpp-156-\t\t\t\tpCamera->SetIntermediateValue( *p );",
        "src/3DSMax/RISERenderImage.cpp-157-\t\t\t\tp->release();",
        "src/3DSMax/RISERenderImage.cpp-158-\t\t\t}",
        "src/3DSMax/RISERenderImage.cpp-159-\t\t}",
        "src/3DSMax/RISERenderImage.cpp-160-",
        "src/3DSMax/RISERenderImage.cpp-161-\t\t// FOV",
        "src/3DSMax/RISERenderImage.cpp-162-\t\t{",
        "src/3DSMax/RISERenderImage.cpp:163:\t\t\tsprintf( val, \"%lf\", fov* RAD_TO_DEG );",
        "src/3DSMax/RISERenderImage.cpp-164-\t\t\tRISE::IKeyframeParameter* p = pCamera->KeyframeFromParameters( \"fov\", val );",
        "src/3DSMax/RISERenderImage.cpp-165-\t\t\tif( p ) {",
        "src/3DSMax/RISERenderImage.cpp-166-\t\t\t\tpCamera->SetIntermediateValue( *p );",
        "src/3DSMax/RISERenderImage.cpp-167-\t\t\t\tp->release();",
        "src/3DSMax/RISERenderImage.cpp-168-\t\t\t}",
        "src/3DSMax/RISERenderImage.cpp-169-\t\t}",
        "src/3DSMax/RISERenderImage.cpp-170-",
        "src/3DSMax/RISERenderImage.cpp-171-\t\t// Width",
        "src/3DSMax/RISERenderImage.cpp-172-\t\t{",
        "src/3DSMax/RISERenderImage.cpp:173:\t\t\tsprintf( val, \"%u\", width );",
        "src/3DSMax/RISERenderImage.cpp-174-\t\t\tRISE::IKeyframeParameter* p = pCamera->KeyframeFromParameters( \"width\", val );",
        "src/3DSMax/RISERenderImage.cpp-175-\t\t\tif( p ) {",
        "src/3DSMax/RISERenderImage.cpp-176-\t\t\t\tpCamera->SetIntermediateValue( *p );",
        "src/3DSMax/RISERenderImage.cpp-177-\t\t\t\tp->release();",
        "src/3DSMax/RISERenderImage.cpp-178-\t\t\t}",
        "src/3DSMax/RISERenderImage.cpp-179-\t\t}",
        "src/3DSMax/RISERenderImage.cpp-180-",
        "src/3DSMax/RISERenderImage.cpp-181-\t\t// Height",
        "src/3DSMax/RISERenderImage.cpp-182-\t\t{",
        "src/3DSMax/RISERenderImage.cpp:183:\t\t\tsprintf( val, \"%u\", height );",
        "src/3DSMax/RISERenderImage.cpp-184-\t\t\tRISE::IKeyframeParameter* p = pCamera->KeyframeFromParameters( \"height\", val );",
        "src/3DSMax/RISERenderImage.cpp-185-\t\t\tif( p ) {",
        "src/3DSMax/RISERenderImage.cpp-186-\t\t\t\tpCamera->SetIntermediateValue( *p );",
        "src/3DSMax/RISERenderImage.cpp-187-\t\t\t\tp->release();",
        "src/3DSMax/RISERenderImage.cpp-188-\t\t\t}"
      ],
      "raw_content": [
        "\t\t// to change the existing camera setting's parameters",
        "\t\tchar val[256] = {0};",
        "",
        "\t\t// Location",
        "\t\t{",
        "\t\t\tsprintf( val, \"%lf %lf %lf\", loc[0], loc[1], loc[2] );",
        "\t\t\tRISE::IKeyframeParameter* p = pCamera->KeyframeFromParameters( \"location\", val );",
        "\t\t\tif( p ) {",
        "\t\t\t\tpCamera->SetIntermediateValue( *p );",
        "\t\t\t\tp->release();",
        "\t\t\t}",
        "\t\t}",
        "",
        "\t\t// Look at",
        "\t\t{",
        "\t\t\tsprintf( val, \"%lf %lf %lf\", lookat[0], lookat[1], lookat[2] );",
        "\t\t\tRISE::IKeyframeParameter* p = pCamera->KeyframeFromParameters( \"lookat\", val );",
        "\t\t\tif( p ) {",
        "\t\t\t\tpCamera->SetIntermediateValue( *p );",
        "\t\t\t\tp->release();",
        "\t\t\t}",
        "\t\t}",
        "",
        "\t\t// Up vector",
        "\t\t{",
        "\t\t\tsprintf( val, \"%lf %lf %lf\", up[0], up[1], up[2] );",
        "\t\t\tRISE::IKeyframeParameter* p = pCamera->KeyframeFromParameters( \"up\", val );",
        "\t\t\tif( p ) {",
        "\t\t\t\tpCamera->SetIntermediateValue( *p );",
        "\t\t\t\tp->release();",
        "\t\t\t}",
        "\t\t}",
        "",
        "\t\t// FOV",
        "\t\t{",
        "\t\t\tsprintf( val, \"%lf\", fov* RAD_TO_DEG );",
        "\t\t\tRISE::IKeyframeParameter* p = pCamera->KeyframeFromParameters( \"fov\", val );",
        "\t\t\tif( p ) {",
        "\t\t\t\tpCamera->SetIntermediateValue( *p );",
        "\t\t\t\tp->release();",
        "\t\t\t}",
        "\t\t}",
        "",
        "\t\t// Width",
        "\t\t{",
        "\t\t\tsprintf( val, \"%u\", width );",
        "\t\t\tRISE::IKeyframeParameter* p = pCamera->KeyframeFromParameters( \"width\", val );",
        "\t\t\tif( p ) {",
        "\t\t\t\tpCamera->SetIntermediateValue( *p );",
        "\t\t\t\tp->release();",
        "\t\t\t}",
        "\t\t}",
        "",
        "\t\t// Height",
        "\t\t{",
        "\t\t\tsprintf( val, \"%u\", height );",
        "\t\t\tRISE::IKeyframeParameter* p = pCamera->KeyframeFromParameters( \"height\", val );",
        "\t\t\tif( p ) {",
        "\t\t\t\tpCamera->SetIntermediateValue( *p );",
        "\t\t\t\tp->release();",
        "\t\t\t}"
      ],
      "_frozen": true
    },
    {
      "file_path": "src/3DSMax/RISERenderImage.cpp",
      "matched_lines": [
        291
      ],
      "context_lines": [
        286,
        287,
        288,
        289,
        290,
        292,
        293,
        294,
        295,
        296
      ],
      "raw_surrounding_git_grep_lines": [
        "src/3DSMax/RISERenderImage.cpp-286-\t\tif( it != geoms.end() ) {",
        "src/3DSMax/RISERenderImage.cpp-287-\t\t\t// Instance of object already exists!",
        "src/3DSMax/RISERenderImage.cpp-288-\t\t\tstrcpy( geomname, it->second.c_str() );",
        "src/3DSMax/RISERenderImage.cpp-289-\t\t} else {",
        "src/3DSMax/RISERenderImage.cpp-290-\t\t\t// Create the geometry instance ",
        "src/3DSMax/RISERenderImage.cpp:291:\t\t\tsprintf( geomname, \"Geom::%s\", pInst->GetName() );",
        "src/3DSMax/RISERenderImage.cpp-292-",
        "src/3DSMax/RISERenderImage.cpp-293-\t\t\tMAXGeometry* pGeometry = new MAXGeometry( pInst );",
        "src/3DSMax/RISERenderImage.cpp-294-\t\t\tRISE::GlobalLog()->PrintNew( pGeometry, __FILE__, __LINE__, \"MAX geometry\" );",
        "src/3DSMax/RISERenderImage.cpp-295-\t\t\tpJob->GetGeometries()->AddItem( pGeometry, geomname );",
        "src/3DSMax/RISERenderImage.cpp-296-\t\t\tpGeometry->release();"
      ],
      "raw_content": [
        "\t\tif( it != geoms.end() ) {",
        "\t\t\t// Instance of object already exists!",
        "\t\t\tstrcpy( geomname, it->second.c_str() );",
        "\t\t} else {",
        "\t\t\t// Create the geometry instance ",
        "\t\t\tsprintf( geomname, \"Geom::%s\", pInst->GetName() );",
        "",
        "\t\t\tMAXGeometry* pGeometry = new MAXGeometry( pInst );",
        "\t\t\tRISE::GlobalLog()->PrintNew( pGeometry, __FILE__, __LINE__, \"MAX geometry\" );",
        "\t\t\tpJob->GetGeometries()->AddItem( pGeometry, geomname );",
        "\t\t\tpGeometry->release();"
      ],
      "_frozen": true
    },
    {
      "file_path": "src/3DSMax/RISERenderImage.cpp",
      "matched_lines": [
        346
      ],
      "context_lines": [
        341,
        342,
        343,
        344,
        345,
        347,
        348,
        349,
        350,
        351
      ],
      "raw_surrounding_git_grep_lines": [
        "src/3DSMax/RISERenderImage.cpp-341-\t\t\t\t\t\t\tstrcat( rs, \"::specular\" );",
        "src/3DSMax/RISERenderImage.cpp-342-\t\t\t\t\t\t\tdouble s[3] = {specular.r*shininessStrength, specular.g*shininessStrength, specular.b*shininessStrength};",
        "src/3DSMax/RISERenderImage.cpp-343-\t\t\t\t\t\t\tpJob->AddUniformColorPainter( rs, s, \"RGB\" );",
        "src/3DSMax/RISERenderImage.cpp-344-\t\t\t\t\t\t\t",
        "src/3DSMax/RISERenderImage.cpp-345-\t\t\t\t\t\t\tchar phong[256] = {0};",
        "src/3DSMax/RISERenderImage.cpp:346:\t\t\t\t\t\t\tsprintf( phong, \"%f\", shininess*100.0 );",
        "src/3DSMax/RISERenderImage.cpp-347-",
        "src/3DSMax/RISERenderImage.cpp-348-\t\t\t\t\t\t\tpJob->AddIsotropicPhongMaterial( material_name, rd, rs, phong );",
        "src/3DSMax/RISERenderImage.cpp-349-\t\t\t\t\t\t} else {",
        "src/3DSMax/RISERenderImage.cpp-350-\t\t\t\t\t\t\tpJob->AddLambertianMaterial( material_name, rd );",
        "src/3DSMax/RISERenderImage.cpp-351-\t\t\t\t\t\t}"
      ],
      "raw_content": [
        "\t\t\t\t\t\t\tstrcat( rs, \"::specular\" );",
        "\t\t\t\t\t\t\tdouble s[3] = {specular.r*shininessStrength, specular.g*shininessStrength, specular.b*shininessStrength};",
        "\t\t\t\t\t\t\tpJob->AddUniformColorPainter( rs, s, \"RGB\" );",
        "\t\t\t\t\t\t\t",
        "\t\t\t\t\t\t\tchar phong[256] = {0};",
        "\t\t\t\t\t\t\tsprintf( phong, \"%f\", shininess*100.0 );",
        "",
        "\t\t\t\t\t\t\tpJob->AddIsotropicPhongMaterial( material_name, rd, rs, phong );",
        "\t\t\t\t\t\t} else {",
        "\t\t\t\t\t\t\tpJob->AddLambertianMaterial( material_name, rd );",
        "\t\t\t\t\t\t}"
      ],
      "_frozen": true
    },
    {
      "file_path": "src/3DSMax/RISERenderImage.cpp",
      "matched_lines": [
        451
      ],
      "context_lines": [
        446,
        447,
        448,
        449,
        450,
        452,
        453,
        454,
        455,
        456
      ],
      "raw_surrounding_git_grep_lines": [
        "src/3DSMax/RISERenderImage.cpp-446-\t\t\tconst double intensity = light->pDesc->ls.intens * PI;",
        "src/3DSMax/RISERenderImage.cpp-447-",
        "src/3DSMax/RISERenderImage.cpp-448-\t\t\tdouble srgb[3] = {col.r,col.g,col.b};",
        "src/3DSMax/RISERenderImage.cpp-449-",
        "src/3DSMax/RISERenderImage.cpp-450-\t\t\tchar lightname[256] = {0};",
        "src/3DSMax/RISERenderImage.cpp:451:\t\t\tsprintf( lightname, \"light%d\", i );",
        "src/3DSMax/RISERenderImage.cpp-452-",
        "src/3DSMax/RISERenderImage.cpp-453-\t\t\tif( light->pDesc->ls.type == OMNI_LGT )",
        "src/3DSMax/RISERenderImage.cpp-454-\t\t\t{",
        "src/3DSMax/RISERenderImage.cpp-455-\t\t\t\t// OMNI Light --------------",
        "src/3DSMax/RISERenderImage.cpp-456-\t\t\t\tdouble pos[3] = {p.x,p.y,p.z};"
      ],
      "raw_content": [
        "\t\t\tconst double intensity = light->pDesc->ls.intens * PI;",
        "",
        "\t\t\tdouble srgb[3] = {col.r,col.g,col.b};",
        "",
        "\t\t\tchar lightname[256] = {0};",
        "\t\t\tsprintf( lightname, \"light%d\", i );",
        "",
        "\t\t\tif( light->pDesc->ls.type == OMNI_LGT )",
        "\t\t\t{",
        "\t\t\t\t// OMNI Light --------------",
        "\t\t\t\tdouble pos[3] = {p.x,p.y,p.z};"
      ],
      "_frozen": true
    },
    {
      "file_path": "src/DRISE/AnimationTask.cpp",
      "matched_lines": [
        137
      ],
      "context_lines": [
        132,
        133,
        134,
        135,
        136,
        138,
        139,
        140,
        141,
        142
      ],
      "raw_surrounding_git_grep_lines": [
        "src/DRISE/AnimationTask.cpp-132-\t\t\t{",
        "src/DRISE/AnimationTask.cpp-133-\t\t\t\tchar fname[1024] = {0};",
        "src/DRISE/AnimationTask.cpp-134-",
        "src/DRISE/AnimationTask.cpp-135-\t\t\t\tIRasterizerOutput* fro = 0;",
        "src/DRISE/AnimationTask.cpp-136-",
        "src/DRISE/AnimationTask.cpp:137:\t\t\t\tsprintf( fname, \"%s_%.5d\", szOutputFileName, id );",
        "src/DRISE/AnimationTask.cpp-138-\t\t\t\tRISE_API_CreateFileRasterizerOutput( &fro, fname, false, 2, 16, eColorSpace_ProPhotoRGB );",
        "src/DRISE/AnimationTask.cpp-139-",
        "src/DRISE/AnimationTask.cpp-140-\t\t\t\tfro->OutputImage( *pOutputImage, 0, 0 );",
        "src/DRISE/AnimationTask.cpp-141-\t\t\t\tfro->release();",
        "src/DRISE/AnimationTask.cpp-142-\t\t\t}"
      ],
      "raw_content": [
        "\t\t\t{",
        "\t\t\t\tchar fname[1024] = {0};",
        "",
        "\t\t\t\tIRasterizerOutput* fro = 0;",
        "",
        "\t\t\t\tsprintf( fname, \"%s_%.5d\", szOutputFileName, id );",
        "\t\t\t\tRISE_API_CreateFileRasterizerOutput( &fro, fname, false, 2, 16, eColorSpace_ProPhotoRGB );",
        "",
        "\t\t\t\tfro->OutputImage( *pOutputImage, 0, 0 );",
        "\t\t\t\tfro->release();",
        "\t\t\t}"
      ],
      "_frozen": true
    },
    {
      "file_path": "src/DRISE/AnimationTask.cpp",
      "matched_lines": [
        162,
        164,
        166,
        168,
        170
      ],
      "context_lines": [
        157,
        158,
        159,
        160,
        161,
        163,
        165,
        167,
        169,
        171,
        172,
        173,
        174,
        175
      ],
      "raw_surrounding_git_grep_lines": [
        "src/DRISE/AnimationTask.cpp-157-\t\t\t\tunsigned int\t\tms = timeforTask % 1000;",
        "src/DRISE/AnimationTask.cpp-158-",
        "src/DRISE/AnimationTask.cpp-159-\t\t\t\tchar buf[1024] = {0};",
        "src/DRISE/AnimationTask.cpp-160-\t\t\t\tstrcat( buf, \"Total Rasterization Time: \" );",
        "src/DRISE/AnimationTask.cpp-161-\t\t\t\tchar daybuf[32] = {0};",
        "src/DRISE/AnimationTask.cpp:162:\t\t\t\tsprintf( daybuf, \"%d days \", days );",
        "src/DRISE/AnimationTask.cpp-163-\t\t\t\tchar hourbuf[32] = {0};",
        "src/DRISE/AnimationTask.cpp:164:\t\t\t\tsprintf( hourbuf, \"%d hours \", hours );",
        "src/DRISE/AnimationTask.cpp-165-\t\t\t\tchar minbuf[32] = {0};",
        "src/DRISE/AnimationTask.cpp:166:\t\t\t\tsprintf( minbuf, \"%d minutes \", mins );",
        "src/DRISE/AnimationTask.cpp-167-\t\t\t\tchar secbuf[32] = {0};",
        "src/DRISE/AnimationTask.cpp:168:\t\t\t\tsprintf( secbuf, \"%d seconds \", secs );",
        "src/DRISE/AnimationTask.cpp-169-\t\t\t\tchar msbuf[32] = {0};",
        "src/DRISE/AnimationTask.cpp:170:\t\t\t\tsprintf( msbuf, \"%d ms\", ms );",
        "src/DRISE/AnimationTask.cpp-171-",
        "src/DRISE/AnimationTask.cpp-172-\t\t\t\tif( days ) {",
        "src/DRISE/AnimationTask.cpp-173-\t\t\t\t\tstrcat( buf, daybuf );",
        "src/DRISE/AnimationTask.cpp-174-\t\t\t\t}",
        "src/DRISE/AnimationTask.cpp-175-"
      ],
      "raw_content": [
        "\t\t\t\tunsigned int\t\tms = timeforTask % 1000;",
        "",
        "\t\t\t\tchar buf[1024] = {0};",
        "\t\t\t\tstrcat( buf, \"Total Rasterization Time: \" );",
        "\t\t\t\tchar daybuf[32] = {0};",
        "\t\t\t\tsprintf( daybuf, \"%d days \", days );",
        "\t\t\t\tchar hourbuf[32] = {0};",
        "\t\t\t\tsprintf( hourbuf, \"%d hours \", hours );",
        "\t\t\t\tchar minbuf[32] = {0};",
        "\t\t\t\tsprintf( minbuf, \"%d minutes \", mins );",
        "\t\t\t\tchar secbuf[32] = {0};",
        "\t\t\t\tsprintf( secbuf, \"%d seconds \", secs );",
        "\t\t\t\tchar msbuf[32] = {0};",
        "\t\t\t\tsprintf( msbuf, \"%d ms\", ms );",
        "",
        "\t\t\t\tif( days ) {",
        "\t\t\t\t\tstrcat( buf, daybuf );",
        "\t\t\t\t}",
        ""
      ],
      "_frozen": true
    },
    {
      "file_path": "src/DRISE/Task.cpp",
      "matched_lines": [
        206,
        212
      ],
      "context_lines": [
        201,
        202,
        203,
        204,
        205,
        207,
        208,
        209,
        210,
        211,
        213,
        214,
        215,
        216,
        217
      ],
      "raw_surrounding_git_grep_lines": [
        "src/DRISE/Task.cpp-201-\t\t\t\t{",
        "src/DRISE/Task.cpp-202-\t\t\t\t\tchar fname[1024] = {0};",
        "src/DRISE/Task.cpp-203-",
        "src/DRISE/Task.cpp-204-\t\t\t\t\tIRasterizerOutput* fro = 0;",
        "src/DRISE/Task.cpp-205-",
        "src/DRISE/Task.cpp:206:\t\t\t\t\tsprintf( fname, \"%s-sRGB\", szOutputFileName );",
        "src/DRISE/Task.cpp-207-\t\t\t\t\tRISE_API_CreateFileRasterizerOutput( &fro, fname, false, 2, 8, eColorSpace_sRGB );",
        "src/DRISE/Task.cpp-208-",
        "src/DRISE/Task.cpp-209-\t\t\t\t\tfro->OutputImage( *pOutputImage, 0, 0 );",
        "src/DRISE/Task.cpp-210-\t\t\t\t\tfro->release();",
        "src/DRISE/Task.cpp-211-",
        "src/DRISE/Task.cpp:212:\t\t\t\t\tsprintf( fname, \"%s-ProPhoto\", szOutputFileName );",
        "src/DRISE/Task.cpp-213-\t\t\t\t\tRISE_API_CreateFileRasterizerOutput( &fro, fname, false, 2, 16, eColorSpace_ProPhotoRGB );",
        "src/DRISE/Task.cpp-214-",
        "src/DRISE/Task.cpp-215-\t\t\t\t\tfro->OutputImage( *pOutputImage, 0, 0 );",
        "src/DRISE/Task.cpp-216-\t\t\t\t\tfro->release();\t\t\t\t",
        "src/DRISE/Task.cpp-217-\t\t\t\t}"
      ],
      "raw_content": [
        "\t\t\t\t{",
        "\t\t\t\t\tchar fname[1024] = {0};",
        "",
        "\t\t\t\t\tIRasterizerOutput* fro = 0;",
        "",
        "\t\t\t\t\tsprintf( fname, \"%s-sRGB\", szOutputFileName );",
        "\t\t\t\t\tRISE_API_CreateFileRasterizerOutput( &fro, fname, false, 2, 8, eColorSpace_sRGB );",
        "",
        "\t\t\t\t\tfro->OutputImage( *pOutputImage, 0, 0 );",
        "\t\t\t\t\tfro->release();",
        "",
        "\t\t\t\t\tsprintf( fname, \"%s-ProPhoto\", szOutputFileName );",
        "\t\t\t\t\tRISE_API_CreateFileRasterizerOutput( &fro, fname, false, 2, 16, eColorSpace_ProPhotoRGB );",
        "",
        "\t\t\t\t\tfro->OutputImage( *pOutputImage, 0, 0 );",
        "\t\t\t\t\tfro->release();\t\t\t\t",
        "\t\t\t\t}"
      ],
      "_frozen": true
    },
    {
      "file_path": "src/DRISE/Task.cpp",
      "matched_lines": [
        233,
        235,
        237,
        239,
        241
      ],
      "context_lines": [
        228,
        229,
        230,
        231,
        232,
        234,
        236,
        238,
        240,
        242,
        243,
        244,
        245,
        246
      ],
      "raw_surrounding_git_grep_lines": [
        "src/DRISE/Task.cpp-228-\t\t\t\tunsigned int\t\tms = timeforTask % 1000;",
        "src/DRISE/Task.cpp-229-",
        "src/DRISE/Task.cpp-230-\t\t\t\tchar buf[1024] = {0};",
        "src/DRISE/Task.cpp-231-\t\t\t\tstrcat( buf, \"Total Rasterization Time: \" );",
        "src/DRISE/Task.cpp-232-\t\t\t\tchar daybuf[32] = {0};",
        "src/DRISE/Task.cpp:233:\t\t\t\tsprintf( daybuf, \"%d days \", days );",
        "src/DRISE/Task.cpp-234-\t\t\t\tchar hourbuf[32] = {0};",
        "src/DRISE/Task.cpp:235:\t\t\t\tsprintf( hourbuf, \"%d hours \", hours );",
        "src/DRISE/Task.cpp-236-\t\t\t\tchar minbuf[32] = {0};",
        "src/DRISE/Task.cpp:237:\t\t\t\tsprintf( minbuf, \"%d minutes \", mins );",
        "src/DRISE/Task.cpp-238-\t\t\t\tchar secbuf[32] = {0};",
        "src/DRISE/Task.cpp:239:\t\t\t\tsprintf( secbuf, \"%d seconds \", secs );",
        "src/DRISE/Task.cpp-240-\t\t\t\tchar msbuf[32] = {0};",
        "src/DRISE/Task.cpp:241:\t\t\t\tsprintf( msbuf, \"%d ms\", ms );",
        "src/DRISE/Task.cpp-242-",
        "src/DRISE/Task.cpp-243-\t\t\t\tif( days ) {",
        "src/DRISE/Task.cpp-244-\t\t\t\t\tstrcat( buf, daybuf );",
        "src/DRISE/Task.cpp-245-\t\t\t\t}",
        "src/DRISE/Task.cpp-246-"
      ],
      "raw_content": [
        "\t\t\t\tunsigned int\t\tms = timeforTask % 1000;",
        "",
        "\t\t\t\tchar buf[1024] = {0};",
        "\t\t\t\tstrcat( buf, \"Total Rasterization Time: \" );",
        "\t\t\t\tchar daybuf[32] = {0};",
        "\t\t\t\tsprintf( daybuf, \"%d days \", days );",
        "\t\t\t\tchar hourbuf[32] = {0};",
        "\t\t\t\tsprintf( hourbuf, \"%d hours \", hours );",
        "\t\t\t\tchar minbuf[32] = {0};",
        "\t\t\t\tsprintf( minbuf, \"%d minutes \", mins );",
        "\t\t\t\tchar secbuf[32] = {0};",
        "\t\t\t\tsprintf( secbuf, \"%d seconds \", secs );",
        "\t\t\t\tchar msbuf[32] = {0};",
        "\t\t\t\tsprintf( msbuf, \"%d ms\", ms );",
        "",
        "\t\t\t\tif( days ) {",
        "\t\t\t\t\tstrcat( buf, daybuf );",
        "\t\t\t\t}",
        ""
      ],
      "_frozen": true
    },
    {
      "file_path": "src/Library/Parsers/AsciiCommandParser.cpp",
      "matched_lines": [
        494,
        496,
        498,
        500,
        502
      ],
      "context_lines": [
        489,
        490,
        491,
        492,
        493,
        495,
        497,
        499,
        501,
        503,
        504,
        505,
        506,
        507
      ],
      "raw_surrounding_git_grep_lines": [
        "src/Library/Parsers/AsciiCommandParser.cpp-489-\t\tunsigned int\t\tms = duration % 1000;",
        "src/Library/Parsers/AsciiCommandParser.cpp-490-",
        "src/Library/Parsers/AsciiCommandParser.cpp-491-\t\tchar buf[1024] = {0};",
        "src/Library/Parsers/AsciiCommandParser.cpp-492-\t\tstrcat( buf, \"Predicted Rasterization Time: \" );",
        "src/Library/Parsers/AsciiCommandParser.cpp-493-\t\tchar daybuf[32] = {0};",
        "src/Library/Parsers/AsciiCommandParser.cpp:494:\t\tsprintf( daybuf, \"%d days \", days );",
        "src/Library/Parsers/AsciiCommandParser.cpp-495-\t\tchar hourbuf[32] = {0};",
        "src/Library/Parsers/AsciiCommandParser.cpp:496:\t\tsprintf( hourbuf, \"%d hours \", hours );",
        "src/Library/Parsers/AsciiCommandParser.cpp-497-\t\tchar minbuf[32] = {0};",
        "src/Library/Parsers/AsciiCommandParser.cpp:498:\t\tsprintf( minbuf, \"%d minutes \", mins );",
        "src/Library/Parsers/AsciiCommandParser.cpp-499-\t\tchar secbuf[32] = {0};",
        "src/Library/Parsers/AsciiCommandParser.cpp:500:\t\tsprintf( secbuf, \"%d seconds \", secs );",
        "src/Library/Parsers/AsciiCommandParser.cpp-501-\t\tchar msbuf[32] = {0};",
        "src/Library/Parsers/AsciiCommandParser.cpp:502:\t\tsprintf( msbuf, \"%d ms\", ms );",
        "src/Library/Parsers/AsciiCommandParser.cpp-503-",
        "src/Library/Parsers/AsciiCommandParser.cpp-504-\t\tif( days ) {",
        "src/Library/Parsers/AsciiCommandParser.cpp-505-\t\t\tstrcat( buf, daybuf );",
        "src/Library/Parsers/AsciiCommandParser.cpp-506-\t\t}",
        "src/Library/Parsers/AsciiCommandParser.cpp-507-"
      ],
      "raw_content": [
        "\t\tunsigned int\t\tms = duration % 1000;",
        "",
        "\t\tchar buf[1024] = {0};",
        "\t\tstrcat( buf, \"Predicted Rasterization Time: \" );",
        "\t\tchar daybuf[32] = {0};",
        "\t\tsprintf( daybuf, \"%d days \", days );",
        "\t\tchar hourbuf[32] = {0};",
        "\t\tsprintf( hourbuf, \"%d hours \", hours );",
        "\t\tchar minbuf[32] = {0};",
        "\t\tsprintf( minbuf, \"%d minutes \", mins );",
        "\t\tchar secbuf[32] = {0};",
        "\t\tsprintf( secbuf, \"%d seconds \", secs );",
        "\t\tchar msbuf[32] = {0};",
        "\t\tsprintf( msbuf, \"%d ms\", ms );",
        "",
        "\t\tif( days ) {",
        "\t\t\tstrcat( buf, daybuf );",
        "\t\t}",
        ""
      ],
      "_frozen": true
    },
    {
      "file_path": "src/Library/Parsers/AsciiCommandParser.cpp",
      "matched_lines": [
        573,
        575,
        577,
        579,
        581
      ],
      "context_lines": [
        568,
        569,
        570,
        571,
        572,
        574,
        576,
        578,
        580,
        582,
        583,
        584,
        585,
        586
      ],
      "raw_surrounding_git_grep_lines": [
        "src/Library/Parsers/AsciiCommandParser.cpp-568-\tunsigned int\t\tms = duration % 1000;",
        "src/Library/Parsers/AsciiCommandParser.cpp-569-",
        "src/Library/Parsers/AsciiCommandParser.cpp-570-\tchar buf[1024] = {0};",
        "src/Library/Parsers/AsciiCommandParser.cpp-571-\tstrcat( buf, \"Total Rasterization Time: \" );",
        "src/Library/Parsers/AsciiCommandParser.cpp-572-\tchar daybuf[32] = {0};",
        "src/Library/Parsers/AsciiCommandParser.cpp:573:\tsprintf( daybuf, \"%d days \", days );",
        "src/Library/Parsers/AsciiCommandParser.cpp-574-\tchar hourbuf[32] = {0};",
        "src/Library/Parsers/AsciiCommandParser.cpp:575:\tsprintf( hourbuf, \"%d hours \", hours );",
        "src/Library/Parsers/AsciiCommandParser.cpp-576-\tchar minbuf[32] = {0};",
        "src/Library/Parsers/AsciiCommandParser.cpp:577:\tsprintf( minbuf, \"%d minutes \", mins );",
        "src/Library/Parsers/AsciiCommandParser.cpp-578-\tchar secbuf[32] = {0};",
        "src/Library/Parsers/AsciiCommandParser.cpp:579:\tsprintf( secbuf, \"%d seconds \", secs );",
        "src/Library/Parsers/AsciiCommandParser.cpp-580-\tchar msbuf[32] = {0};",
        "src/Library/Parsers/AsciiCommandParser.cpp:581:\tsprintf( msbuf, \"%d ms\", ms );",
        "src/Library/Parsers/AsciiCommandParser.cpp-582-",
        "src/Library/Parsers/AsciiCommandParser.cpp-583-\tif( days ) {",
        "src/Library/Parsers/AsciiCommandParser.cpp-584-\t\tstrcat( buf, daybuf );",
        "src/Library/Parsers/AsciiCommandParser.cpp-585-\t}",
        "src/Library/Parsers/AsciiCommandParser.cpp-586-"
      ],
      "raw_content": [
        "\tunsigned int\t\tms = duration % 1000;",
        "",
        "\tchar buf[1024] = {0};",
        "\tstrcat( buf, \"Total Rasterization Time: \" );",
        "\tchar daybuf[32] = {0};",
        "\tsprintf( daybuf, \"%d days \", days );",
        "\tchar hourbuf[32] = {0};",
        "\tsprintf( hourbuf, \"%d hours \", hours );",
        "\tchar minbuf[32] = {0};",
        "\tsprintf( minbuf, \"%d minutes \", mins );",
        "\tchar secbuf[32] = {0};",
        "\tsprintf( secbuf, \"%d seconds \", secs );",
        "\tchar msbuf[32] = {0};",
        "\tsprintf( msbuf, \"%d ms\", ms );",
        "",
        "\tif( days ) {",
        "\t\tstrcat( buf, daybuf );",
        "\t}",
        ""
      ],
      "_frozen": true
    },
    {
      "file_path": "src/Library/Parsers/AsciiCommandParser.cpp",
      "matched_lines": [
        658,
        660,
        662,
        664,
        666
      ],
      "context_lines": [
        653,
        654,
        655,
        656,
        657,
        659,
        661,
        663,
        665,
        667,
        668,
        669,
        670,
        671
      ],
      "raw_surrounding_git_grep_lines": [
        "src/Library/Parsers/AsciiCommandParser.cpp-653-\tunsigned int\t\tms = duration % 1000;",
        "src/Library/Parsers/AsciiCommandParser.cpp-654-",
        "src/Library/Parsers/AsciiCommandParser.cpp-655-\tchar buf[1024] = {0};",
        "src/Library/Parsers/AsciiCommandParser.cpp-656-\tstrcat( buf, \"Total Rasterization Time: \" );",
        "src/Library/Parsers/AsciiCommandParser.cpp-657-\tchar daybuf[32] = {0};",
        "src/Library/Parsers/AsciiCommandParser.cpp:658:\tsprintf( daybuf, \"%d days \", days );",
        "src/Library/Parsers/AsciiCommandParser.cpp-659-\tchar hourbuf[32] = {0};",
        "src/Library/Parsers/AsciiCommandParser.cpp:660:\tsprintf( hourbuf, \"%d hours \", hours );",
        "src/Library/Parsers/AsciiCommandParser.cpp-661-\tchar minbuf[32] = {0};",
        "src/Library/Parsers/AsciiCommandParser.cpp:662:\tsprintf( minbuf, \"%d minutes \", mins );",
        "src/Library/Parsers/AsciiCommandParser.cpp-663-\tchar secbuf[32] = {0};",
        "src/Library/Parsers/AsciiCommandParser.cpp:664:\tsprintf( secbuf, \"%d seconds \", secs );",
        "src/Library/Parsers/AsciiCommandParser.cpp-665-\tchar msbuf[32] = {0};",
        "src/Library/Parsers/AsciiCommandParser.cpp:666:\tsprintf( msbuf, \"%d ms\", ms );",
        "src/Library/Parsers/AsciiCommandParser.cpp-667-",
        "src/Library/Parsers/AsciiCommandParser.cpp-668-\tif( days ) {",
        "src/Library/Parsers/AsciiCommandParser.cpp-669-\t\tstrcat( buf, daybuf );",
        "src/Library/Parsers/AsciiCommandParser.cpp-670-\t}",
        "src/Library/Parsers/AsciiCommandParser.cpp-671-"
      ],
      "raw_content": [
        "\tunsigned int\t\tms = duration % 1000;",
        "",
        "\tchar buf[1024] = {0};",
        "\tstrcat( buf, \"Total Rasterization Time: \" );",
        "\tchar daybuf[32] = {0};",
        "\tsprintf( daybuf, \"%d days \", days );",
        "\tchar hourbuf[32] = {0};",
        "\tsprintf( hourbuf, \"%d hours \", hours );",
        "\tchar minbuf[32] = {0};",
        "\tsprintf( minbuf, \"%d minutes \", mins );",
        "\tchar secbuf[32] = {0};",
        "\tsprintf( secbuf, \"%d seconds \", secs );",
        "\tchar msbuf[32] = {0};",
        "\tsprintf( msbuf, \"%d ms\", ms );",
        "",
        "\tif( days ) {",
        "\t\tstrcat( buf, daybuf );",
        "\t}",
        ""
      ],
      "_frozen": true
    },
    {
      "file_path": "src/Library/Parsers/AsciiSceneParser.cpp",
      "matched_lines": [
        153
      ],
      "context_lines": [
        148,
        149,
        150,
        151,
        152,
        154,
        155,
        156,
        157,
        158
      ],
      "raw_surrounding_git_grep_lines": [
        "src/Library/Parsers/AsciiSceneParser.cpp-148-\t\tbreak;",
        "src/Library/Parsers/AsciiSceneParser.cpp-149-\t}",
        "src/Library/Parsers/AsciiSceneParser.cpp-150-",
        "src/Library/Parsers/AsciiSceneParser.cpp-151-\t// assemble together",
        "src/Library/Parsers/AsciiSceneParser.cpp-152-\tchar evaluated[64] = {0};",
        "src/Library/Parsers/AsciiSceneParser.cpp:153:\tsprintf( evaluated, \"%.12f\", val );",
        "src/Library/Parsers/AsciiSceneParser.cpp-154-",
        "src/Library/Parsers/AsciiSceneParser.cpp-155-\tprocessed.append( evaluated );",
        "src/Library/Parsers/AsciiSceneParser.cpp-156-\tprocessed.append( str.substr( y+1, str.length()-1 ) );",
        "src/Library/Parsers/AsciiSceneParser.cpp-157-",
        "src/Library/Parsers/AsciiSceneParser.cpp-158-\ttoken = String(processed.c_str());"
      ],
      "raw_content": [
        "\t\tbreak;",
        "\t}",
        "",
        "\t// assemble together",
        "\tchar evaluated[64] = {0};",
        "\tsprintf( evaluated, \"%.12f\", val );",
        "",
        "\tprocessed.append( evaluated );",
        "\tprocessed.append( str.substr( y+1, str.length()-1 ) );",
        "",
        "\ttoken = String(processed.c_str());"
      ],
      "_frozen": true
    },
    {
      "file_path": "src/Library/Parsers/AsciiSceneParser.cpp",
      "matched_lines": [
        215
      ],
      "context_lines": [
        210,
        211,
        212,
        213,
        214,
        216,
        217,
        218,
        219,
        220
      ],
      "raw_surrounding_git_grep_lines": [
        "src/Library/Parsers/AsciiSceneParser.cpp-210-\tif( expr.error() ) {",
        "src/Library/Parsers/AsciiSceneParser.cpp-211-\t\treturn false;",
        "src/Library/Parsers/AsciiSceneParser.cpp-212-\t}",
        "src/Library/Parsers/AsciiSceneParser.cpp-213-",
        "src/Library/Parsers/AsciiSceneParser.cpp-214-\tchar evaluated[64] = {0};",
        "src/Library/Parsers/AsciiSceneParser.cpp:215:\tsprintf( evaluated, \"%.12f\", expr.eval() );",
        "src/Library/Parsers/AsciiSceneParser.cpp-216-",
        "src/Library/Parsers/AsciiSceneParser.cpp-217-\ttoken = String(evaluated);",
        "src/Library/Parsers/AsciiSceneParser.cpp-218-\treturn true;",
        "src/Library/Parsers/AsciiSceneParser.cpp-219-}",
        "src/Library/Parsers/AsciiSceneParser.cpp-220-"
      ],
      "raw_content": [
        "\tif( expr.error() ) {",
        "\t\treturn false;",
        "\t}",
        "",
        "\tchar evaluated[64] = {0};",
        "\tsprintf( evaluated, \"%.12f\", expr.eval() );",
        "",
        "\ttoken = String(evaluated);",
        "\treturn true;",
        "}",
        ""
      ],
      "_frozen": true
    },
    {
      "file_path": "src/Library/Parsers/AsciiSceneParser.cpp",
      "matched_lines": [
        6364,
        6366
      ],
      "context_lines": [
        6359,
        6360,
        6361,
        6362,
        6363,
        6365,
        6367,
        6368,
        6369,
        6370,
        6371
      ],
      "raw_surrounding_git_grep_lines": [
        "src/Library/Parsers/AsciiSceneParser.cpp-6359-\t\t}",
        "src/Library/Parsers/AsciiSceneParser.cpp-6360-",
        "src/Library/Parsers/AsciiSceneParser.cpp-6361-\t\t// Re-assemble the string",
        "src/Library/Parsers/AsciiSceneParser.cpp-6362-\t\tchar buf[64] = {0};",
        "src/Library/Parsers/AsciiSceneParser.cpp-6363-\t\tif( macro_char == '@' ) {",
        "src/Library/Parsers/AsciiSceneParser.cpp:6364:\t\t\tsprintf( buf, \"%.12f\", it->second );",
        "src/Library/Parsers/AsciiSceneParser.cpp-6365-\t\t} else {",
        "src/Library/Parsers/AsciiSceneParser.cpp:6366:\t\t\tsprintf( buf, \"%.4d\", (int)it->second );",
        "src/Library/Parsers/AsciiSceneParser.cpp-6367-\t\t}",
        "src/Library/Parsers/AsciiSceneParser.cpp-6368-\t\tprocessed.append( buf );",
        "src/Library/Parsers/AsciiSceneParser.cpp-6369-",
        "src/Library/Parsers/AsciiSceneParser.cpp-6370-\t\tif( x<str.size() ) {",
        "src/Library/Parsers/AsciiSceneParser.cpp-6371-\t\t\tprocessed.append( str.substr( x, str.size() ) );"
      ],
      "raw_content": [
        "\t\t}",
        "",
        "\t\t// Re-assemble the string",
        "\t\tchar buf[64] = {0};",
        "\t\tif( macro_char == '@' ) {",
        "\t\t\tsprintf( buf, \"%.12f\", it->second );",
        "\t\t} else {",
        "\t\t\tsprintf( buf, \"%.4d\", (int)it->second );",
        "\t\t}",
        "\t\tprocessed.append( buf );",
        "",
        "\t\tif( x<str.size() ) {",
        "\t\t\tprocessed.append( str.substr( x, str.size() ) );"
      ],
      "_frozen": true
    },
    {
      "file_path": "src/Library/RasterImages/HDRWriter.cpp",
      "matched_lines": [
        15
      ],
      "context_lines": [
        10,
        11,
        12,
        13,
        14,
        16,
        17,
        18,
        19,
        20
      ],
      "raw_surrounding_git_grep_lines": [
        "src/Library/RasterImages/HDRWriter.cpp-10-//  License Information: Please see the attached LICENSE.TXT file",
        "src/Library/RasterImages/HDRWriter.cpp-11-//",
        "src/Library/RasterImages/HDRWriter.cpp-12-//////////////////////////////////////////////////////////////////////",
        "src/Library/RasterImages/HDRWriter.cpp-13-",
        "src/Library/RasterImages/HDRWriter.cpp-14-#include \"pch.h\"",
        "src/Library/RasterImages/HDRWriter.cpp:15:#include <stdio.h>\t\t\t\t\t// for sprintf",
        "src/Library/RasterImages/HDRWriter.cpp-16-#include <string.h>\t\t\t\t\t// for strlen and strncmp",
        "src/Library/RasterImages/HDRWriter.cpp-17-#include \"HDRWriter.h\"",
        "src/Library/RasterImages/HDRWriter.cpp-18-#include \"../Interfaces/ILog.h\"",
        "src/Library/RasterImages/HDRWriter.cpp-19-#include \"../Version.h\"",
        "src/Library/RasterImages/HDRWriter.cpp-20-"
      ],
      "raw_content": [
        "//  License Information: Please see the attached LICENSE.TXT file",
        "//",
        "//////////////////////////////////////////////////////////////////////",
        "",
        "#include \"pch.h\"",
        "#include <stdio.h>\t\t\t\t\t// for sprintf",
        "#include <string.h>\t\t\t\t\t// for strlen and strncmp",
        "#include \"HDRWriter.h\"",
        "#include \"../Interfaces/ILog.h\"",
        "#include \"../Version.h\"",
        ""
      ],
      "_frozen": true
    },
    {
      "file_path": "src/Library/RasterImages/HDRWriter.cpp",
      "matched_lines": [
        50,
        53
      ],
      "context_lines": [
        45,
        46,
        47,
        48,
        49,
        51,
        52,
        54,
        55,
        56,
        57,
        58
      ],
      "raw_surrounding_git_grep_lines": [
        "src/Library/RasterImages/HDRWriter.cpp-45-\t// Build the header",
        "src/Library/RasterImages/HDRWriter.cpp-46-\tchar szHeader[2048] = {0};",
        "src/Library/RasterImages/HDRWriter.cpp-47-\t{",
        "src/Library/RasterImages/HDRWriter.cpp-48-\t\tstatic const char * szSignature = \"#?RADIANCE\\n\";",
        "src/Library/RasterImages/HDRWriter.cpp-49-\t\tchar szWhoWroteIt[256] = {0};",
        "src/Library/RasterImages/HDRWriter.cpp:50:\t\tsprintf( szWhoWroteIt, \"# Generated by R.I.S.E. v%d.%d.%d build %d\\n\", RISE_VER_MAJOR_VERSION, RISE_VER_MINOR_VERSION, RISE_VER_REVISION_VERSION, RISE_VER_BUILD_VERSION );",
        "src/Library/RasterImages/HDRWriter.cpp-51-\t\tstatic const char * szImageType = \"FORMAT=32-bit_rle_rgbe\\n\\n\";",
        "src/Library/RasterImages/HDRWriter.cpp-52-\t\tchar szImageDimensions[256] = {0};",
        "src/Library/RasterImages/HDRWriter.cpp:53:\t\tsprintf( szImageDimensions,\"-Y %d +X %d\\n\", height, width );",
        "src/Library/RasterImages/HDRWriter.cpp-54-",
        "src/Library/RasterImages/HDRWriter.cpp-55-\t\tstrcpy( szHeader, szSignature );",
        "src/Library/RasterImages/HDRWriter.cpp-56-\t\tstrcat( szHeader, szWhoWroteIt );",
        "src/Library/RasterImages/HDRWriter.cpp-57-\t\tstrcat( szHeader, szImageType );",
        "src/Library/RasterImages/HDRWriter.cpp-58-\t\tstrcat( szHeader, szImageDimensions );"
      ],
      "raw_content": [
        "\t// Build the header",
        "\tchar szHeader[2048] = {0};",
        "\t{",
        "\t\tstatic const char * szSignature = \"#?RADIANCE\\n\";",
        "\t\tchar szWhoWroteIt[256] = {0};",
        "\t\tsprintf( szWhoWroteIt, \"# Generated by R.I.S.E. v%d.%d.%d build %d\\n\", RISE_VER_MAJOR_VERSION, RISE_VER_MINOR_VERSION, RISE_VER_REVISION_VERSION, RISE_VER_BUILD_VERSION );",
        "\t\tstatic const char * szImageType = \"FORMAT=32-bit_rle_rgbe\\n\\n\";",
        "\t\tchar szImageDimensions[256] = {0};",
        "\t\tsprintf( szImageDimensions,\"-Y %d +X %d\\n\", height, width );",
        "",
        "\t\tstrcpy( szHeader, szSignature );",
        "\t\tstrcat( szHeader, szWhoWroteIt );",
        "\t\tstrcat( szHeader, szImageType );",
        "\t\tstrcat( szHeader, szImageDimensions );"
      ],
      "_frozen": true
    },
    {
      "file_path": "src/Library/RasterImages/PPMWriter.cpp",
      "matched_lines": [
        50
      ],
      "context_lines": [
        45,
        46,
        47,
        48,
        49,
        51,
        52,
        53,
        54,
        55
      ],
      "raw_surrounding_git_grep_lines": [
        "src/Library/RasterImages/PPMWriter.cpp-45-void PPMWriter::BeginWrite( const unsigned int width, const unsigned int height )",
        "src/Library/RasterImages/PPMWriter.cpp-46-{",
        "src/Library/RasterImages/PPMWriter.cpp-47-\t// Write the header",
        "src/Library/RasterImages/PPMWriter.cpp-48-\t// Get a string with the header",
        "src/Library/RasterImages/PPMWriter.cpp-49-\tchar\theader[256] = {0};",
        "src/Library/RasterImages/PPMWriter.cpp:50:\tsprintf( header, \"P6\\n%d %d\\n255\\n\", width, height );",
        "src/Library/RasterImages/PPMWriter.cpp-51-",
        "src/Library/RasterImages/PPMWriter.cpp-52-\t// Make sure the buffer is the correct size",
        "src/Library/RasterImages/PPMWriter.cpp-53-\tpWriteBuffer.Resize( strlen( header ) + width*height*3 );",
        "src/Library/RasterImages/PPMWriter.cpp-54-",
        "src/Library/RasterImages/PPMWriter.cpp-55-\t// Copy the header"
      ],
      "raw_content": [
        "void PPMWriter::BeginWrite( const unsigned int width, const unsigned int height )",
        "{",
        "\t// Write the header",
        "\t// Get a string with the header",
        "\tchar\theader[256] = {0};",
        "\tsprintf( header, \"P6\\n%d %d\\n255\\n\", width, height );",
        "",
        "\t// Make sure the buffer is the correct size",
        "\tpWriteBuffer.Resize( strlen( header ) + width*height*3 );",
        "",
        "\t// Copy the header"
      ],
      "_frozen": true
    },
    {
      "file_path": "src/Library/RasterImages/RGBEAWriter.cpp",
      "matched_lines": [
        15
      ],
      "context_lines": [
        10,
        11,
        12,
        13,
        14,
        16,
        17,
        18,
        19,
        20
      ],
      "raw_surrounding_git_grep_lines": [
        "src/Library/RasterImages/RGBEAWriter.cpp-10-//  License Information: Please see the attached LICENSE.TXT file",
        "src/Library/RasterImages/RGBEAWriter.cpp-11-//",
        "src/Library/RasterImages/RGBEAWriter.cpp-12-//////////////////////////////////////////////////////////////////////",
        "src/Library/RasterImages/RGBEAWriter.cpp-13-",
        "src/Library/RasterImages/RGBEAWriter.cpp-14-#include \"pch.h\"",
        "src/Library/RasterImages/RGBEAWriter.cpp:15:#include <stdio.h>\t\t\t\t\t// for sprintf",
        "src/Library/RasterImages/RGBEAWriter.cpp-16-#include <string.h>\t\t\t\t\t// for strlen and strncmp",
        "src/Library/RasterImages/RGBEAWriter.cpp-17-#include \"RGBEAWriter.h\"",
        "src/Library/RasterImages/RGBEAWriter.cpp-18-#include \"../Interfaces/ILog.h\"",
        "src/Library/RasterImages/RGBEAWriter.cpp-19-#include \"../Version.h\"",
        "src/Library/RasterImages/RGBEAWriter.cpp-20-"
      ],
      "raw_content": [
        "//  License Information: Please see the attached LICENSE.TXT file",
        "//",
        "//////////////////////////////////////////////////////////////////////",
        "",
        "#include \"pch.h\"",
        "#include <stdio.h>\t\t\t\t\t// for sprintf",
        "#include <string.h>\t\t\t\t\t// for strlen and strncmp",
        "#include \"RGBEAWriter.h\"",
        "#include \"../Interfaces/ILog.h\"",
        "#include \"../Version.h\"",
        ""
      ],
      "_frozen": true
    },
    {
      "file_path": "src/Library/RasterImages/RGBEAWriter.cpp",
      "matched_lines": [
        49,
        52
      ],
      "context_lines": [
        44,
        45,
        46,
        47,
        48,
        50,
        51,
        53,
        54,
        55,
        56,
        57
      ],
      "raw_surrounding_git_grep_lines": [
        "src/Library/RasterImages/RGBEAWriter.cpp-44-\t// Build the header",
        "src/Library/RasterImages/RGBEAWriter.cpp-45-\tchar szHeader[2048] = {0};",
        "src/Library/RasterImages/RGBEAWriter.cpp-46-\t{",
        "src/Library/RasterImages/RGBEAWriter.cpp-47-\t\tstatic const char * szSignature = \"#?RGBEA\\n\";",
        "src/Library/RasterImages/RGBEAWriter.cpp-48-\t\tchar szWhoWroteIt[256] = {0};",
        "src/Library/RasterImages/RGBEAWriter.cpp:49:\t\tsprintf( szWhoWroteIt, \"# Generated by R.I.S.E. v%d.%d.%d build %d\\n\", RISE_VER_MAJOR_VERSION, RISE_VER_MINOR_VERSION, RISE_VER_REVISION_VERSION, RISE_VER_BUILD_VERSION );",
        "src/Library/RasterImages/RGBEAWriter.cpp-50-\t\tstatic const char * szImageType = \"FORMAT=64-bit_rle_rgbea\\n\\n\";",
        "src/Library/RasterImages/RGBEAWriter.cpp-51-\t\tchar szImageDimensions[256] = {0};",
        "src/Library/RasterImages/RGBEAWriter.cpp:52:\t\tsprintf( szImageDimensions,\"-Y %d +X %d\\n\", height, width );",
        "src/Library/RasterImages/RGBEAWriter.cpp-53-",
        "src/Library/RasterImages/RGBEAWriter.cpp-54-\t\tstrcpy( szHeader, szSignature );",
        "src/Library/RasterImages/RGBEAWriter.cpp-55-\t\tstrcat( szHeader, szWhoWroteIt );",
        "src/Library/RasterImages/RGBEAWriter.cpp-56-\t\tstrcat( szHeader, szImageType );",
        "src/Library/RasterImages/RGBEAWriter.cpp-57-\t\tstrcat( szHeader, szImageDimensions );"
      ],
      "raw_content": [
        "\t// Build the header",
        "\tchar szHeader[2048] = {0};",
        "\t{",
        "\t\tstatic const char * szSignature = \"#?RGBEA\\n\";",
        "\t\tchar szWhoWroteIt[256] = {0};",
        "\t\tsprintf( szWhoWroteIt, \"# Generated by R.I.S.E. v%d.%d.%d build %d\\n\", RISE_VER_MAJOR_VERSION, RISE_VER_MINOR_VERSION, RISE_VER_REVISION_VERSION, RISE_VER_BUILD_VERSION );",
        "\t\tstatic const char * szImageType = \"FORMAT=64-bit_rle_rgbea\\n\\n\";",
        "\t\tchar szImageDimensions[256] = {0};",
        "\t\tsprintf( szImageDimensions,\"-Y %d +X %d\\n\", height, width );",
        "",
        "\t\tstrcpy( szHeader, szSignature );",
        "\t\tstrcat( szHeader, szWhoWroteIt );",
        "\t\tstrcat( szHeader, szImageType );",
        "\t\tstrcat( szHeader, szImageDimensions );"
      ],
      "_frozen": true
    },
    {
      "file_path": "src/Library/Rendering/FileRasterizerOutput.cpp",
      "matched_lines": [
        100,
        102
      ],
      "context_lines": [
        95,
        96,
        97,
        98,
        99,
        101,
        103,
        104,
        105,
        106,
        107
      ],
      "raw_surrounding_git_grep_lines": [
        "src/Library/Rendering/FileRasterizerOutput.cpp-95-\tIRasterImageWriter*\t\tpWriter = 0;",
        "src/Library/Rendering/FileRasterizerOutput.cpp-96-",
        "src/Library/Rendering/FileRasterizerOutput.cpp-97-\tchar\tbuf[2048];",
        "src/Library/Rendering/FileRasterizerOutput.cpp-98-",
        "src/Library/Rendering/FileRasterizerOutput.cpp-99-\tif( bMultiple ) {",
        "src/Library/Rendering/FileRasterizerOutput.cpp:100:\t\tsprintf( buf, \"%s%.4d.%s\", szPattern, frame, extensions[type] );",
        "src/Library/Rendering/FileRasterizerOutput.cpp-101-\t} else {",
        "src/Library/Rendering/FileRasterizerOutput.cpp:102:\t\tsprintf( buf, \"%s.%s\", szPattern, extensions[type] );",
        "src/Library/Rendering/FileRasterizerOutput.cpp-103-\t}",
        "src/Library/Rendering/FileRasterizerOutput.cpp-104-",
        "src/Library/Rendering/FileRasterizerOutput.cpp-105-\tDiskFileWriteBuffer*\t\tmb = new DiskFileWriteBuffer( buf );",
        "src/Library/Rendering/FileRasterizerOutput.cpp-106-\t",
        "src/Library/Rendering/FileRasterizerOutput.cpp-107-\tif( !mb->ReadyToWrite() ) {"
      ],
      "raw_content": [
        "\tIRasterImageWriter*\t\tpWriter = 0;",
        "",
        "\tchar\tbuf[2048];",
        "",
        "\tif( bMultiple ) {",
        "\t\tsprintf( buf, \"%s%.4d.%s\", szPattern, frame, extensions[type] );",
        "\t} else {",
        "\t\tsprintf( buf, \"%s.%s\", szPattern, extensions[type] );",
        "\t}",
        "",
        "\tDiskFileWriteBuffer*\t\tmb = new DiskFileWriteBuffer( buf );",
        "\t",
        "\tif( !mb->ReadyToWrite() ) {"
      ],
      "_frozen": true
    },
    {
      "file_path": "src/Library/Rendering/FileRasterizerOutput.cpp",
      "matched_lines": [
        116,
        118
      ],
      "context_lines": [
        111,
        112,
        113,
        114,
        115,
        117,
        119,
        120,
        121,
        122,
        123
      ],
      "raw_surrounding_git_grep_lines": [
        "src/Library/Rendering/FileRasterizerOutput.cpp-111-",
        "src/Library/Rendering/FileRasterizerOutput.cpp-112-\t\tsafe_release( mb );",
        "src/Library/Rendering/FileRasterizerOutput.cpp-113-",
        "src/Library/Rendering/FileRasterizerOutput.cpp-114-\t\tconst FileRasterizerOutput* pMe = this;",
        "src/Library/Rendering/FileRasterizerOutput.cpp-115-\t\tif( bMultiple ) {",
        "src/Library/Rendering/FileRasterizerOutput.cpp:116:\t\t\tsprintf( buf, \"fro_temp_%d_%.4d.%s\", VoidPtrToUInt((void*)pMe), frame, extensions[type] );",
        "src/Library/Rendering/FileRasterizerOutput.cpp-117-\t\t} else {",
        "src/Library/Rendering/FileRasterizerOutput.cpp:118:\t\t\tsprintf( buf, \"fro_temp_%d.%s\", VoidPtrToUInt((void*)pMe), extensions[type] );",
        "src/Library/Rendering/FileRasterizerOutput.cpp-119-\t\t}",
        "src/Library/Rendering/FileRasterizerOutput.cpp-120-",
        "src/Library/Rendering/FileRasterizerOutput.cpp-121-\t\tmb = new DiskFileWriteBuffer( buf );",
        "src/Library/Rendering/FileRasterizerOutput.cpp-122-",
        "src/Library/Rendering/FileRasterizerOutput.cpp-123-\t\t// If that doesn't work either we are just screwed"
      ],
      "raw_content": [
        "",
        "\t\tsafe_release( mb );",
        "",
        "\t\tconst FileRasterizerOutput* pMe = this;",
        "\t\tif( bMultiple ) {",
        "\t\t\tsprintf( buf, \"fro_temp_%d_%.4d.%s\", VoidPtrToUInt((void*)pMe), frame, extensions[type] );",
        "\t\t} else {",
        "\t\t\tsprintf( buf, \"fro_temp_%d.%s\", VoidPtrToUInt((void*)pMe), extensions[type] );",
        "\t\t}",
        "",
        "\t\tmb = new DiskFileWriteBuffer( buf );",
        "",
        "\t\t// If that doesn't work either we are just screwed"
      ],
      "_frozen": true
    },
    {
      "file_path": "src/Library/Rendering/Win32WindowRasterizerOutput.cpp",
      "matched_lines": [
        141
      ],
      "context_lines": [
        136,
        137,
        138,
        139,
        140,
        142,
        143,
        144,
        145,
        146
      ],
      "raw_surrounding_git_grep_lines": [
        "src/Library/Rendering/Win32WindowRasterizerOutput.cpp-136-\t\t\tmemset( &pBits[y*width*4+x*4+2], 0, 1 );",
        "src/Library/Rendering/Win32WindowRasterizerOutput.cpp-137-\t\t}",
        "src/Library/Rendering/Win32WindowRasterizerOutput.cpp-138-\t}",
        "src/Library/Rendering/Win32WindowRasterizerOutput.cpp-139-\t",
        "src/Library/Rendering/Win32WindowRasterizerOutput.cpp-140-\tchar buf[_MAX_PATH] = {0};",
        "src/Library/Rendering/Win32WindowRasterizerOutput.cpp:141:\tsprintf( buf, \"RISE_Neverset_Thread_Handle_%d_%d\", GetTickCount(), rand() );",
        "src/Library/Rendering/Win32WindowRasterizerOutput.cpp-142-\thStop = CreateEvent( 0, FALSE, FALSE, buf );",
        "src/Library/Rendering/Win32WindowRasterizerOutput.cpp-143-",
        "src/Library/Rendering/Win32WindowRasterizerOutput.cpp-144-\t// We need to create a message pump so that this window can keep processing messages",
        "src/Library/Rendering/Win32WindowRasterizerOutput.cpp-145-\thThread = CreateThread( 0, 0, WindowMessagePump, (LPVOID)this, 0, 0 );",
        "src/Library/Rendering/Win32WindowRasterizerOutput.cpp-146-}"
      ],
      "raw_content": [
        "\t\t\tmemset( &pBits[y*width*4+x*4+2], 0, 1 );",
        "\t\t}",
        "\t}",
        "\t",
        "\tchar buf[_MAX_PATH] = {0};",
        "\tsprintf( buf, \"RISE_Neverset_Thread_Handle_%d_%d\", GetTickCount(), rand() );",
        "\thStop = CreateEvent( 0, FALSE, FALSE, buf );",
        "",
        "\t// We need to create a message pump so that this window can keep processing messages",
        "\thThread = CreateThread( 0, 0, WindowMessagePump, (LPVOID)this, 0, 0 );",
        "}"
      ],
      "_frozen": true
    },
    {
      "file_path": "src/Library/Rendering/Win32WindowRasterizerOutput.cpp",
      "matched_lines": [
        313
      ],
      "context_lines": [
        308,
        309,
        310,
        311,
        312,
        314,
        315,
        316,
        317,
        318
      ],
      "raw_surrounding_git_grep_lines": [
        "src/Library/Rendering/Win32WindowRasterizerOutput.cpp-308-\t// that requires a unique name for this particular context... <sigh>",
        "src/Library/Rendering/Win32WindowRasterizerOutput.cpp-309-",
        "src/Library/Rendering/Win32WindowRasterizerOutput.cpp-310-\thInstance = GetModuleHandle( NULL );",
        "src/Library/Rendering/Win32WindowRasterizerOutput.cpp-311-",
        "src/Library/Rendering/Win32WindowRasterizerOutput.cpp-312-\tszClassName[0] = 0;",
        "src/Library/Rendering/Win32WindowRasterizerOutput.cpp:313:\tsprintf( szClassName, \"RISE::Win32Context::%d::%d\", GetTickCount(), rand() );",
        "src/Library/Rendering/Win32WindowRasterizerOutput.cpp-314-",
        "src/Library/Rendering/Win32WindowRasterizerOutput.cpp-315-\tWNDCLASSEX\t\twc = {\tsizeof(WNDCLASSEX),",
        "src/Library/Rendering/Win32WindowRasterizerOutput.cpp-316-\t\t\t\t\t\t\tCS_CLASSDC,",
        "src/Library/Rendering/Win32WindowRasterizerOutput.cpp-317-\t\t\t\t\t\t\tMsgProc,",
        "src/Library/Rendering/Win32WindowRasterizerOutput.cpp-318-\t\t\t\t\t\t\t0L, 0L, "
      ],
      "raw_content": [
        "\t// that requires a unique name for this particular context... <sigh>",
        "",
        "\thInstance = GetModuleHandle( NULL );",
        "",
        "\tszClassName[0] = 0;",
        "\tsprintf( szClassName, \"RISE::Win32Context::%d::%d\", GetTickCount(), rand() );",
        "",
        "\tWNDCLASSEX\t\twc = {\tsizeof(WNDCLASSEX),",
        "\t\t\t\t\t\t\tCS_CLASSDC,",
        "\t\t\t\t\t\t\tMsgProc,",
        "\t\t\t\t\t\t\t0L, 0L, "
      ],
      "_frozen": true
    },
    {
      "file_path": "src/Library/Utilities/Communications/SocketCommunications.cpp",
      "matched_lines": [
        45,
        50
      ],
      "context_lines": [
        40,
        41,
        42,
        43,
        44,
        46,
        47,
        48,
        49,
        51,
        52,
        53,
        54,
        55
      ],
      "raw_surrounding_git_grep_lines": [
        "src/Library/Utilities/Communications/SocketCommunications.cpp-40-",
        "src/Library/Utilities/Communications/SocketCommunications.cpp-41-\terror = WSAStartup( d_winsockVersion, &d_winsockData );",
        "src/Library/Utilities/Communications/SocketCommunications.cpp-42-\tif( error == SOCKET_ERROR )",
        "src/Library/Utilities/Communications/SocketCommunications.cpp-43-\t{",
        "src/Library/Utilities/Communications/SocketCommunications.cpp-44-\t\tif( error == WSAVERNOTSUPPORTED ) {",
        "src/Library/Utilities/Communications/SocketCommunications.cpp:45:\t\t\tsprintf( buffer, \"WSAStartup error.\\nRequested Winsock v%d.%d, found v%d.%d.\",",
        "src/Library/Utilities/Communications/SocketCommunications.cpp-46-\t\t\tWINSOCK_MAJOR_VERSION, WINSOCK_MINOR_VERSION,",
        "src/Library/Utilities/Communications/SocketCommunications.cpp-47-\t\t\tLOBYTE( d_winsockData.wVersion ), HIBYTE( d_winsockData.wVersion ) );",
        "src/Library/Utilities/Communications/SocketCommunications.cpp-48-\t\t\tWSACleanup();",
        "src/Library/Utilities/Communications/SocketCommunications.cpp-49-\t\t} else {",
        "src/Library/Utilities/Communications/SocketCommunications.cpp:50:\t\t\tsprintf( buffer, \"WSAStartup error (%d)\", WSAGetLastError() );",
        "src/Library/Utilities/Communications/SocketCommunications.cpp-51-\t\t}",
        "src/Library/Utilities/Communications/SocketCommunications.cpp-52-",
        "src/Library/Utilities/Communications/SocketCommunications.cpp-53-\t\tGlobalLog()->PrintSourceError( buffer, __FILE__, __LINE__ );",
        "src/Library/Utilities/Communications/SocketCommunications.cpp-54-\t\treturn false;",
        "src/Library/Utilities/Communications/SocketCommunications.cpp-55-\t}"
      ],
      "raw_content": [
        "",
        "\terror = WSAStartup( d_winsockVersion, &d_winsockData );",
        "\tif( error == SOCKET_ERROR )",
        "\t{",
        "\t\tif( error == WSAVERNOTSUPPORTED ) {",
        "\t\t\tsprintf( buffer, \"WSAStartup error.\\nRequested Winsock v%d.%d, found v%d.%d.\",",
        "\t\t\tWINSOCK_MAJOR_VERSION, WINSOCK_MINOR_VERSION,",
        "\t\t\tLOBYTE( d_winsockData.wVersion ), HIBYTE( d_winsockData.wVersion ) );",
        "\t\t\tWSACleanup();",
        "\t\t} else {",
        "\t\t\tsprintf( buffer, \"WSAStartup error (%d)\", WSAGetLastError() );",
        "\t\t}",
        "",
        "\t\tGlobalLog()->PrintSourceError( buffer, __FILE__, __LINE__ );",
        "\t\treturn false;",
        "\t}"
      ],
      "_frozen": true
    },
    {
      "file_path": "src/Library/Volume/Volume.h",
      "matched_lines": [
        83
      ],
      "context_lines": [
        78,
        79,
        80,
        81,
        82,
        84,
        85,
        86,
        87,
        88
      ],
      "raw_surrounding_git_grep_lines": [
        "src/Library/Volume/Volume.h-78-",
        "src/Library/Volume/Volume.h-79-\t\t\tfor( unsigned int i=zstart, cnt=0; i<=zend; i++, cnt++ )",
        "src/Library/Volume/Volume.h-80-\t\t\t{",
        "src/Library/Volume/Volume.h-81-\t\t\t\tchar buffer[1024] = {0};",
        "src/Library/Volume/Volume.h-82-",
        "src/Library/Volume/Volume.h:83:\t\t\t\tsprintf( buffer, szFilePattern, i );",
        "src/Library/Volume/Volume.h-84-\t\t\t\tFILE* f = fopen( GlobalMediaPathLocator().Find(buffer).c_str(), \"rb\" );",
        "src/Library/Volume/Volume.h-85-",
        "src/Library/Volume/Volume.h-86-\t\t\t\tif( f ) {",
        "src/Library/Volume/Volume.h-87-\t\t\t\t\tfread( &m_pData[cnt*width*height], sizeof( T ), m_nWidth*m_nHeight, f );",
        "src/Library/Volume/Volume.h-88-\t\t\t\t\tfclose( f );"
      ],
      "raw_content": [
        "",
        "\t\t\tfor( unsigned int i=zstart, cnt=0; i<=zend; i++, cnt++ )",
        "\t\t\t{",
        "\t\t\t\tchar buffer[1024] = {0};",
        "",
        "\t\t\t\tsprintf( buffer, szFilePattern, i );",
        "\t\t\t\tFILE* f = fopen( GlobalMediaPathLocator().Find(buffer).c_str(), \"rb\" );",
        "",
        "\t\t\t\tif( f ) {",
        "\t\t\t\t\tfread( &m_pData[cnt*width*height], sizeof( T ), m_nWidth*m_nHeight, f );",
        "\t\t\t\t\tfclose( f );"
      ],
      "_frozen": true
    },
    {
      "file_path": "src/PRISE/SchedulerEngine.cpp",
      "matched_lines": [
        160
      ],
      "context_lines": [
        155,
        156,
        157,
        158,
        159,
        161,
        162,
        163,
        164,
        165
      ],
      "raw_surrounding_git_grep_lines": [
        "src/PRISE/SchedulerEngine.cpp-155-\t{",
        "src/PRISE/SchedulerEngine.cpp-156-\t\tpMesh = new PRISEMeshGeometry(0,0,0,0);",
        "src/PRISE/SchedulerEngine.cpp-157-\t\tGlobalLog()->PrintNew( pMesh, __FILE__, __LINE__, \"geometry\" );",
        "src/PRISE/SchedulerEngine.cpp-158-",
        "src/PRISE/SchedulerEngine.cpp-159-\t\tchar szModelFileName[1024] = {0};",
        "src/PRISE/SchedulerEngine.cpp:160:\t\tsprintf( szModelFileName, \"%s_%d.prisemesh\", sceneModels.front().szFilename.c_str(), -1 );",
        "src/PRISE/SchedulerEngine.cpp-161-",
        "src/PRISE/SchedulerEngine.cpp-162-\t\tImplementation::MemoryBuffer*\t\t\tpBuffer = new Implementation::MemoryBuffer( szModelFileName );",
        "src/PRISE/SchedulerEngine.cpp-163-\t\tGlobalLog()->PrintNew( pBuffer, __FILE__, __LINE__, \"buffer\" );",
        "src/PRISE/SchedulerEngine.cpp-164-",
        "src/PRISE/SchedulerEngine.cpp-165-\t\tpMesh->Deserialize( *pBuffer );"
      ],
      "raw_content": [
        "\t{",
        "\t\tpMesh = new PRISEMeshGeometry(0,0,0,0);",
        "\t\tGlobalLog()->PrintNew( pMesh, __FILE__, __LINE__, \"geometry\" );",
        "",
        "\t\tchar szModelFileName[1024] = {0};",
        "\t\tsprintf( szModelFileName, \"%s_%d.prisemesh\", sceneModels.front().szFilename.c_str(), -1 );",
        "",
        "\t\tImplementation::MemoryBuffer*\t\t\tpBuffer = new Implementation::MemoryBuffer( szModelFileName );",
        "\t\tGlobalLog()->PrintNew( pBuffer, __FILE__, __LINE__, \"buffer\" );",
        "",
        "\t\tpMesh->Deserialize( *pBuffer );"
      ],
      "_frozen": true
    },
    {
      "file_path": "src/PRISE/WorkerConnection.cpp",
      "matched_lines": [
        68
      ],
      "context_lines": [
        63,
        64,
        65,
        66,
        67,
        69,
        70,
        71,
        72,
        73
      ],
      "raw_surrounding_git_grep_lines": [
        "src/PRISE/WorkerConnection.cpp-63-\t\tret = TrySendMessage( eMessage_ModelCount, true );",
        "src/PRISE/WorkerConnection.cpp-64-",
        "src/PRISE/WorkerConnection.cpp-65-\t\tstd::deque<MODEL_INFO>::const_iterator\tit;",
        "src/PRISE/WorkerConnection.cpp-66-\t\tfor( it=szModels.begin(); it!=szModels.end(); it++ ) {",
        "src/PRISE/WorkerConnection.cpp-67-\t\t\tchar szModelFileName[1024] = {0};",
        "src/PRISE/WorkerConnection.cpp:68:\t\t\tsprintf( szModelFileName, \"%s_%d.prisemesh\", it->szFilename.c_str(), nWorkerID );",
        "src/PRISE/WorkerConnection.cpp-69-",
        "src/PRISE/WorkerConnection.cpp-70-\t\t\tunsigned int length = strlen(szModelFileName); ",
        "src/PRISE/WorkerConnection.cpp-71-\t\t\tunsigned int matlength = strlen(it->material.c_str());",
        "src/PRISE/WorkerConnection.cpp-72-\t\t\tpSendBuffer->Resize( sizeof( Point3D ) + sizeof( Vector3D ) + length + matlength + 2, true );",
        "src/PRISE/WorkerConnection.cpp-73-\t\t\tpSendBuffer->seek( IBuffer::START, 0 );"
      ],
      "raw_content": [
        "\t\tret = TrySendMessage( eMessage_ModelCount, true );",
        "",
        "\t\tstd::deque<MODEL_INFO>::const_iterator\tit;",
        "\t\tfor( it=szModels.begin(); it!=szModels.end(); it++ ) {",
        "\t\t\tchar szModelFileName[1024] = {0};",
        "\t\t\tsprintf( szModelFileName, \"%s_%d.prisemesh\", it->szFilename.c_str(), nWorkerID );",
        "",
        "\t\t\tunsigned int length = strlen(szModelFileName); ",
        "\t\t\tunsigned int matlength = strlen(it->material.c_str());",
        "\t\t\tpSendBuffer->Resize( sizeof( Point3D ) + sizeof( Vector3D ) + length + matlength + 2, true );",
        "\t\t\tpSendBuffer->seek( IBuffer::START, 0 );"
      ],
      "_frozen": true
    },
    {
      "file_path": "src/PRISE/prise_mpi_worker.cpp",
      "matched_lines": [
        149
      ],
      "context_lines": [
        144,
        145,
        146,
        147,
        148,
        150,
        151,
        152,
        153,
        154
      ],
      "raw_surrounding_git_grep_lines": [
        "src/PRISE/prise_mpi_worker.cpp-144-",
        "src/PRISE/prise_mpi_worker.cpp-145-\t// Disable aspects of the logger, so that different processes don't conflict on the same log file",
        "src/PRISE/prise_mpi_worker.cpp-146-\tGlobalLogPriv()->RemoveAllPrinters();",
        "src/PRISE/prise_mpi_worker.cpp-147-",
        "src/PRISE/prise_mpi_worker.cpp-148-\tchar buf[1024];",
        "src/PRISE/prise_mpi_worker.cpp:149:\tsprintf( buf, \"PRISE_Worker_Log_Proc%d.txt\", rank );",
        "src/PRISE/prise_mpi_worker.cpp-150-\tstd::ofstream*\t\tfs = new std::ofstream( buf );",
        "src/PRISE/prise_mpi_worker.cpp-151-\tStreamPrinter*\t\tpB = new StreamPrinter( fs, true );",
        "src/PRISE/prise_mpi_worker.cpp-152-\tGlobalLog()->PrintNew( pB, __FILE__, __LINE__, \"file stream printer\" );",
        "src/PRISE/prise_mpi_worker.cpp-153-\tGlobalLogPriv()->AddPrinter( pB );",
        "src/PRISE/prise_mpi_worker.cpp-154-\tpB->RemoveRef();"
      ],
      "raw_content": [
        "",
        "\t// Disable aspects of the logger, so that different processes don't conflict on the same log file",
        "\tGlobalLogPriv()->RemoveAllPrinters();",
        "",
        "\tchar buf[1024];",
        "\tsprintf( buf, \"PRISE_Worker_Log_Proc%d.txt\", rank );",
        "\tstd::ofstream*\t\tfs = new std::ofstream( buf );",
        "\tStreamPrinter*\t\tpB = new StreamPrinter( fs, true );",
        "\tGlobalLog()->PrintNew( pB, __FILE__, __LINE__, \"file stream printer\" );",
        "\tGlobalLogPriv()->AddPrinter( pB );",
        "\tpB->RemoveRef();"
      ],
      "_frozen": true
    },
    {
      "file_path": "src/PRISE/prise_scheduler.cpp",
      "matched_lines": [
        158
      ],
      "context_lines": [
        153,
        154,
        155,
        156,
        157,
        159,
        160,
        161,
        162,
        163
      ],
      "raw_surrounding_git_grep_lines": [
        "src/PRISE/prise_scheduler.cpp-153-",
        "src/PRISE/prise_scheduler.cpp-154-\tConsoleWin32* pA = new ConsoleWin32( eLog_Win32Console, TYPICAL_PRIORITY, HIGHEST_PRIORITY );",
        "src/PRISE/prise_scheduler.cpp-155-\tGlobalLog()->PrintNew( pA, __FILE__, __LINE__, \"Win32 Console printer\" );",
        "src/PRISE/prise_scheduler.cpp-156-\tconst char *szWndTitle = \"Parallel Realistic Image Synthesis Engine (P.R.I.S.E) Scheduler Console\";",
        "src/PRISE/prise_scheduler.cpp-157-\tchar szWindowName[1024];",
        "src/PRISE/prise_scheduler.cpp:158:\tsprintf( szWindowName, \"%s v. %d.%d.%d build %d\", szWndTitle, RISE_VER_MAJOR_VERSION, RISE_VER_MINOR_VERSION, RISE_VER_REVISION_VERSION, RISE_VER_BUILD_VERSION );",
        "src/PRISE/prise_scheduler.cpp-159-\tpA->Init( szWindowName, hInstance );",
        "src/PRISE/prise_scheduler.cpp-160-\tGlobalLogPriv()->AddPrinter( pA );",
        "src/PRISE/prise_scheduler.cpp-161-\tpA->RemoveRef();",
        "src/PRISE/prise_scheduler.cpp-162-",
        "src/PRISE/prise_scheduler.cpp-163-\tGlobalLog()->PrintEasyEvent( \"============================================================\" );"
      ],
      "raw_content": [
        "",
        "\tConsoleWin32* pA = new ConsoleWin32( eLog_Win32Console, TYPICAL_PRIORITY, HIGHEST_PRIORITY );",
        "\tGlobalLog()->PrintNew( pA, __FILE__, __LINE__, \"Win32 Console printer\" );",
        "\tconst char *szWndTitle = \"Parallel Realistic Image Synthesis Engine (P.R.I.S.E) Scheduler Console\";",
        "\tchar szWindowName[1024];",
        "\tsprintf( szWindowName, \"%s v. %d.%d.%d build %d\", szWndTitle, RISE_VER_MAJOR_VERSION, RISE_VER_MINOR_VERSION, RISE_VER_REVISION_VERSION, RISE_VER_BUILD_VERSION );",
        "\tpA->Init( szWindowName, hInstance );",
        "\tGlobalLogPriv()->AddPrinter( pA );",
        "\tpA->RemoveRef();",
        "",
        "\tGlobalLog()->PrintEasyEvent( \"============================================================\" );"
      ],
      "_frozen": true
    },
    {
      "file_path": "src/PRISE/prise_worker.cpp",
      "matched_lines": [
        205
      ],
      "context_lines": [
        200,
        201,
        202,
        203,
        204,
        206,
        207,
        208,
        209,
        210
      ],
      "raw_surrounding_git_grep_lines": [
        "src/PRISE/prise_worker.cpp-200-",
        "src/PRISE/prise_worker.cpp-201-\tConsoleWin32* pA = new ConsoleWin32( eLog_Win32Console, TYPICAL_PRIORITY, HIGHEST_PRIORITY );",
        "src/PRISE/prise_worker.cpp-202-\tGlobalLog()->PrintNew( pA, __FILE__, __LINE__, \"Win32 Console printer\" );",
        "src/PRISE/prise_worker.cpp-203-\tconst char *szWndTitle = \"Parallel Realistic Image Synthesis Engine (P.R.I.S.E) Worker Console\";",
        "src/PRISE/prise_worker.cpp-204-\tchar szWindowName[1024];",
        "src/PRISE/prise_worker.cpp:205:\tsprintf( szWindowName, \"%s v. %d.%d.%d build %d\", szWndTitle, RISE_VER_MAJOR_VERSION, RISE_VER_MINOR_VERSION, RISE_VER_REVISION_VERSION, RISE_VER_BUILD_VERSION );",
        "src/PRISE/prise_worker.cpp-206-\tpA->Init( szWindowName, hInstance );",
        "src/PRISE/prise_worker.cpp-207-\tGlobalLogPriv()->AddPrinter( pA );",
        "src/PRISE/prise_worker.cpp-208-\tpA->RemoveRef();",
        "src/PRISE/prise_worker.cpp-209-",
        "src/PRISE/prise_worker.cpp-210-\tGlobalLog()->PrintEasyEvent( \"============================================================\" );"
      ],
      "raw_content": [
        "",
        "\tConsoleWin32* pA = new ConsoleWin32( eLog_Win32Console, TYPICAL_PRIORITY, HIGHEST_PRIORITY );",
        "\tGlobalLog()->PrintNew( pA, __FILE__, __LINE__, \"Win32 Console printer\" );",
        "\tconst char *szWndTitle = \"Parallel Realistic Image Synthesis Engine (P.R.I.S.E) Worker Console\";",
        "\tchar szWindowName[1024];",
        "\tsprintf( szWindowName, \"%s v. %d.%d.%d build %d\", szWndTitle, RISE_VER_MAJOR_VERSION, RISE_VER_MINOR_VERSION, RISE_VER_REVISION_VERSION, RISE_VER_BUILD_VERSION );",
        "\tpA->Init( szWindowName, hInstance );",
        "\tGlobalLogPriv()->AddPrinter( pA );",
        "\tpA->RemoveRef();",
        "",
        "\tGlobalLog()->PrintEasyEvent( \"============================================================\" );"
      ],
      "_frozen": true
    },
    {
      "file_path": "src/PRISE/prisemeshmaker.cpp",
      "matched_lines": [
        205
      ],
      "context_lines": [
        200,
        201,
        202,
        203,
        204,
        206,
        207,
        208,
        209,
        210
      ],
      "raw_surrounding_git_grep_lines": [
        "src/PRISE/prisemeshmaker.cpp-200-\t\tMemoryBuffer*\tmb = new MemoryBuffer();",
        "src/PRISE/prisemeshmaker.cpp-201-\t\tmb->Resize( 0x10000000 );",
        "src/PRISE/prisemeshmaker.cpp-202-\t\tgeom->SerializeForCPU( *mb, i );",
        "src/PRISE/prisemeshmaker.cpp-203-",
        "src/PRISE/prisemeshmaker.cpp-204-\t\tchar\tfilename[1024];",
        "src/PRISE/prisemeshmaker.cpp:205:\t\tsprintf( filename, \"%s_%d.prisemesh\", argv[2], i );",
        "src/PRISE/prisemeshmaker.cpp-206-",
        "src/PRISE/prisemeshmaker.cpp-207-\t\tmb->DumpToFileToCursor( filename );",
        "src/PRISE/prisemeshmaker.cpp-208-\t\tmb->RemoveRef();",
        "src/PRISE/prisemeshmaker.cpp-209-\t}",
        "src/PRISE/prisemeshmaker.cpp-210-"
      ],
      "raw_content": [
        "\t\tMemoryBuffer*\tmb = new MemoryBuffer();",
        "\t\tmb->Resize( 0x10000000 );",
        "\t\tgeom->SerializeForCPU( *mb, i );",
        "",
        "\t\tchar\tfilename[1024];",
        "\t\tsprintf( filename, \"%s_%d.prisemesh\", argv[2], i );",
        "",
        "\t\tmb->DumpToFileToCursor( filename );",
        "\t\tmb->RemoveRef();",
        "\t}",
        ""
      ],
      "_frozen": true
    },
    {
      "file_path": "src/RISE/biospecbsdfmaker.cpp",
      "matched_lines": [
        121
      ],
      "context_lines": [
        116,
        117,
        118,
        119,
        120,
        122,
        123,
        124,
        125,
        126
      ],
      "raw_surrounding_git_grep_lines": [
        "src/RISE/biospecbsdfmaker.cpp-116-\tpBuffer->setInt( numPositions );\t\t// Number of emitter positions",
        "src/RISE/biospecbsdfmaker.cpp-117-\tpBuffer->setInt( numPatches );\t\t\t// Number of patches",
        "src/RISE/biospecbsdfmaker.cpp-118-\t",
        "src/RISE/biospecbsdfmaker.cpp-119-\tfor( unsigned int i=0; i<numPositions; i++ ) {",
        "src/RISE/biospecbsdfmaker.cpp-120-\t\tchar buf[256] = {0};",
        "src/RISE/biospecbsdfmaker.cpp:121:\t\tsprintf( buf, \"Performing measurement %.2d of %.2d: \", i+1, numPositions );",
        "src/RISE/biospecbsdfmaker.cpp-122-\t\tStdOutProgress\tprogress( buf );",
        "src/RISE/biospecbsdfmaker.cpp-123-",
        "src/RISE/biospecbsdfmaker.cpp-124-\t\tconst Scalar dEmitterTheta = (PI_OV_TWO/(numPositions-1))*(i);",
        "src/RISE/biospecbsdfmaker.cpp-125-",
        "src/RISE/biospecbsdfmaker.cpp-126-\t\tpDetector->PerformMeasurement("
      ],
      "raw_content": [
        "\tpBuffer->setInt( numPositions );\t\t// Number of emitter positions",
        "\tpBuffer->setInt( numPatches );\t\t\t// Number of patches",
        "\t",
        "\tfor( unsigned int i=0; i<numPositions; i++ ) {",
        "\t\tchar buf[256] = {0};",
        "\t\tsprintf( buf, \"Performing measurement %.2d of %.2d: \", i+1, numPositions );",
        "\t\tStdOutProgress\tprogress( buf );",
        "",
        "\t\tconst Scalar dEmitterTheta = (PI_OV_TWO/(numPositions-1))*(i);",
        "",
        "\t\tpDetector->PerformMeasurement("
      ],
      "_frozen": true
    },
    {
      "file_path": "src/RISE/risempi.cpp",
      "matched_lines": [
        279
      ],
      "context_lines": [
        274,
        275,
        276,
        277,
        278,
        280,
        281,
        282,
        283,
        284
      ],
      "raw_surrounding_git_grep_lines": [
        "src/RISE/risempi.cpp-274-\t// Disable aspects of the logger, so that different processes don't conflict on the same log file",
        "src/RISE/risempi.cpp-275-\tGlobalLogPriv()->RemoveAllPrinters();",
        "src/RISE/risempi.cpp-276-",
        "src/RISE/risempi.cpp-277-\t// Now add back the file printer",
        "src/RISE/risempi.cpp-278-\tchar buf[1024];",
        "src/RISE/risempi.cpp:279:\tsprintf( buf, \"RISELog_Proc%d.txt\", rank );",
        "src/RISE/risempi.cpp-280-\tstd::ofstream*\t\tfs = new std::ofstream( buf );",
        "src/RISE/risempi.cpp-281-\tStreamPrinter*\t\tpB = new StreamPrinter( fs, true );",
        "src/RISE/risempi.cpp-282-\tGlobalLog()->PrintNew( pB, __FILE__, __LINE__, \"file stream printer\" );",
        "src/RISE/risempi.cpp-283-\tGlobalLogPriv()->AddPrinter( pB );",
        "src/RISE/risempi.cpp-284-\tpB->release();"
      ],
      "raw_content": [
        "\t// Disable aspects of the logger, so that different processes don't conflict on the same log file",
        "\tGlobalLogPriv()->RemoveAllPrinters();",
        "",
        "\t// Now add back the file printer",
        "\tchar buf[1024];",
        "\tsprintf( buf, \"RISELog_Proc%d.txt\", rank );",
        "\tstd::ofstream*\t\tfs = new std::ofstream( buf );",
        "\tStreamPrinter*\t\tpB = new StreamPrinter( fs, true );",
        "\tGlobalLog()->PrintNew( pB, __FILE__, __LINE__, \"file stream printer\" );",
        "\tGlobalLogPriv()->AddPrinter( pB );",
        "\tpB->release();"
      ],
      "_frozen": true
    }
  ]
}