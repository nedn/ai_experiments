{
  "metadata": {
    "repository": "https://github.com/aravindkrishnaswamy/RISE",
    "commit": "297d0339a7f7acd1418e322a30a21f44c7dbbb1d",
    "extraction_date": "Tue Sep 30 10:12:44 MDT 2025",
    "total_snippets": 28,
    "description": "Code snippets containing sprintf calls from RISE repository"
  },
  "snippets": [
    {
      "file_path": "extlib/libpng/png.c",
      "matched_lines": [
        641,
        652,
        660
      ],
      "context_lines": [
        631,
        632,
        633,
        634,
        635,
        636,
        637,
        638,
        639,
        640,
        642,
        643,
        644,
        645,
        646,
        647,
        648,
        649,
        650,
        651,
        653,
        654,
        655,
        656,
        657,
        658,
        659,
        661,
        662,
        663,
        664,
        665,
        666,
        667,
        668,
        669,
        670
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/libpng/png.c-631-",
        "extlib/libpng/png.c-632-   if (png_ptr->time_buffer == NULL)",
        "extlib/libpng/png.c-633-   {",
        "extlib/libpng/png.c-634-      png_ptr->time_buffer = (png_charp)png_malloc(png_ptr, (png_uint_32)(29*",
        "extlib/libpng/png.c-635-         png_sizeof(char)));",
        "extlib/libpng/png.c-636-   }",
        "extlib/libpng/png.c-637-",
        "extlib/libpng/png.c-638-#if defined(_WIN32_WCE)",
        "extlib/libpng/png.c-639-   {",
        "extlib/libpng/png.c-640-      wchar_t time_buf[29];",
        "extlib/libpng/png.c:641:      wsprintf(time_buf, TEXT(\"%d %S %d %02d:%02d:%02d +0000\"),",
        "extlib/libpng/png.c-642-          ptime->day % 32, short_months[(ptime->month - 1) % 12],",
        "extlib/libpng/png.c-643-        ptime->year, ptime->hour % 24, ptime->minute % 60,",
        "extlib/libpng/png.c-644-          ptime->second % 61);",
        "extlib/libpng/png.c-645-      WideCharToMultiByte(CP_ACP, 0, time_buf, -1, png_ptr->time_buffer, 29,",
        "extlib/libpng/png.c-646-          NULL, NULL);",
        "extlib/libpng/png.c-647-   }",
        "extlib/libpng/png.c-648-#else",
        "extlib/libpng/png.c-649-#ifdef USE_FAR_KEYWORD",
        "extlib/libpng/png.c-650-   {",
        "extlib/libpng/png.c-651-      char near_time_buf[29];",
        "extlib/libpng/png.c:652:      sprintf(near_time_buf, \"%d %s %d %02d:%02d:%02d +0000\",",
        "extlib/libpng/png.c-653-          ptime->day % 32, short_months[(ptime->month - 1) % 12],",
        "extlib/libpng/png.c-654-          ptime->year, ptime->hour % 24, ptime->minute % 60,",
        "extlib/libpng/png.c-655-          ptime->second % 61);",
        "extlib/libpng/png.c-656-      png_memcpy(png_ptr->time_buffer, near_time_buf,",
        "extlib/libpng/png.c-657-          29*png_sizeof(char));",
        "extlib/libpng/png.c-658-   }",
        "extlib/libpng/png.c-659-#else",
        "extlib/libpng/png.c:660:   sprintf(png_ptr->time_buffer, \"%d %s %d %02d:%02d:%02d +0000\",",
        "extlib/libpng/png.c-661-       ptime->day % 32, short_months[(ptime->month - 1) % 12],",
        "extlib/libpng/png.c-662-       ptime->year, ptime->hour % 24, ptime->minute % 60,",
        "extlib/libpng/png.c-663-       ptime->second % 61);",
        "extlib/libpng/png.c-664-#endif",
        "extlib/libpng/png.c-665-#endif /* _WIN32_WCE */",
        "extlib/libpng/png.c-666-   return ((png_charp)png_ptr->time_buffer);",
        "extlib/libpng/png.c-667-}",
        "extlib/libpng/png.c-668-#endif /* PNG_TIME_RFC1123_SUPPORTED */",
        "extlib/libpng/png.c-669-",
        "extlib/libpng/png.c-670-#if 0"
      ],
      "raw_content": [
        "",
        "   if (png_ptr->time_buffer == NULL)",
        "   {",
        "      png_ptr->time_buffer = (png_charp)png_malloc(png_ptr, (png_uint_32)(29*",
        "         png_sizeof(char)));",
        "   }",
        "",
        "#if defined(_WIN32_WCE)",
        "   {",
        "      wchar_t time_buf[29];",
        "      wsprintf(time_buf, TEXT(\"%d %S %d %02d:%02d:%02d +0000\"),",
        "          ptime->day % 32, short_months[(ptime->month - 1) % 12],",
        "        ptime->year, ptime->hour % 24, ptime->minute % 60,",
        "          ptime->second % 61);",
        "      WideCharToMultiByte(CP_ACP, 0, time_buf, -1, png_ptr->time_buffer, 29,",
        "          NULL, NULL);",
        "   }",
        "#else",
        "#ifdef USE_FAR_KEYWORD",
        "   {",
        "      char near_time_buf[29];",
        "      sprintf(near_time_buf, \"%d %s %d %02d:%02d:%02d +0000\",",
        "          ptime->day % 32, short_months[(ptime->month - 1) % 12],",
        "          ptime->year, ptime->hour % 24, ptime->minute % 60,",
        "          ptime->second % 61);",
        "      png_memcpy(png_ptr->time_buffer, near_time_buf,",
        "          29*png_sizeof(char));",
        "   }",
        "#else",
        "   sprintf(png_ptr->time_buffer, \"%d %s %d %02d:%02d:%02d +0000\",",
        "       ptime->day % 32, short_months[(ptime->month - 1) % 12],",
        "       ptime->year, ptime->hour % 24, ptime->minute % 60,",
        "       ptime->second % 61);",
        "#endif",
        "#endif /* _WIN32_WCE */",
        "   return ((png_charp)png_ptr->time_buffer);",
        "}",
        "#endif /* PNG_TIME_RFC1123_SUPPORTED */",
        "",
        "#if 0"
      ]
    },
    {
      "file_path": "extlib/libpng/pnggccrd.c",
      "matched_lines": [
        5100,
        5102,
        5110,
        5118,
        5126,
        5134
      ],
      "context_lines": [
        5090,
        5091,
        5092,
        5093,
        5094,
        5095,
        5096,
        5097,
        5098,
        5099,
        5101,
        5103,
        5104,
        5105,
        5106,
        5107,
        5108,
        5109,
        5111,
        5112,
        5113,
        5114,
        5115,
        5116,
        5117,
        5119,
        5120,
        5121,
        5122,
        5123,
        5124,
        5125,
        5127,
        5128,
        5129,
        5130,
        5131,
        5132,
        5133,
        5135,
        5136,
        5137,
        5138,
        5139,
        5140,
        5141,
        5142,
        5143,
        5144
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/libpng/pnggccrd.c-5090-       png_warning(png_ptr, \"asm_flags may not have been initialized\");",
        "extlib/libpng/pnggccrd.c-5091-#endif",
        "extlib/libpng/pnggccrd.c-5092-       png_mmx_support();",
        "extlib/libpng/pnggccrd.c-5093-   }",
        "extlib/libpng/pnggccrd.c-5094-#endif /* PNG_ASSEMBLER_CODE_SUPPORTED */",
        "extlib/libpng/pnggccrd.c-5095-",
        "extlib/libpng/pnggccrd.c-5096-#ifdef PNG_DEBUG",
        "extlib/libpng/pnggccrd.c-5097-   png_debug(1, \"in png_read_filter_row (pnggccrd.c)\\n\");",
        "extlib/libpng/pnggccrd.c-5098-   switch (filter)",
        "extlib/libpng/pnggccrd.c-5099-   {",
        "extlib/libpng/pnggccrd.c:5100:      case 0: sprintf(filnm, \"none\");",
        "extlib/libpng/pnggccrd.c-5101-         break;",
        "extlib/libpng/pnggccrd.c:5102:      case 1: sprintf(filnm, \"sub-%s\",",
        "extlib/libpng/pnggccrd.c-5103-#if defined(PNG_ASSEMBLER_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)",
        "extlib/libpng/pnggccrd.c-5104-#if !defined(PNG_1_0_X)",
        "extlib/libpng/pnggccrd.c-5105-        (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_SUB)? \"MMX\" : ",
        "extlib/libpng/pnggccrd.c-5106-#endif",
        "extlib/libpng/pnggccrd.c-5107-#endif",
        "extlib/libpng/pnggccrd.c-5108-\"x86\");",
        "extlib/libpng/pnggccrd.c-5109-         break;",
        "extlib/libpng/pnggccrd.c:5110:      case 2: sprintf(filnm, \"up-%s\",",
        "extlib/libpng/pnggccrd.c-5111-#ifdef PNG_ASSEMBLER_CODE_SUPPORTED",
        "extlib/libpng/pnggccrd.c-5112-#if !defined(PNG_1_0_X)",
        "extlib/libpng/pnggccrd.c-5113-        (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_UP)? \"MMX\" :",
        "extlib/libpng/pnggccrd.c-5114-#endif",
        "extlib/libpng/pnggccrd.c-5115-#endif",
        "extlib/libpng/pnggccrd.c-5116- \"x86\");",
        "extlib/libpng/pnggccrd.c-5117-         break;",
        "extlib/libpng/pnggccrd.c:5118:      case 3: sprintf(filnm, \"avg-%s\",",
        "extlib/libpng/pnggccrd.c-5119-#if defined(PNG_ASSEMBLER_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)",
        "extlib/libpng/pnggccrd.c-5120-#if !defined(PNG_1_0_X)",
        "extlib/libpng/pnggccrd.c-5121-        (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_AVG)? \"MMX\" :",
        "extlib/libpng/pnggccrd.c-5122-#endif",
        "extlib/libpng/pnggccrd.c-5123-#endif",
        "extlib/libpng/pnggccrd.c-5124- \"x86\");",
        "extlib/libpng/pnggccrd.c-5125-         break;",
        "extlib/libpng/pnggccrd.c:5126:      case 4: sprintf(filnm, \"Paeth-%s\",",
        "extlib/libpng/pnggccrd.c-5127-#if defined(PNG_ASSEMBLER_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)",
        "extlib/libpng/pnggccrd.c-5128-#if !defined(PNG_1_0_X)",
        "extlib/libpng/pnggccrd.c-5129-        (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_PAETH)? \"MMX\":",
        "extlib/libpng/pnggccrd.c-5130-#endif",
        "extlib/libpng/pnggccrd.c-5131-#endif",
        "extlib/libpng/pnggccrd.c-5132-\"x86\");",
        "extlib/libpng/pnggccrd.c-5133-         break;",
        "extlib/libpng/pnggccrd.c:5134:      default: sprintf(filnm, \"unknw\");",
        "extlib/libpng/pnggccrd.c-5135-         break;",
        "extlib/libpng/pnggccrd.c-5136-   }",
        "extlib/libpng/pnggccrd.c-5137-   png_debug2(0, \"row_number=%5ld, %5s, \", png_ptr->row_number, filnm);",
        "extlib/libpng/pnggccrd.c-5138-   png_debug1(0, \"row=0x%08lx, \", (unsigned long)row);",
        "extlib/libpng/pnggccrd.c-5139-   png_debug2(0, \"pixdepth=%2d, bytes=%d, \", (int)row_info->pixel_depth,",
        "extlib/libpng/pnggccrd.c-5140-      (int)((row_info->pixel_depth + 7) >> 3));",
        "extlib/libpng/pnggccrd.c-5141-   png_debug1(0,\"rowbytes=%8ld\\n\", row_info->rowbytes);",
        "extlib/libpng/pnggccrd.c-5142-#endif /* PNG_DEBUG */",
        "extlib/libpng/pnggccrd.c-5143-",
        "extlib/libpng/pnggccrd.c-5144-   switch (filter)"
      ],
      "raw_content": [
        "       png_warning(png_ptr, \"asm_flags may not have been initialized\");",
        "#endif",
        "       png_mmx_support();",
        "   }",
        "#endif /* PNG_ASSEMBLER_CODE_SUPPORTED */",
        "",
        "#ifdef PNG_DEBUG",
        "   png_debug(1, \"in png_read_filter_row (pnggccrd.c)\\n\");",
        "   switch (filter)",
        "   {",
        "      case 0: sprintf(filnm, \"none\");",
        "         break;",
        "      case 1: sprintf(filnm, \"sub-%s\",",
        "#if defined(PNG_ASSEMBLER_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)",
        "#if !defined(PNG_1_0_X)",
        "        (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_SUB)? \"MMX\" : ",
        "#endif",
        "#endif",
        "\"x86\");",
        "         break;",
        "      case 2: sprintf(filnm, \"up-%s\",",
        "#ifdef PNG_ASSEMBLER_CODE_SUPPORTED",
        "#if !defined(PNG_1_0_X)",
        "        (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_UP)? \"MMX\" :",
        "#endif",
        "#endif",
        " \"x86\");",
        "         break;",
        "      case 3: sprintf(filnm, \"avg-%s\",",
        "#if defined(PNG_ASSEMBLER_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)",
        "#if !defined(PNG_1_0_X)",
        "        (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_AVG)? \"MMX\" :",
        "#endif",
        "#endif",
        " \"x86\");",
        "         break;",
        "      case 4: sprintf(filnm, \"Paeth-%s\",",
        "#if defined(PNG_ASSEMBLER_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)",
        "#if !defined(PNG_1_0_X)",
        "        (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_PAETH)? \"MMX\":",
        "#endif",
        "#endif",
        "\"x86\");",
        "         break;",
        "      default: sprintf(filnm, \"unknw\");",
        "         break;",
        "   }",
        "   png_debug2(0, \"row_number=%5ld, %5s, \", png_ptr->row_number, filnm);",
        "   png_debug1(0, \"row=0x%08lx, \", (unsigned long)row);",
        "   png_debug2(0, \"pixdepth=%2d, bytes=%d, \", (int)row_info->pixel_depth,",
        "      (int)((row_info->pixel_depth + 7) >> 3));",
        "   png_debug1(0,\"rowbytes=%8ld\\n\", row_info->rowbytes);",
        "#endif /* PNG_DEBUG */",
        "",
        "   switch (filter)"
      ]
    },
    {
      "file_path": "extlib/libpng/pngread.c",
      "matched_lines": [
        118,
        122
      ],
      "context_lines": [
        108,
        109,
        110,
        111,
        112,
        113,
        114,
        115,
        116,
        117,
        119,
        120,
        121,
        123,
        124,
        125,
        126,
        127,
        128,
        129,
        130,
        131,
        132
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/libpng/pngread.c-108-      * only check the first digit.",
        "extlib/libpng/pngread.c-109-      */",
        "extlib/libpng/pngread.c-110-     if (user_png_ver == NULL || user_png_ver[0] != png_libpng_ver[0] ||",
        "extlib/libpng/pngread.c-111-         (user_png_ver[0] == '1' && user_png_ver[2] != png_libpng_ver[2]) ||",
        "extlib/libpng/pngread.c-112-         (user_png_ver[0] == '0' && user_png_ver[2] < '9'))",
        "extlib/libpng/pngread.c-113-     {",
        "extlib/libpng/pngread.c-114-#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)",
        "extlib/libpng/pngread.c-115-        char msg[80];",
        "extlib/libpng/pngread.c-116-        if (user_png_ver)",
        "extlib/libpng/pngread.c-117-        {",
        "extlib/libpng/pngread.c:118:          sprintf(msg, \"Application was compiled with png.h from libpng-%.20s\",",
        "extlib/libpng/pngread.c-119-             user_png_ver);",
        "extlib/libpng/pngread.c-120-          png_warning(png_ptr, msg);",
        "extlib/libpng/pngread.c-121-        }",
        "extlib/libpng/pngread.c:122:        sprintf(msg, \"Application  is  running with png.c from libpng-%.20s\",",
        "extlib/libpng/pngread.c-123-           png_libpng_ver);",
        "extlib/libpng/pngread.c-124-        png_warning(png_ptr, msg);",
        "extlib/libpng/pngread.c-125-#endif",
        "extlib/libpng/pngread.c-126-#ifdef PNG_ERROR_NUMBERS_SUPPORTED",
        "extlib/libpng/pngread.c-127-        png_ptr->flags=0;",
        "extlib/libpng/pngread.c-128-#endif",
        "extlib/libpng/pngread.c-129-        png_error(png_ptr,",
        "extlib/libpng/pngread.c-130-           \"Incompatible libpng version in application and library\");",
        "extlib/libpng/pngread.c-131-     }",
        "extlib/libpng/pngread.c-132-   }"
      ],
      "raw_content": [
        "      * only check the first digit.",
        "      */",
        "     if (user_png_ver == NULL || user_png_ver[0] != png_libpng_ver[0] ||",
        "         (user_png_ver[0] == '1' && user_png_ver[2] != png_libpng_ver[2]) ||",
        "         (user_png_ver[0] == '0' && user_png_ver[2] < '9'))",
        "     {",
        "#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)",
        "        char msg[80];",
        "        if (user_png_ver)",
        "        {",
        "          sprintf(msg, \"Application was compiled with png.h from libpng-%.20s\",",
        "             user_png_ver);",
        "          png_warning(png_ptr, msg);",
        "        }",
        "        sprintf(msg, \"Application  is  running with png.c from libpng-%.20s\",",
        "           png_libpng_ver);",
        "        png_warning(png_ptr, msg);",
        "#endif",
        "#ifdef PNG_ERROR_NUMBERS_SUPPORTED",
        "        png_ptr->flags=0;",
        "#endif",
        "        png_error(png_ptr,",
        "           \"Incompatible libpng version in application and library\");",
        "     }",
        "   }"
      ]
    },
    {
      "file_path": "extlib/libpng/pngread.c",
      "matched_lines": [
        198,
        202
      ],
      "context_lines": [
        188,
        189,
        190,
        191,
        192,
        193,
        194,
        195,
        196,
        197,
        199,
        200,
        201,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        210,
        211,
        212
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/libpng/pngread.c-188-{",
        "extlib/libpng/pngread.c-189-   /* We only come here via pre-1.0.12-compiled applications */",
        "extlib/libpng/pngread.c-190-#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)",
        "extlib/libpng/pngread.c-191-   if(png_sizeof(png_struct) > png_struct_size || ",
        "extlib/libpng/pngread.c-192-      png_sizeof(png_info) > png_info_size)",
        "extlib/libpng/pngread.c-193-   {",
        "extlib/libpng/pngread.c-194-      char msg[80];",
        "extlib/libpng/pngread.c-195-      png_ptr->warning_fn=NULL;",
        "extlib/libpng/pngread.c-196-      if (user_png_ver)",
        "extlib/libpng/pngread.c-197-      {",
        "extlib/libpng/pngread.c:198:        sprintf(msg, \"Application was compiled with png.h from libpng-%.20s\",",
        "extlib/libpng/pngread.c-199-           user_png_ver);",
        "extlib/libpng/pngread.c-200-        png_warning(png_ptr, msg);",
        "extlib/libpng/pngread.c-201-      }",
        "extlib/libpng/pngread.c:202:      sprintf(msg, \"Application  is  running with png.c from libpng-%.20s\",",
        "extlib/libpng/pngread.c-203-         png_libpng_ver);",
        "extlib/libpng/pngread.c-204-      png_warning(png_ptr, msg);",
        "extlib/libpng/pngread.c-205-   }",
        "extlib/libpng/pngread.c-206-#endif",
        "extlib/libpng/pngread.c-207-   if(png_sizeof(png_struct) > png_struct_size)",
        "extlib/libpng/pngread.c-208-     {",
        "extlib/libpng/pngread.c-209-       png_ptr->error_fn=NULL;",
        "extlib/libpng/pngread.c-210-#ifdef PNG_ERROR_NUMBERS_SUPPORTED",
        "extlib/libpng/pngread.c-211-       png_ptr->flags=0;",
        "extlib/libpng/pngread.c-212-#endif"
      ],
      "raw_content": [
        "{",
        "   /* We only come here via pre-1.0.12-compiled applications */",
        "#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)",
        "   if(png_sizeof(png_struct) > png_struct_size || ",
        "      png_sizeof(png_info) > png_info_size)",
        "   {",
        "      char msg[80];",
        "      png_ptr->warning_fn=NULL;",
        "      if (user_png_ver)",
        "      {",
        "        sprintf(msg, \"Application was compiled with png.h from libpng-%.20s\",",
        "           user_png_ver);",
        "        png_warning(png_ptr, msg);",
        "      }",
        "      sprintf(msg, \"Application  is  running with png.c from libpng-%.20s\",",
        "         png_libpng_ver);",
        "      png_warning(png_ptr, msg);",
        "   }",
        "#endif",
        "   if(png_sizeof(png_struct) > png_struct_size)",
        "     {",
        "       png_ptr->error_fn=NULL;",
        "#ifdef PNG_ERROR_NUMBERS_SUPPORTED",
        "       png_ptr->flags=0;",
        "#endif"
      ]
    },
    {
      "file_path": "extlib/libpng/pngrtran.c",
      "matched_lines": [
        1182
      ],
      "context_lines": [
        1172,
        1173,
        1174,
        1175,
        1176,
        1177,
        1178,
        1179,
        1180,
        1181,
        1183,
        1184,
        1185,
        1186,
        1187,
        1188,
        1189,
        1190,
        1191,
        1192
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/libpng/pngrtran.c-1172-void /* PRIVATE */",
        "extlib/libpng/pngrtran.c-1173-png_do_read_transformations(png_structp png_ptr)",
        "extlib/libpng/pngrtran.c-1174-{",
        "extlib/libpng/pngrtran.c-1175-   png_debug(1, \"in png_do_read_transformations\\n\");",
        "extlib/libpng/pngrtran.c-1176-#if !defined(PNG_USELESS_TESTS_SUPPORTED)",
        "extlib/libpng/pngrtran.c-1177-   if (png_ptr->row_buf == NULL)",
        "extlib/libpng/pngrtran.c-1178-   {",
        "extlib/libpng/pngrtran.c-1179-#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)",
        "extlib/libpng/pngrtran.c-1180-      char msg[50];",
        "extlib/libpng/pngrtran.c-1181-",
        "extlib/libpng/pngrtran.c:1182:      sprintf(msg, \"NULL row buffer for row %ld, pass %d\", png_ptr->row_number,",
        "extlib/libpng/pngrtran.c-1183-         png_ptr->pass);",
        "extlib/libpng/pngrtran.c-1184-      png_error(png_ptr, msg);",
        "extlib/libpng/pngrtran.c-1185-#else",
        "extlib/libpng/pngrtran.c-1186-      png_error(png_ptr, \"NULL row buffer\");",
        "extlib/libpng/pngrtran.c-1187-#endif",
        "extlib/libpng/pngrtran.c-1188-   }",
        "extlib/libpng/pngrtran.c-1189-#endif",
        "extlib/libpng/pngrtran.c-1190-",
        "extlib/libpng/pngrtran.c-1191-#if defined(PNG_READ_EXPAND_SUPPORTED)",
        "extlib/libpng/pngrtran.c-1192-   if (png_ptr->transformations & PNG_EXPAND)"
      ],
      "raw_content": [
        "void /* PRIVATE */",
        "png_do_read_transformations(png_structp png_ptr)",
        "{",
        "   png_debug(1, \"in png_do_read_transformations\\n\");",
        "#if !defined(PNG_USELESS_TESTS_SUPPORTED)",
        "   if (png_ptr->row_buf == NULL)",
        "   {",
        "#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)",
        "      char msg[50];",
        "",
        "      sprintf(msg, \"NULL row buffer for row %ld, pass %d\", png_ptr->row_number,",
        "         png_ptr->pass);",
        "      png_error(png_ptr, msg);",
        "#else",
        "      png_error(png_ptr, \"NULL row buffer\");",
        "#endif",
        "   }",
        "#endif",
        "",
        "#if defined(PNG_READ_EXPAND_SUPPORTED)",
        "   if (png_ptr->transformations & PNG_EXPAND)"
      ]
    },
    {
      "file_path": "extlib/libpng/pngrutil.c",
      "matched_lines": [
        281,
        284,
        287
      ],
      "context_lines": [
        271,
        272,
        273,
        274,
        275,
        276,
        277,
        278,
        279,
        280,
        282,
        283,
        285,
        286,
        288,
        289,
        290,
        291,
        292,
        293,
        294,
        295,
        296,
        297
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/libpng/pngrutil.c-271-               png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;",
        "extlib/libpng/pngrutil.c-272-            }",
        "extlib/libpng/pngrutil.c-273-         }",
        "extlib/libpng/pngrutil.c-274-      }",
        "extlib/libpng/pngrutil.c-275-      if (ret != Z_STREAM_END)",
        "extlib/libpng/pngrutil.c-276-      {",
        "extlib/libpng/pngrutil.c-277-#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)",
        "extlib/libpng/pngrutil.c-278-         char umsg[50];",
        "extlib/libpng/pngrutil.c-279-",
        "extlib/libpng/pngrutil.c-280-         if (ret == Z_BUF_ERROR)",
        "extlib/libpng/pngrutil.c:281:            sprintf(umsg,\"Buffer error in compressed datastream in %s chunk\",",
        "extlib/libpng/pngrutil.c-282-                png_ptr->chunk_name);",
        "extlib/libpng/pngrutil.c-283-         else if (ret == Z_DATA_ERROR)",
        "extlib/libpng/pngrutil.c:284:            sprintf(umsg,\"Data error in compressed datastream in %s chunk\",",
        "extlib/libpng/pngrutil.c-285-                png_ptr->chunk_name);",
        "extlib/libpng/pngrutil.c-286-         else",
        "extlib/libpng/pngrutil.c:287:            sprintf(umsg,\"Incomplete compressed datastream in %s chunk\",",
        "extlib/libpng/pngrutil.c-288-                png_ptr->chunk_name);",
        "extlib/libpng/pngrutil.c-289-         png_warning(png_ptr, umsg);",
        "extlib/libpng/pngrutil.c-290-#else",
        "extlib/libpng/pngrutil.c-291-         png_warning(png_ptr,",
        "extlib/libpng/pngrutil.c-292-            \"Incomplete compressed datastream in chunk other than IDAT\");",
        "extlib/libpng/pngrutil.c-293-#endif",
        "extlib/libpng/pngrutil.c-294-         text_size=prefix_size;",
        "extlib/libpng/pngrutil.c-295-         if (text ==  NULL)",
        "extlib/libpng/pngrutil.c-296-         {",
        "extlib/libpng/pngrutil.c-297-            text = (png_charp)png_malloc_warn(png_ptr, text_size+1);"
      ],
      "raw_content": [
        "               png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;",
        "            }",
        "         }",
        "      }",
        "      if (ret != Z_STREAM_END)",
        "      {",
        "#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)",
        "         char umsg[50];",
        "",
        "         if (ret == Z_BUF_ERROR)",
        "            sprintf(umsg,\"Buffer error in compressed datastream in %s chunk\",",
        "                png_ptr->chunk_name);",
        "         else if (ret == Z_DATA_ERROR)",
        "            sprintf(umsg,\"Data error in compressed datastream in %s chunk\",",
        "                png_ptr->chunk_name);",
        "         else",
        "            sprintf(umsg,\"Incomplete compressed datastream in %s chunk\",",
        "                png_ptr->chunk_name);",
        "         png_warning(png_ptr, umsg);",
        "#else",
        "         png_warning(png_ptr,",
        "            \"Incomplete compressed datastream in chunk other than IDAT\");",
        "#endif",
        "         text_size=prefix_size;",
        "         if (text ==  NULL)",
        "         {",
        "            text = (png_charp)png_malloc_warn(png_ptr, text_size+1);"
      ]
    },
    {
      "file_path": "extlib/libpng/pngrutil.c",
      "matched_lines": [
        320
      ],
      "context_lines": [
        310,
        311,
        312,
        313,
        314,
        315,
        316,
        317,
        318,
        319,
        321,
        322,
        323,
        324,
        325,
        326,
        327,
        328,
        329,
        330
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/libpng/pngrutil.c-310-",
        "extlib/libpng/pngrutil.c-311-      png_free(png_ptr, chunkdata);",
        "extlib/libpng/pngrutil.c-312-      chunkdata = text;",
        "extlib/libpng/pngrutil.c-313-      *newlength=text_size;",
        "extlib/libpng/pngrutil.c-314-   }",
        "extlib/libpng/pngrutil.c-315-   else /* if (comp_type != PNG_COMPRESSION_TYPE_BASE) */",
        "extlib/libpng/pngrutil.c-316-   {",
        "extlib/libpng/pngrutil.c-317-#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)",
        "extlib/libpng/pngrutil.c-318-      char umsg[50];",
        "extlib/libpng/pngrutil.c-319-",
        "extlib/libpng/pngrutil.c:320:      sprintf(umsg, \"Unknown zTXt compression type %d\", comp_type);",
        "extlib/libpng/pngrutil.c-321-      png_warning(png_ptr, umsg);",
        "extlib/libpng/pngrutil.c-322-#else",
        "extlib/libpng/pngrutil.c-323-      png_warning(png_ptr, \"Unknown zTXt compression type\");",
        "extlib/libpng/pngrutil.c-324-#endif",
        "extlib/libpng/pngrutil.c-325-",
        "extlib/libpng/pngrutil.c-326-      *(chunkdata + prefix_size) = 0x00;",
        "extlib/libpng/pngrutil.c-327-      *newlength=prefix_size;",
        "extlib/libpng/pngrutil.c-328-   }",
        "extlib/libpng/pngrutil.c-329-",
        "extlib/libpng/pngrutil.c-330-   return chunkdata;"
      ],
      "raw_content": [
        "",
        "      png_free(png_ptr, chunkdata);",
        "      chunkdata = text;",
        "      *newlength=text_size;",
        "   }",
        "   else /* if (comp_type != PNG_COMPRESSION_TYPE_BASE) */",
        "   {",
        "#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)",
        "      char umsg[50];",
        "",
        "      sprintf(umsg, \"Unknown zTXt compression type %d\", comp_type);",
        "      png_warning(png_ptr, umsg);",
        "#else",
        "      png_warning(png_ptr, \"Unknown zTXt compression type\");",
        "#endif",
        "",
        "      *(chunkdata + prefix_size) = 0x00;",
        "      *newlength=prefix_size;",
        "   }",
        "",
        "   return chunkdata;"
      ]
    },
    {
      "file_path": "extlib/libpng/pngvcrd.c",
      "matched_lines": [
        3695,
        3698,
        3701,
        3704,
        3707,
        3711,
        3713,
        3715,
        3717,
        3720
      ],
      "context_lines": [
        3685,
        3686,
        3687,
        3688,
        3689,
        3690,
        3691,
        3692,
        3693,
        3694,
        3696,
        3697,
        3699,
        3700,
        3702,
        3703,
        3705,
        3706,
        3708,
        3709,
        3710,
        3712,
        3714,
        3716,
        3718,
        3719,
        3721,
        3722,
        3723,
        3724,
        3725,
        3726,
        3727,
        3728,
        3729,
        3730
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/libpng/pngvcrd.c-3685-       /* this should have happened in png_init_mmx_flags() already */",
        "extlib/libpng/pngvcrd.c-3686-       png_warning(png_ptr, \"asm_flags may not have been initialized\");",
        "extlib/libpng/pngvcrd.c-3687-#endif",
        "extlib/libpng/pngvcrd.c-3688-       png_mmx_support();",
        "extlib/libpng/pngvcrd.c-3689-   }",
        "extlib/libpng/pngvcrd.c-3690-",
        "extlib/libpng/pngvcrd.c-3691-#ifdef PNG_DEBUG",
        "extlib/libpng/pngvcrd.c-3692-   png_debug(1, \"in png_read_filter_row\\n\");",
        "extlib/libpng/pngvcrd.c-3693-   switch (filter)",
        "extlib/libpng/pngvcrd.c-3694-   {",
        "extlib/libpng/pngvcrd.c:3695:      case 0: sprintf(filnm, \"none\");",
        "extlib/libpng/pngvcrd.c-3696-         break;",
        "extlib/libpng/pngvcrd.c-3697-#if !defined(PNG_1_0_X)",
        "extlib/libpng/pngvcrd.c:3698:      case 1: sprintf(filnm, \"sub-%s\",",
        "extlib/libpng/pngvcrd.c-3699-        (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_SUB)? \"MMX\" : \"x86\");",
        "extlib/libpng/pngvcrd.c-3700-         break;",
        "extlib/libpng/pngvcrd.c:3701:      case 2: sprintf(filnm, \"up-%s\",",
        "extlib/libpng/pngvcrd.c-3702-        (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_UP)? \"MMX\" : \"x86\");",
        "extlib/libpng/pngvcrd.c-3703-         break;",
        "extlib/libpng/pngvcrd.c:3704:      case 3: sprintf(filnm, \"avg-%s\",",
        "extlib/libpng/pngvcrd.c-3705-        (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_AVG)? \"MMX\" : \"x86\");",
        "extlib/libpng/pngvcrd.c-3706-         break;",
        "extlib/libpng/pngvcrd.c:3707:      case 4: sprintf(filnm, \"Paeth-%s\",",
        "extlib/libpng/pngvcrd.c-3708-        (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_PAETH)? \"MMX\":\"x86\");",
        "extlib/libpng/pngvcrd.c-3709-         break;",
        "extlib/libpng/pngvcrd.c-3710-#else",
        "extlib/libpng/pngvcrd.c:3711:      case 1: sprintf(filnm, \"sub\");",
        "extlib/libpng/pngvcrd.c-3712-         break;",
        "extlib/libpng/pngvcrd.c:3713:      case 2: sprintf(filnm, \"up\");",
        "extlib/libpng/pngvcrd.c-3714-         break;",
        "extlib/libpng/pngvcrd.c:3715:      case 3: sprintf(filnm, \"avg\");",
        "extlib/libpng/pngvcrd.c-3716-         break;",
        "extlib/libpng/pngvcrd.c:3717:      case 4: sprintf(filnm, \"Paeth\");",
        "extlib/libpng/pngvcrd.c-3718-         break;",
        "extlib/libpng/pngvcrd.c-3719-#endif",
        "extlib/libpng/pngvcrd.c:3720:      default: sprintf(filnm, \"unknw\");",
        "extlib/libpng/pngvcrd.c-3721-         break;",
        "extlib/libpng/pngvcrd.c-3722-   }",
        "extlib/libpng/pngvcrd.c-3723-   png_debug2(0,\"row=%5d, %s, \", png_ptr->row_number, filnm);",
        "extlib/libpng/pngvcrd.c-3724-   png_debug2(0, \"pd=%2d, b=%d, \", (int)row_info->pixel_depth,",
        "extlib/libpng/pngvcrd.c-3725-      (int)((row_info->pixel_depth + 7) >> 3));",
        "extlib/libpng/pngvcrd.c-3726-   png_debug1(0,\"len=%8d, \", row_info->rowbytes);",
        "extlib/libpng/pngvcrd.c-3727-#endif /* PNG_DEBUG */",
        "extlib/libpng/pngvcrd.c-3728-",
        "extlib/libpng/pngvcrd.c-3729-   switch (filter)",
        "extlib/libpng/pngvcrd.c-3730-   {"
      ],
      "raw_content": [
        "       /* this should have happened in png_init_mmx_flags() already */",
        "       png_warning(png_ptr, \"asm_flags may not have been initialized\");",
        "#endif",
        "       png_mmx_support();",
        "   }",
        "",
        "#ifdef PNG_DEBUG",
        "   png_debug(1, \"in png_read_filter_row\\n\");",
        "   switch (filter)",
        "   {",
        "      case 0: sprintf(filnm, \"none\");",
        "         break;",
        "#if !defined(PNG_1_0_X)",
        "      case 1: sprintf(filnm, \"sub-%s\",",
        "        (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_SUB)? \"MMX\" : \"x86\");",
        "         break;",
        "      case 2: sprintf(filnm, \"up-%s\",",
        "        (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_UP)? \"MMX\" : \"x86\");",
        "         break;",
        "      case 3: sprintf(filnm, \"avg-%s\",",
        "        (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_AVG)? \"MMX\" : \"x86\");",
        "         break;",
        "      case 4: sprintf(filnm, \"Paeth-%s\",",
        "        (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_PAETH)? \"MMX\":\"x86\");",
        "         break;",
        "#else",
        "      case 1: sprintf(filnm, \"sub\");",
        "         break;",
        "      case 2: sprintf(filnm, \"up\");",
        "         break;",
        "      case 3: sprintf(filnm, \"avg\");",
        "         break;",
        "      case 4: sprintf(filnm, \"Paeth\");",
        "         break;",
        "#endif",
        "      default: sprintf(filnm, \"unknw\");",
        "         break;",
        "   }",
        "   png_debug2(0,\"row=%5d, %s, \", png_ptr->row_number, filnm);",
        "   png_debug2(0, \"pd=%2d, b=%d, \", (int)row_info->pixel_depth,",
        "      (int)((row_info->pixel_depth + 7) >> 3));",
        "   png_debug1(0,\"len=%8d, \", row_info->rowbytes);",
        "#endif /* PNG_DEBUG */",
        "",
        "   switch (filter)",
        "   {"
      ]
    },
    {
      "file_path": "extlib/libpng/pngwrite.c",
      "matched_lines": [
        511,
        515
      ],
      "context_lines": [
        501,
        502,
        503,
        504,
        505,
        506,
        507,
        508,
        509,
        510,
        512,
        513,
        514,
        516,
        517,
        518,
        519,
        520,
        521,
        522,
        523,
        524,
        525
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/libpng/pngwrite.c-501-      * only check the first digit.",
        "extlib/libpng/pngwrite.c-502-      */",
        "extlib/libpng/pngwrite.c-503-     if (user_png_ver == NULL || user_png_ver[0] != png_libpng_ver[0] ||",
        "extlib/libpng/pngwrite.c-504-         (user_png_ver[0] == '1' && user_png_ver[2] != png_libpng_ver[2]) ||",
        "extlib/libpng/pngwrite.c-505-         (user_png_ver[0] == '0' && user_png_ver[2] < '9'))",
        "extlib/libpng/pngwrite.c-506-     {",
        "extlib/libpng/pngwrite.c-507-#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)",
        "extlib/libpng/pngwrite.c-508-        char msg[80];",
        "extlib/libpng/pngwrite.c-509-        if (user_png_ver)",
        "extlib/libpng/pngwrite.c-510-        {",
        "extlib/libpng/pngwrite.c:511:          sprintf(msg, \"Application was compiled with png.h from libpng-%.20s\",",
        "extlib/libpng/pngwrite.c-512-             user_png_ver);",
        "extlib/libpng/pngwrite.c-513-          png_warning(png_ptr, msg);",
        "extlib/libpng/pngwrite.c-514-        }",
        "extlib/libpng/pngwrite.c:515:        sprintf(msg, \"Application  is  running with png.c from libpng-%.20s\",",
        "extlib/libpng/pngwrite.c-516-           png_libpng_ver);",
        "extlib/libpng/pngwrite.c-517-        png_warning(png_ptr, msg);",
        "extlib/libpng/pngwrite.c-518-#endif",
        "extlib/libpng/pngwrite.c-519-#ifdef PNG_ERROR_NUMBERS_SUPPORTED",
        "extlib/libpng/pngwrite.c-520-        png_ptr->flags=0;",
        "extlib/libpng/pngwrite.c-521-#endif",
        "extlib/libpng/pngwrite.c-522-        png_error(png_ptr,",
        "extlib/libpng/pngwrite.c-523-           \"Incompatible libpng version in application and library\");",
        "extlib/libpng/pngwrite.c-524-     }",
        "extlib/libpng/pngwrite.c-525-   }"
      ],
      "raw_content": [
        "      * only check the first digit.",
        "      */",
        "     if (user_png_ver == NULL || user_png_ver[0] != png_libpng_ver[0] ||",
        "         (user_png_ver[0] == '1' && user_png_ver[2] != png_libpng_ver[2]) ||",
        "         (user_png_ver[0] == '0' && user_png_ver[2] < '9'))",
        "     {",
        "#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)",
        "        char msg[80];",
        "        if (user_png_ver)",
        "        {",
        "          sprintf(msg, \"Application was compiled with png.h from libpng-%.20s\",",
        "             user_png_ver);",
        "          png_warning(png_ptr, msg);",
        "        }",
        "        sprintf(msg, \"Application  is  running with png.c from libpng-%.20s\",",
        "           png_libpng_ver);",
        "        png_warning(png_ptr, msg);",
        "#endif",
        "#ifdef PNG_ERROR_NUMBERS_SUPPORTED",
        "        png_ptr->flags=0;",
        "#endif",
        "        png_error(png_ptr,",
        "           \"Incompatible libpng version in application and library\");",
        "     }",
        "   }"
      ]
    },
    {
      "file_path": "extlib/libpng/pngwrite.c",
      "matched_lines": [
        578,
        582
      ],
      "context_lines": [
        568,
        569,
        570,
        571,
        572,
        573,
        574,
        575,
        576,
        577,
        579,
        580,
        581,
        583,
        584,
        585,
        586,
        587,
        588,
        589,
        590,
        591,
        592
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/libpng/pngwrite.c-568-{",
        "extlib/libpng/pngwrite.c-569-   /* We only come here via pre-1.0.12-compiled applications */",
        "extlib/libpng/pngwrite.c-570-#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)",
        "extlib/libpng/pngwrite.c-571-   if(png_sizeof(png_struct) > png_struct_size ||",
        "extlib/libpng/pngwrite.c-572-      png_sizeof(png_info) > png_info_size)",
        "extlib/libpng/pngwrite.c-573-   {",
        "extlib/libpng/pngwrite.c-574-      char msg[80];",
        "extlib/libpng/pngwrite.c-575-      png_ptr->warning_fn=NULL;",
        "extlib/libpng/pngwrite.c-576-      if (user_png_ver)",
        "extlib/libpng/pngwrite.c-577-      {",
        "extlib/libpng/pngwrite.c:578:        sprintf(msg, \"Application was compiled with png.h from libpng-%.20s\",",
        "extlib/libpng/pngwrite.c-579-           user_png_ver);",
        "extlib/libpng/pngwrite.c-580-        png_warning(png_ptr, msg);",
        "extlib/libpng/pngwrite.c-581-      }",
        "extlib/libpng/pngwrite.c:582:      sprintf(msg, \"Application  is  running with png.c from libpng-%.20s\",",
        "extlib/libpng/pngwrite.c-583-         png_libpng_ver);",
        "extlib/libpng/pngwrite.c-584-      png_warning(png_ptr, msg);",
        "extlib/libpng/pngwrite.c-585-   }",
        "extlib/libpng/pngwrite.c-586-#endif",
        "extlib/libpng/pngwrite.c-587-   if(png_sizeof(png_struct) > png_struct_size)",
        "extlib/libpng/pngwrite.c-588-     {",
        "extlib/libpng/pngwrite.c-589-       png_ptr->error_fn=NULL;",
        "extlib/libpng/pngwrite.c-590-#ifdef PNG_ERROR_NUMBERS_SUPPORTED",
        "extlib/libpng/pngwrite.c-591-       png_ptr->flags=0;",
        "extlib/libpng/pngwrite.c-592-#endif"
      ],
      "raw_content": [
        "{",
        "   /* We only come here via pre-1.0.12-compiled applications */",
        "#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)",
        "   if(png_sizeof(png_struct) > png_struct_size ||",
        "      png_sizeof(png_info) > png_info_size)",
        "   {",
        "      char msg[80];",
        "      png_ptr->warning_fn=NULL;",
        "      if (user_png_ver)",
        "      {",
        "        sprintf(msg, \"Application was compiled with png.h from libpng-%.20s\",",
        "           user_png_ver);",
        "        png_warning(png_ptr, msg);",
        "      }",
        "      sprintf(msg, \"Application  is  running with png.c from libpng-%.20s\",",
        "         png_libpng_ver);",
        "      png_warning(png_ptr, msg);",
        "   }",
        "#endif",
        "   if(png_sizeof(png_struct) > png_struct_size)",
        "     {",
        "       png_ptr->error_fn=NULL;",
        "#ifdef PNG_ERROR_NUMBERS_SUPPORTED",
        "       png_ptr->flags=0;",
        "#endif"
      ]
    },
    {
      "file_path": "extlib/libpng/pngwutil.c",
      "matched_lines": [
        180
      ],
      "context_lines": [
        170,
        171,
        172,
        173,
        174,
        175,
        176,
        177,
        178,
        179,
        181,
        182,
        183,
        184,
        185,
        186,
        187,
        188,
        189,
        190
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/libpng/pngwutil.c-170-   {",
        "extlib/libpng/pngwutil.c-171-       comp->input = text;",
        "extlib/libpng/pngwutil.c-172-       comp->input_len = text_len;",
        "extlib/libpng/pngwutil.c-173-       return((int)text_len);",
        "extlib/libpng/pngwutil.c-174-   }",
        "extlib/libpng/pngwutil.c-175-",
        "extlib/libpng/pngwutil.c-176-   if (compression >= PNG_TEXT_COMPRESSION_LAST)",
        "extlib/libpng/pngwutil.c-177-   {",
        "extlib/libpng/pngwutil.c-178-#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)",
        "extlib/libpng/pngwutil.c-179-      char msg[50];",
        "extlib/libpng/pngwutil.c:180:      sprintf(msg, \"Unknown compression type %d\", compression);",
        "extlib/libpng/pngwutil.c-181-      png_warning(png_ptr, msg);",
        "extlib/libpng/pngwutil.c-182-#else",
        "extlib/libpng/pngwutil.c-183-      png_warning(png_ptr, \"Unknown compression type\");",
        "extlib/libpng/pngwutil.c-184-#endif",
        "extlib/libpng/pngwutil.c-185-   }",
        "extlib/libpng/pngwutil.c-186-",
        "extlib/libpng/pngwutil.c-187-   /* We can't write the chunk until we find out how much data we have,",
        "extlib/libpng/pngwutil.c-188-    * which means we need to run the compressor first and save the",
        "extlib/libpng/pngwutil.c-189-    * output.  This shouldn't be a problem, as the vast majority of",
        "extlib/libpng/pngwutil.c-190-    * comments should be reasonable, but we will set up an array of"
      ],
      "raw_content": [
        "   {",
        "       comp->input = text;",
        "       comp->input_len = text_len;",
        "       return((int)text_len);",
        "   }",
        "",
        "   if (compression >= PNG_TEXT_COMPRESSION_LAST)",
        "   {",
        "#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)",
        "      char msg[50];",
        "      sprintf(msg, \"Unknown compression type %d\", compression);",
        "      png_warning(png_ptr, msg);",
        "#else",
        "      png_warning(png_ptr, \"Unknown compression type\");",
        "#endif",
        "   }",
        "",
        "   /* We can't write the chunk until we find out how much data we have,",
        "    * which means we need to run the compressor first and save the",
        "    * output.  This shouldn't be a problem, as the vast majority of",
        "    * comments should be reasonable, but we will set up an array of"
      ]
    },
    {
      "file_path": "extlib/libpng/pngwutil.c",
      "matched_lines": [
        1207
      ],
      "context_lines": [
        1197,
        1198,
        1199,
        1200,
        1201,
        1202,
        1203,
        1204,
        1205,
        1206,
        1208,
        1209,
        1210,
        1211,
        1212,
        1213,
        1214,
        1215,
        1216,
        1217
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/libpng/pngwutil.c-1197-   }",
        "extlib/libpng/pngwutil.c-1198-",
        "extlib/libpng/pngwutil.c-1199-   /* Replace non-printing characters with a blank and print a warning */",
        "extlib/libpng/pngwutil.c-1200-   for (kp = key, dp = *new_key; *kp != '\\0'; kp++, dp++)",
        "extlib/libpng/pngwutil.c-1201-   {",
        "extlib/libpng/pngwutil.c-1202-      if (*kp < 0x20 || (*kp > 0x7E && (png_byte)*kp < 0xA1))",
        "extlib/libpng/pngwutil.c-1203-      {",
        "extlib/libpng/pngwutil.c-1204-#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)",
        "extlib/libpng/pngwutil.c-1205-         char msg[40];",
        "extlib/libpng/pngwutil.c-1206-",
        "extlib/libpng/pngwutil.c:1207:         sprintf(msg, \"invalid keyword character 0x%02X\", *kp);",
        "extlib/libpng/pngwutil.c-1208-         png_warning(png_ptr, msg);",
        "extlib/libpng/pngwutil.c-1209-#else",
        "extlib/libpng/pngwutil.c-1210-         png_warning(png_ptr, \"invalid character in keyword\");",
        "extlib/libpng/pngwutil.c-1211-#endif",
        "extlib/libpng/pngwutil.c-1212-         *dp = ' ';",
        "extlib/libpng/pngwutil.c-1213-      }",
        "extlib/libpng/pngwutil.c-1214-      else",
        "extlib/libpng/pngwutil.c-1215-      {",
        "extlib/libpng/pngwutil.c-1216-         *dp = *kp;",
        "extlib/libpng/pngwutil.c-1217-      }"
      ],
      "raw_content": [
        "   }",
        "",
        "   /* Replace non-printing characters with a blank and print a warning */",
        "   for (kp = key, dp = *new_key; *kp != '\\0'; kp++, dp++)",
        "   {",
        "      if (*kp < 0x20 || (*kp > 0x7E && (png_byte)*kp < 0xA1))",
        "      {",
        "#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)",
        "         char msg[40];",
        "",
        "         sprintf(msg, \"invalid keyword character 0x%02X\", *kp);",
        "         png_warning(png_ptr, msg);",
        "#else",
        "         png_warning(png_ptr, \"invalid character in keyword\");",
        "#endif",
        "         *dp = ' ';",
        "      }",
        "      else",
        "      {",
        "         *dp = *kp;",
        "      }"
      ]
    },
    {
      "file_path": "extlib/libpng/pngwutil.c",
      "matched_lines": [
        1567,
        1576,
        1577
      ],
      "context_lines": [
        1557,
        1558,
        1559,
        1560,
        1561,
        1562,
        1563,
        1564,
        1565,
        1566,
        1568,
        1569,
        1570,
        1571,
        1572,
        1573,
        1574,
        1575,
        1578,
        1579,
        1580,
        1581,
        1582,
        1583,
        1584,
        1585,
        1586,
        1587
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/libpng/pngwutil.c-1557-#ifdef PNG_USE_LOCAL_ARRAYS",
        "extlib/libpng/pngwutil.c-1558-   PNG_sCAL;",
        "extlib/libpng/pngwutil.c-1559-#endif",
        "extlib/libpng/pngwutil.c-1560-   png_size_t total_len;",
        "extlib/libpng/pngwutil.c-1561-   char wbuf[32], hbuf[32];",
        "extlib/libpng/pngwutil.c-1562-   png_byte bunit = unit;",
        "extlib/libpng/pngwutil.c-1563-",
        "extlib/libpng/pngwutil.c-1564-   png_debug(1, \"in png_write_sCAL\\n\");",
        "extlib/libpng/pngwutil.c-1565-",
        "extlib/libpng/pngwutil.c-1566-#if defined(_WIN32_WCE)",
        "extlib/libpng/pngwutil.c:1567:/* sprintf() function is not supported on WindowsCE */",
        "extlib/libpng/pngwutil.c-1568-   {",
        "extlib/libpng/pngwutil.c-1569-      wchar_t wc_buf[32];",
        "extlib/libpng/pngwutil.c-1570-      swprintf(wc_buf, TEXT(\"%12.12e\"), width);",
        "extlib/libpng/pngwutil.c-1571-      WideCharToMultiByte(CP_ACP, 0, wc_buf, -1, wbuf, 32, NULL, NULL);",
        "extlib/libpng/pngwutil.c-1572-      swprintf(wc_buf, TEXT(\"%12.12e\"), height);",
        "extlib/libpng/pngwutil.c-1573-      WideCharToMultiByte(CP_ACP, 0, wc_buf, -1, hbuf, 32, NULL, NULL);",
        "extlib/libpng/pngwutil.c-1574-   }",
        "extlib/libpng/pngwutil.c-1575-#else",
        "extlib/libpng/pngwutil.c:1576:   sprintf(wbuf, \"%12.12e\", width);",
        "extlib/libpng/pngwutil.c:1577:   sprintf(hbuf, \"%12.12e\", height);",
        "extlib/libpng/pngwutil.c-1578-#endif",
        "extlib/libpng/pngwutil.c-1579-   total_len = 1 + png_strlen(wbuf)+1 + png_strlen(hbuf);",
        "extlib/libpng/pngwutil.c-1580-",
        "extlib/libpng/pngwutil.c-1581-   png_debug1(3, \"sCAL total length = %d\\n\", (int)total_len);",
        "extlib/libpng/pngwutil.c-1582-   png_write_chunk_start(png_ptr, (png_bytep)png_sCAL, (png_uint_32)total_len);",
        "extlib/libpng/pngwutil.c-1583-   png_write_chunk_data(png_ptr, (png_bytep)&bunit, 1);",
        "extlib/libpng/pngwutil.c-1584-   png_write_chunk_data(png_ptr, (png_bytep)wbuf, png_strlen(wbuf)+1);",
        "extlib/libpng/pngwutil.c-1585-   png_write_chunk_data(png_ptr, (png_bytep)hbuf, png_strlen(hbuf));",
        "extlib/libpng/pngwutil.c-1586-",
        "extlib/libpng/pngwutil.c-1587-   png_write_chunk_end(png_ptr);"
      ],
      "raw_content": [
        "#ifdef PNG_USE_LOCAL_ARRAYS",
        "   PNG_sCAL;",
        "#endif",
        "   png_size_t total_len;",
        "   char wbuf[32], hbuf[32];",
        "   png_byte bunit = unit;",
        "",
        "   png_debug(1, \"in png_write_sCAL\\n\");",
        "",
        "#if defined(_WIN32_WCE)",
        "/* sprintf() function is not supported on WindowsCE */",
        "   {",
        "      wchar_t wc_buf[32];",
        "      swprintf(wc_buf, TEXT(\"%12.12e\"), width);",
        "      WideCharToMultiByte(CP_ACP, 0, wc_buf, -1, wbuf, 32, NULL, NULL);",
        "      swprintf(wc_buf, TEXT(\"%12.12e\"), height);",
        "      WideCharToMultiByte(CP_ACP, 0, wc_buf, -1, hbuf, 32, NULL, NULL);",
        "   }",
        "#else",
        "   sprintf(wbuf, \"%12.12e\", width);",
        "   sprintf(hbuf, \"%12.12e\", height);",
        "#endif",
        "   total_len = 1 + png_strlen(wbuf)+1 + png_strlen(hbuf);",
        "",
        "   png_debug1(3, \"sCAL total length = %d\\n\", (int)total_len);",
        "   png_write_chunk_start(png_ptr, (png_bytep)png_sCAL, (png_uint_32)total_len);",
        "   png_write_chunk_data(png_ptr, (png_bytep)&bunit, 1);",
        "   png_write_chunk_data(png_ptr, (png_bytep)wbuf, png_strlen(wbuf)+1);",
        "   png_write_chunk_data(png_ptr, (png_bytep)hbuf, png_strlen(hbuf));",
        "",
        "   png_write_chunk_end(png_ptr);"
      ]
    },
    {
      "file_path": "extlib/libtiff/tif_dirinfo.c",
      "matched_lines": [
        841
      ],
      "context_lines": [
        831,
        832,
        833,
        834,
        835,
        836,
        837,
        838,
        839,
        840,
        842,
        843,
        844,
        845,
        846
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/libtiff/tif_dirinfo.c-831-\tfld->field_passcount = TRUE;",
        "extlib/libtiff/tif_dirinfo.c-832-\tfld->field_name = (char *) _TIFFmalloc(32);",
        "extlib/libtiff/tif_dirinfo.c-833-\tif (fld->field_name == NULL) {",
        "extlib/libtiff/tif_dirinfo.c-834-\t    _TIFFfree(fld);",
        "extlib/libtiff/tif_dirinfo.c-835-\t    return NULL;",
        "extlib/libtiff/tif_dirinfo.c-836-\t}",
        "extlib/libtiff/tif_dirinfo.c-837-",
        "extlib/libtiff/tif_dirinfo.c-838-\t/* note that this name is a special sign to TIFFClose() and",
        "extlib/libtiff/tif_dirinfo.c-839-\t * _TIFFSetupFieldInfo() to free the field",
        "extlib/libtiff/tif_dirinfo.c-840-\t */",
        "extlib/libtiff/tif_dirinfo.c:841:\tsprintf(fld->field_name, \"Tag %d\", (int) tag);",
        "extlib/libtiff/tif_dirinfo.c-842-",
        "extlib/libtiff/tif_dirinfo.c-843-\treturn fld;    ",
        "extlib/libtiff/tif_dirinfo.c-844-}",
        "extlib/libtiff/tif_dirinfo.c-845-",
        "extlib/libtiff/tif_dirinfo.c-846-/* vim: set ts=8 sts=8 sw=8 noet: */"
      ],
      "raw_content": [
        "\tfld->field_passcount = TRUE;",
        "\tfld->field_name = (char *) _TIFFmalloc(32);",
        "\tif (fld->field_name == NULL) {",
        "\t    _TIFFfree(fld);",
        "\t    return NULL;",
        "\t}",
        "",
        "\t/* note that this name is a special sign to TIFFClose() and",
        "\t * _TIFFSetupFieldInfo() to free the field",
        "\t */",
        "\tsprintf(fld->field_name, \"Tag %d\", (int) tag);",
        "",
        "\treturn fld;    ",
        "}",
        "",
        "/* vim: set ts=8 sts=8 sw=8 noet: */"
      ]
    },
    {
      "file_path": "extlib/libtiff/tif_getimage.c",
      "matched_lines": [
        80,
        88,
        102,
        113,
        129,
        136,
        146,
        152,
        161,
        169,
        174,
        182
      ],
      "context_lines": [
        70,
        71,
        72,
        73,
        74,
        75,
        76,
        77,
        78,
        79,
        81,
        82,
        83,
        84,
        85,
        86,
        87,
        89,
        90,
        91,
        92,
        93,
        94,
        95,
        96,
        97,
        98,
        99,
        100,
        101,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        111,
        112,
        114,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        123,
        124,
        125,
        126,
        127,
        128,
        130,
        131,
        132,
        133,
        134,
        135,
        137,
        138,
        139,
        140,
        141,
        142,
        143,
        144,
        145,
        147,
        148,
        149,
        150,
        151,
        153,
        154,
        155,
        156,
        157,
        158,
        159,
        160,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        170,
        171,
        172,
        173,
        175,
        176,
        177,
        178,
        179,
        180,
        181,
        183,
        184,
        185,
        186,
        187,
        188,
        189,
        190,
        191,
        192
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/libtiff/tif_getimage.c-70- * why it is being rejected.",
        "extlib/libtiff/tif_getimage.c-71- */",
        "extlib/libtiff/tif_getimage.c-72-int",
        "extlib/libtiff/tif_getimage.c-73-TIFFRGBAImageOK(TIFF* tif, char emsg[1024])",
        "extlib/libtiff/tif_getimage.c-74-{",
        "extlib/libtiff/tif_getimage.c-75-    TIFFDirectory* td = &tif->tif_dir;",
        "extlib/libtiff/tif_getimage.c-76-    uint16 photometric;",
        "extlib/libtiff/tif_getimage.c-77-    int colorchannels;",
        "extlib/libtiff/tif_getimage.c-78-",
        "extlib/libtiff/tif_getimage.c-79-    if (!tif->tif_decodestatus) {",
        "extlib/libtiff/tif_getimage.c:80:\tsprintf(emsg, \"Sorry, requested compression method is not configured\");",
        "extlib/libtiff/tif_getimage.c-81-\treturn (0);",
        "extlib/libtiff/tif_getimage.c-82-    }",
        "extlib/libtiff/tif_getimage.c-83-    switch (td->td_bitspersample) {",
        "extlib/libtiff/tif_getimage.c-84-    case 1: case 2: case 4:",
        "extlib/libtiff/tif_getimage.c-85-    case 8: case 16:",
        "extlib/libtiff/tif_getimage.c-86-\tbreak;",
        "extlib/libtiff/tif_getimage.c-87-    default:",
        "extlib/libtiff/tif_getimage.c:88:\tsprintf(emsg, \"Sorry, can not handle images with %d-bit samples\",",
        "extlib/libtiff/tif_getimage.c-89-\t    td->td_bitspersample);",
        "extlib/libtiff/tif_getimage.c-90-\treturn (0);",
        "extlib/libtiff/tif_getimage.c-91-    }",
        "extlib/libtiff/tif_getimage.c-92-    colorchannels = td->td_samplesperpixel - td->td_extrasamples;",
        "extlib/libtiff/tif_getimage.c-93-    if (!TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric)) {",
        "extlib/libtiff/tif_getimage.c-94-\tswitch (colorchannels) {",
        "extlib/libtiff/tif_getimage.c-95-\tcase 1:",
        "extlib/libtiff/tif_getimage.c-96-\t    photometric = PHOTOMETRIC_MINISBLACK;",
        "extlib/libtiff/tif_getimage.c-97-\t    break;",
        "extlib/libtiff/tif_getimage.c-98-\tcase 3:",
        "extlib/libtiff/tif_getimage.c-99-\t    photometric = PHOTOMETRIC_RGB;",
        "extlib/libtiff/tif_getimage.c-100-\t    break;",
        "extlib/libtiff/tif_getimage.c-101-\tdefault:",
        "extlib/libtiff/tif_getimage.c:102:\t    sprintf(emsg, \"Missing needed %s tag\", photoTag);",
        "extlib/libtiff/tif_getimage.c-103-\t    return (0);",
        "extlib/libtiff/tif_getimage.c-104-\t}",
        "extlib/libtiff/tif_getimage.c-105-    }",
        "extlib/libtiff/tif_getimage.c-106-    switch (photometric) {",
        "extlib/libtiff/tif_getimage.c-107-    case PHOTOMETRIC_MINISWHITE:",
        "extlib/libtiff/tif_getimage.c-108-    case PHOTOMETRIC_MINISBLACK:",
        "extlib/libtiff/tif_getimage.c-109-    case PHOTOMETRIC_PALETTE:",
        "extlib/libtiff/tif_getimage.c-110-\tif (td->td_planarconfig == PLANARCONFIG_CONTIG ",
        "extlib/libtiff/tif_getimage.c-111-            && td->td_samplesperpixel != 1",
        "extlib/libtiff/tif_getimage.c-112-            && td->td_bitspersample < 8 ) {",
        "extlib/libtiff/tif_getimage.c:113:\t    sprintf(emsg,",
        "extlib/libtiff/tif_getimage.c-114-                    \"Sorry, can not handle contiguous data with %s=%d, \"",
        "extlib/libtiff/tif_getimage.c-115-                    \"and %s=%d and Bits/Sample=%d\",",
        "extlib/libtiff/tif_getimage.c-116-                    photoTag, photometric,",
        "extlib/libtiff/tif_getimage.c-117-                    \"Samples/pixel\", td->td_samplesperpixel,",
        "extlib/libtiff/tif_getimage.c-118-                    td->td_bitspersample);",
        "extlib/libtiff/tif_getimage.c-119-\t    return (0);",
        "extlib/libtiff/tif_getimage.c-120-\t}",
        "extlib/libtiff/tif_getimage.c-121-        /*",
        "extlib/libtiff/tif_getimage.c-122-        ** We should likely validate that any extra samples are either",
        "extlib/libtiff/tif_getimage.c-123-        ** to be ignored, or are alpha, and if alpha we should try to use",
        "extlib/libtiff/tif_getimage.c-124-        ** them.  But for now we won't bother with this. ",
        "extlib/libtiff/tif_getimage.c-125-        */",
        "extlib/libtiff/tif_getimage.c-126-\tbreak;",
        "extlib/libtiff/tif_getimage.c-127-    case PHOTOMETRIC_YCBCR:",
        "extlib/libtiff/tif_getimage.c-128-\tif (td->td_planarconfig != PLANARCONFIG_CONTIG) {",
        "extlib/libtiff/tif_getimage.c:129:\t    sprintf(emsg, \"Sorry, can not handle YCbCr images with %s=%d\",",
        "extlib/libtiff/tif_getimage.c-130-\t\t\"Planarconfiguration\", td->td_planarconfig);",
        "extlib/libtiff/tif_getimage.c-131-\t    return (0);",
        "extlib/libtiff/tif_getimage.c-132-\t}",
        "extlib/libtiff/tif_getimage.c-133-\tbreak;",
        "extlib/libtiff/tif_getimage.c-134-    case PHOTOMETRIC_RGB: ",
        "extlib/libtiff/tif_getimage.c-135-\tif (colorchannels < 3) {",
        "extlib/libtiff/tif_getimage.c:136:\t    sprintf(emsg, \"Sorry, can not handle RGB image with %s=%d\",",
        "extlib/libtiff/tif_getimage.c-137-\t\t\"Color channels\", colorchannels);",
        "extlib/libtiff/tif_getimage.c-138-\t    return (0);",
        "extlib/libtiff/tif_getimage.c-139-\t}",
        "extlib/libtiff/tif_getimage.c-140-\tbreak;",
        "extlib/libtiff/tif_getimage.c-141-    case PHOTOMETRIC_SEPARATED:",
        "extlib/libtiff/tif_getimage.c-142-\t{",
        "extlib/libtiff/tif_getimage.c-143-\t\tuint16 inkset;",
        "extlib/libtiff/tif_getimage.c-144-\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_INKSET, &inkset);",
        "extlib/libtiff/tif_getimage.c-145-\t\tif (inkset != INKSET_CMYK) {",
        "extlib/libtiff/tif_getimage.c:146:\t\t    sprintf(emsg,",
        "extlib/libtiff/tif_getimage.c-147-\t\t\t    \"Sorry, can not handle separated image with %s=%d\",",
        "extlib/libtiff/tif_getimage.c-148-\t\t\t    \"InkSet\", inkset);",
        "extlib/libtiff/tif_getimage.c-149-\t\t    return 0;",
        "extlib/libtiff/tif_getimage.c-150-\t\t}",
        "extlib/libtiff/tif_getimage.c-151-\t\tif (td->td_samplesperpixel < 4) {",
        "extlib/libtiff/tif_getimage.c:152:\t\t    sprintf(emsg,",
        "extlib/libtiff/tif_getimage.c-153-\t\t\t    \"Sorry, can not handle separated image with %s=%d\",",
        "extlib/libtiff/tif_getimage.c-154-\t\t\t    \"Samples/pixel\", td->td_samplesperpixel);",
        "extlib/libtiff/tif_getimage.c-155-\t\t    return 0;",
        "extlib/libtiff/tif_getimage.c-156-\t\t}",
        "extlib/libtiff/tif_getimage.c-157-\t\tbreak;",
        "extlib/libtiff/tif_getimage.c-158-\t}",
        "extlib/libtiff/tif_getimage.c-159-    case PHOTOMETRIC_LOGL:",
        "extlib/libtiff/tif_getimage.c-160-\tif (td->td_compression != COMPRESSION_SGILOG) {",
        "extlib/libtiff/tif_getimage.c:161:\t    sprintf(emsg, \"Sorry, LogL data must have %s=%d\",",
        "extlib/libtiff/tif_getimage.c-162-\t\t\"Compression\", COMPRESSION_SGILOG);",
        "extlib/libtiff/tif_getimage.c-163-\t    return (0);",
        "extlib/libtiff/tif_getimage.c-164-\t}",
        "extlib/libtiff/tif_getimage.c-165-\tbreak;",
        "extlib/libtiff/tif_getimage.c-166-    case PHOTOMETRIC_LOGLUV:",
        "extlib/libtiff/tif_getimage.c-167-\tif (td->td_compression != COMPRESSION_SGILOG &&",
        "extlib/libtiff/tif_getimage.c-168-\t\ttd->td_compression != COMPRESSION_SGILOG24) {",
        "extlib/libtiff/tif_getimage.c:169:\t    sprintf(emsg, \"Sorry, LogLuv data must have %s=%d or %d\",",
        "extlib/libtiff/tif_getimage.c-170-\t\t\"Compression\", COMPRESSION_SGILOG, COMPRESSION_SGILOG24);",
        "extlib/libtiff/tif_getimage.c-171-\t    return (0);",
        "extlib/libtiff/tif_getimage.c-172-\t}",
        "extlib/libtiff/tif_getimage.c-173-\tif (td->td_planarconfig != PLANARCONFIG_CONTIG) {",
        "extlib/libtiff/tif_getimage.c:174:\t    sprintf(emsg, \"Sorry, can not handle LogLuv images with %s=%d\",",
        "extlib/libtiff/tif_getimage.c-175-\t\t\"Planarconfiguration\", td->td_planarconfig);",
        "extlib/libtiff/tif_getimage.c-176-\t    return (0);",
        "extlib/libtiff/tif_getimage.c-177-\t}",
        "extlib/libtiff/tif_getimage.c-178-\tbreak;",
        "extlib/libtiff/tif_getimage.c-179-    case PHOTOMETRIC_CIELAB:",
        "extlib/libtiff/tif_getimage.c-180-\tbreak;",
        "extlib/libtiff/tif_getimage.c-181-    default:",
        "extlib/libtiff/tif_getimage.c:182:\tsprintf(emsg, \"Sorry, can not handle image with %s=%d\",",
        "extlib/libtiff/tif_getimage.c-183-\t    photoTag, photometric);",
        "extlib/libtiff/tif_getimage.c-184-\treturn (0);",
        "extlib/libtiff/tif_getimage.c-185-    }",
        "extlib/libtiff/tif_getimage.c-186-    return (1);",
        "extlib/libtiff/tif_getimage.c-187-}",
        "extlib/libtiff/tif_getimage.c-188-",
        "extlib/libtiff/tif_getimage.c-189-void",
        "extlib/libtiff/tif_getimage.c-190-TIFFRGBAImageEnd(TIFFRGBAImage* img)",
        "extlib/libtiff/tif_getimage.c-191-{",
        "extlib/libtiff/tif_getimage.c-192-\tif (img->Map)"
      ],
      "raw_content": [
        " * why it is being rejected.",
        " */",
        "int",
        "TIFFRGBAImageOK(TIFF* tif, char emsg[1024])",
        "{",
        "    TIFFDirectory* td = &tif->tif_dir;",
        "    uint16 photometric;",
        "    int colorchannels;",
        "",
        "    if (!tif->tif_decodestatus) {",
        "\tsprintf(emsg, \"Sorry, requested compression method is not configured\");",
        "\treturn (0);",
        "    }",
        "    switch (td->td_bitspersample) {",
        "    case 1: case 2: case 4:",
        "    case 8: case 16:",
        "\tbreak;",
        "    default:",
        "\tsprintf(emsg, \"Sorry, can not handle images with %d-bit samples\",",
        "\t    td->td_bitspersample);",
        "\treturn (0);",
        "    }",
        "    colorchannels = td->td_samplesperpixel - td->td_extrasamples;",
        "    if (!TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric)) {",
        "\tswitch (colorchannels) {",
        "\tcase 1:",
        "\t    photometric = PHOTOMETRIC_MINISBLACK;",
        "\t    break;",
        "\tcase 3:",
        "\t    photometric = PHOTOMETRIC_RGB;",
        "\t    break;",
        "\tdefault:",
        "\t    sprintf(emsg, \"Missing needed %s tag\", photoTag);",
        "\t    return (0);",
        "\t}",
        "    }",
        "    switch (photometric) {",
        "    case PHOTOMETRIC_MINISWHITE:",
        "    case PHOTOMETRIC_MINISBLACK:",
        "    case PHOTOMETRIC_PALETTE:",
        "\tif (td->td_planarconfig == PLANARCONFIG_CONTIG ",
        "            && td->td_samplesperpixel != 1",
        "            && td->td_bitspersample < 8 ) {",
        "\t    sprintf(emsg,",
        "                    \"Sorry, can not handle contiguous data with %s=%d, \"",
        "                    \"and %s=%d and Bits/Sample=%d\",",
        "                    photoTag, photometric,",
        "                    \"Samples/pixel\", td->td_samplesperpixel,",
        "                    td->td_bitspersample);",
        "\t    return (0);",
        "\t}",
        "        /*",
        "        ** We should likely validate that any extra samples are either",
        "        ** to be ignored, or are alpha, and if alpha we should try to use",
        "        ** them.  But for now we won't bother with this. ",
        "        */",
        "\tbreak;",
        "    case PHOTOMETRIC_YCBCR:",
        "\tif (td->td_planarconfig != PLANARCONFIG_CONTIG) {",
        "\t    sprintf(emsg, \"Sorry, can not handle YCbCr images with %s=%d\",",
        "\t\t\"Planarconfiguration\", td->td_planarconfig);",
        "\t    return (0);",
        "\t}",
        "\tbreak;",
        "    case PHOTOMETRIC_RGB: ",
        "\tif (colorchannels < 3) {",
        "\t    sprintf(emsg, \"Sorry, can not handle RGB image with %s=%d\",",
        "\t\t\"Color channels\", colorchannels);",
        "\t    return (0);",
        "\t}",
        "\tbreak;",
        "    case PHOTOMETRIC_SEPARATED:",
        "\t{",
        "\t\tuint16 inkset;",
        "\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_INKSET, &inkset);",
        "\t\tif (inkset != INKSET_CMYK) {",
        "\t\t    sprintf(emsg,",
        "\t\t\t    \"Sorry, can not handle separated image with %s=%d\",",
        "\t\t\t    \"InkSet\", inkset);",
        "\t\t    return 0;",
        "\t\t}",
        "\t\tif (td->td_samplesperpixel < 4) {",
        "\t\t    sprintf(emsg,",
        "\t\t\t    \"Sorry, can not handle separated image with %s=%d\",",
        "\t\t\t    \"Samples/pixel\", td->td_samplesperpixel);",
        "\t\t    return 0;",
        "\t\t}",
        "\t\tbreak;",
        "\t}",
        "    case PHOTOMETRIC_LOGL:",
        "\tif (td->td_compression != COMPRESSION_SGILOG) {",
        "\t    sprintf(emsg, \"Sorry, LogL data must have %s=%d\",",
        "\t\t\"Compression\", COMPRESSION_SGILOG);",
        "\t    return (0);",
        "\t}",
        "\tbreak;",
        "    case PHOTOMETRIC_LOGLUV:",
        "\tif (td->td_compression != COMPRESSION_SGILOG &&",
        "\t\ttd->td_compression != COMPRESSION_SGILOG24) {",
        "\t    sprintf(emsg, \"Sorry, LogLuv data must have %s=%d or %d\",",
        "\t\t\"Compression\", COMPRESSION_SGILOG, COMPRESSION_SGILOG24);",
        "\t    return (0);",
        "\t}",
        "\tif (td->td_planarconfig != PLANARCONFIG_CONTIG) {",
        "\t    sprintf(emsg, \"Sorry, can not handle LogLuv images with %s=%d\",",
        "\t\t\"Planarconfiguration\", td->td_planarconfig);",
        "\t    return (0);",
        "\t}",
        "\tbreak;",
        "    case PHOTOMETRIC_CIELAB:",
        "\tbreak;",
        "    default:",
        "\tsprintf(emsg, \"Sorry, can not handle image with %s=%d\",",
        "\t    photoTag, photometric);",
        "\treturn (0);",
        "    }",
        "    return (1);",
        "}",
        "",
        "void",
        "TIFFRGBAImageEnd(TIFFRGBAImage* img)",
        "{",
        "\tif (img->Map)"
      ]
    },
    {
      "file_path": "extlib/libtiff/tif_getimage.c",
      "matched_lines": [
        248
      ],
      "context_lines": [
        238,
        239,
        240,
        241,
        242,
        243,
        244,
        245,
        246,
        247,
        249,
        250,
        251,
        252,
        253,
        254,
        255,
        256,
        257,
        258
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/libtiff/tif_getimage.c-238-    img->req_orientation = ORIENTATION_BOTLEFT;\t    /* It is the default */",
        "extlib/libtiff/tif_getimage.c-239-    ",
        "extlib/libtiff/tif_getimage.c-240-    img->tif = tif;",
        "extlib/libtiff/tif_getimage.c-241-    img->stoponerr = stop;",
        "extlib/libtiff/tif_getimage.c-242-    TIFFGetFieldDefaulted(tif, TIFFTAG_BITSPERSAMPLE, &img->bitspersample);",
        "extlib/libtiff/tif_getimage.c-243-    switch (img->bitspersample) {",
        "extlib/libtiff/tif_getimage.c-244-    case 1: case 2: case 4:",
        "extlib/libtiff/tif_getimage.c-245-    case 8: case 16:",
        "extlib/libtiff/tif_getimage.c-246-\tbreak;",
        "extlib/libtiff/tif_getimage.c-247-    default:",
        "extlib/libtiff/tif_getimage.c:248:\tsprintf(emsg, \"Sorry, can not handle images with %d-bit samples\",",
        "extlib/libtiff/tif_getimage.c-249-\t    img->bitspersample);",
        "extlib/libtiff/tif_getimage.c-250-\treturn (0);",
        "extlib/libtiff/tif_getimage.c-251-    }",
        "extlib/libtiff/tif_getimage.c-252-    img->alpha = 0;",
        "extlib/libtiff/tif_getimage.c-253-    TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &img->samplesperpixel);",
        "extlib/libtiff/tif_getimage.c-254-    TIFFGetFieldDefaulted(tif, TIFFTAG_EXTRASAMPLES,",
        "extlib/libtiff/tif_getimage.c-255-\t&extrasamples, &sampleinfo);",
        "extlib/libtiff/tif_getimage.c-256-    if (extrasamples >= 1)",
        "extlib/libtiff/tif_getimage.c-257-    {",
        "extlib/libtiff/tif_getimage.c-258-\tswitch (sampleinfo[0]) {"
      ],
      "raw_content": [
        "    img->req_orientation = ORIENTATION_BOTLEFT;\t    /* It is the default */",
        "    ",
        "    img->tif = tif;",
        "    img->stoponerr = stop;",
        "    TIFFGetFieldDefaulted(tif, TIFFTAG_BITSPERSAMPLE, &img->bitspersample);",
        "    switch (img->bitspersample) {",
        "    case 1: case 2: case 4:",
        "    case 8: case 16:",
        "\tbreak;",
        "    default:",
        "\tsprintf(emsg, \"Sorry, can not handle images with %d-bit samples\",",
        "\t    img->bitspersample);",
        "\treturn (0);",
        "    }",
        "    img->alpha = 0;",
        "    TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &img->samplesperpixel);",
        "    TIFFGetFieldDefaulted(tif, TIFFTAG_EXTRASAMPLES,",
        "\t&extrasamples, &sampleinfo);",
        "    if (extrasamples >= 1)",
        "    {",
        "\tswitch (sampleinfo[0]) {"
      ]
    },
    {
      "file_path": "extlib/libtiff/tif_getimage.c",
      "matched_lines": [
        298,
        306,
        316,
        330,
        341
      ],
      "context_lines": [
        288,
        289,
        290,
        291,
        292,
        293,
        294,
        295,
        296,
        297,
        299,
        300,
        301,
        302,
        303,
        304,
        305,
        307,
        308,
        309,
        310,
        311,
        312,
        313,
        314,
        315,
        317,
        318,
        319,
        320,
        321,
        322,
        323,
        324,
        325,
        326,
        327,
        328,
        329,
        331,
        332,
        333,
        334,
        335,
        336,
        337,
        338,
        339,
        340,
        342,
        343,
        344,
        345,
        346,
        347,
        348,
        349,
        350,
        351
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/libtiff/tif_getimage.c-288-\tcase 1:",
        "extlib/libtiff/tif_getimage.c-289-\t    if (isCCITTCompression(tif))",
        "extlib/libtiff/tif_getimage.c-290-\t\timg->photometric = PHOTOMETRIC_MINISWHITE;",
        "extlib/libtiff/tif_getimage.c-291-\t    else",
        "extlib/libtiff/tif_getimage.c-292-\t\timg->photometric = PHOTOMETRIC_MINISBLACK;",
        "extlib/libtiff/tif_getimage.c-293-\t    break;",
        "extlib/libtiff/tif_getimage.c-294-\tcase 3:",
        "extlib/libtiff/tif_getimage.c-295-\t    img->photometric = PHOTOMETRIC_RGB;",
        "extlib/libtiff/tif_getimage.c-296-\t    break;",
        "extlib/libtiff/tif_getimage.c-297-\tdefault:",
        "extlib/libtiff/tif_getimage.c:298:\t    sprintf(emsg, \"Missing needed %s tag\", photoTag);",
        "extlib/libtiff/tif_getimage.c-299-\t    return (0);",
        "extlib/libtiff/tif_getimage.c-300-\t}",
        "extlib/libtiff/tif_getimage.c-301-    }",
        "extlib/libtiff/tif_getimage.c-302-    switch (img->photometric) {",
        "extlib/libtiff/tif_getimage.c-303-    case PHOTOMETRIC_PALETTE:",
        "extlib/libtiff/tif_getimage.c-304-\tif (!TIFFGetField(tif, TIFFTAG_COLORMAP,",
        "extlib/libtiff/tif_getimage.c-305-\t    &red_orig, &green_orig, &blue_orig)) {",
        "extlib/libtiff/tif_getimage.c:306:\t    sprintf(emsg, \"Missing required \\\"Colormap\\\" tag\");",
        "extlib/libtiff/tif_getimage.c-307-\t    return (0);",
        "extlib/libtiff/tif_getimage.c-308-\t}",
        "extlib/libtiff/tif_getimage.c-309-",
        "extlib/libtiff/tif_getimage.c-310-        /* copy the colormaps so we can modify them */",
        "extlib/libtiff/tif_getimage.c-311-        n_color = (1L << img->bitspersample);",
        "extlib/libtiff/tif_getimage.c-312-        img->redcmap = (uint16 *) _TIFFmalloc(sizeof(uint16)*n_color);",
        "extlib/libtiff/tif_getimage.c-313-        img->greencmap = (uint16 *) _TIFFmalloc(sizeof(uint16)*n_color);",
        "extlib/libtiff/tif_getimage.c-314-        img->bluecmap = (uint16 *) _TIFFmalloc(sizeof(uint16)*n_color);",
        "extlib/libtiff/tif_getimage.c-315-        if( !img->redcmap || !img->greencmap || !img->bluecmap ) {",
        "extlib/libtiff/tif_getimage.c:316:\t    sprintf(emsg, \"Out of memory for colormap copy\");",
        "extlib/libtiff/tif_getimage.c-317-\t    return (0);",
        "extlib/libtiff/tif_getimage.c-318-        }",
        "extlib/libtiff/tif_getimage.c-319-",
        "extlib/libtiff/tif_getimage.c-320-        _TIFFmemcpy( img->redcmap, red_orig, n_color * 2 );",
        "extlib/libtiff/tif_getimage.c-321-        _TIFFmemcpy( img->greencmap, green_orig, n_color * 2 );",
        "extlib/libtiff/tif_getimage.c-322-        _TIFFmemcpy( img->bluecmap, blue_orig, n_color * 2 );",
        "extlib/libtiff/tif_getimage.c-323-        ",
        "extlib/libtiff/tif_getimage.c-324-\t/* fall thru... */",
        "extlib/libtiff/tif_getimage.c-325-    case PHOTOMETRIC_MINISWHITE:",
        "extlib/libtiff/tif_getimage.c-326-    case PHOTOMETRIC_MINISBLACK:",
        "extlib/libtiff/tif_getimage.c-327-\tif (planarconfig == PLANARCONFIG_CONTIG ",
        "extlib/libtiff/tif_getimage.c-328-            && img->samplesperpixel != 1",
        "extlib/libtiff/tif_getimage.c-329-            && img->bitspersample < 8 ) {",
        "extlib/libtiff/tif_getimage.c:330:\t    sprintf(emsg,",
        "extlib/libtiff/tif_getimage.c-331-                    \"Sorry, can not handle contiguous data with %s=%d, \"",
        "extlib/libtiff/tif_getimage.c-332-                    \"and %s=%d and Bits/Sample=%d\",",
        "extlib/libtiff/tif_getimage.c-333-                    photoTag, img->photometric,",
        "extlib/libtiff/tif_getimage.c-334-                    \"Samples/pixel\", img->samplesperpixel,",
        "extlib/libtiff/tif_getimage.c-335-                    img->bitspersample);",
        "extlib/libtiff/tif_getimage.c-336-\t    return (0);",
        "extlib/libtiff/tif_getimage.c-337-\t}",
        "extlib/libtiff/tif_getimage.c-338-\tbreak;",
        "extlib/libtiff/tif_getimage.c-339-    case PHOTOMETRIC_YCBCR:",
        "extlib/libtiff/tif_getimage.c-340-\tif (planarconfig != PLANARCONFIG_CONTIG) {",
        "extlib/libtiff/tif_getimage.c:341:\t    sprintf(emsg, \"Sorry, can not handle YCbCr images with %s=%d\",",
        "extlib/libtiff/tif_getimage.c-342-\t\t\"Planarconfiguration\", planarconfig);",
        "extlib/libtiff/tif_getimage.c-343-\t    return (0);",
        "extlib/libtiff/tif_getimage.c-344-\t}",
        "extlib/libtiff/tif_getimage.c-345-\t/* It would probably be nice to have a reality check here. */",
        "extlib/libtiff/tif_getimage.c-346-\tif (planarconfig == PLANARCONFIG_CONTIG)",
        "extlib/libtiff/tif_getimage.c-347-\t    /* can rely on libjpeg to convert to RGB */",
        "extlib/libtiff/tif_getimage.c-348-\t    /* XXX should restore current state on exit */",
        "extlib/libtiff/tif_getimage.c-349-\t    switch (compress) {",
        "extlib/libtiff/tif_getimage.c-350-\t\tcase COMPRESSION_OJPEG:",
        "extlib/libtiff/tif_getimage.c-351-\t\tcase COMPRESSION_JPEG:"
      ],
      "raw_content": [
        "\tcase 1:",
        "\t    if (isCCITTCompression(tif))",
        "\t\timg->photometric = PHOTOMETRIC_MINISWHITE;",
        "\t    else",
        "\t\timg->photometric = PHOTOMETRIC_MINISBLACK;",
        "\t    break;",
        "\tcase 3:",
        "\t    img->photometric = PHOTOMETRIC_RGB;",
        "\t    break;",
        "\tdefault:",
        "\t    sprintf(emsg, \"Missing needed %s tag\", photoTag);",
        "\t    return (0);",
        "\t}",
        "    }",
        "    switch (img->photometric) {",
        "    case PHOTOMETRIC_PALETTE:",
        "\tif (!TIFFGetField(tif, TIFFTAG_COLORMAP,",
        "\t    &red_orig, &green_orig, &blue_orig)) {",
        "\t    sprintf(emsg, \"Missing required \\\"Colormap\\\" tag\");",
        "\t    return (0);",
        "\t}",
        "",
        "        /* copy the colormaps so we can modify them */",
        "        n_color = (1L << img->bitspersample);",
        "        img->redcmap = (uint16 *) _TIFFmalloc(sizeof(uint16)*n_color);",
        "        img->greencmap = (uint16 *) _TIFFmalloc(sizeof(uint16)*n_color);",
        "        img->bluecmap = (uint16 *) _TIFFmalloc(sizeof(uint16)*n_color);",
        "        if( !img->redcmap || !img->greencmap || !img->bluecmap ) {",
        "\t    sprintf(emsg, \"Out of memory for colormap copy\");",
        "\t    return (0);",
        "        }",
        "",
        "        _TIFFmemcpy( img->redcmap, red_orig, n_color * 2 );",
        "        _TIFFmemcpy( img->greencmap, green_orig, n_color * 2 );",
        "        _TIFFmemcpy( img->bluecmap, blue_orig, n_color * 2 );",
        "        ",
        "\t/* fall thru... */",
        "    case PHOTOMETRIC_MINISWHITE:",
        "    case PHOTOMETRIC_MINISBLACK:",
        "\tif (planarconfig == PLANARCONFIG_CONTIG ",
        "            && img->samplesperpixel != 1",
        "            && img->bitspersample < 8 ) {",
        "\t    sprintf(emsg,",
        "                    \"Sorry, can not handle contiguous data with %s=%d, \"",
        "                    \"and %s=%d and Bits/Sample=%d\",",
        "                    photoTag, img->photometric,",
        "                    \"Samples/pixel\", img->samplesperpixel,",
        "                    img->bitspersample);",
        "\t    return (0);",
        "\t}",
        "\tbreak;",
        "    case PHOTOMETRIC_YCBCR:",
        "\tif (planarconfig != PLANARCONFIG_CONTIG) {",
        "\t    sprintf(emsg, \"Sorry, can not handle YCbCr images with %s=%d\",",
        "\t\t\"Planarconfiguration\", planarconfig);",
        "\t    return (0);",
        "\t}",
        "\t/* It would probably be nice to have a reality check here. */",
        "\tif (planarconfig == PLANARCONFIG_CONTIG)",
        "\t    /* can rely on libjpeg to convert to RGB */",
        "\t    /* XXX should restore current state on exit */",
        "\t    switch (compress) {",
        "\t\tcase COMPRESSION_OJPEG:",
        "\t\tcase COMPRESSION_JPEG:"
      ]
    },
    {
      "file_path": "extlib/libtiff/tif_getimage.c",
      "matched_lines": [
        363,
        372,
        377,
        385,
        395,
        400,
        411,
        428,
        434
      ],
      "context_lines": [
        353,
        354,
        355,
        356,
        357,
        358,
        359,
        360,
        361,
        362,
        364,
        365,
        366,
        367,
        368,
        369,
        370,
        371,
        373,
        374,
        375,
        376,
        378,
        379,
        380,
        381,
        382,
        383,
        384,
        386,
        387,
        388,
        389,
        390,
        391,
        392,
        393,
        394,
        396,
        397,
        398,
        399,
        401,
        402,
        403,
        404,
        405,
        406,
        407,
        408,
        409,
        410,
        412,
        413,
        414,
        415,
        416,
        417,
        418,
        419,
        420,
        421,
        422,
        423,
        424,
        425,
        426,
        427,
        429,
        430,
        431,
        432,
        433,
        435,
        436,
        437,
        438,
        439,
        440,
        441,
        442,
        443,
        444
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/libtiff/tif_getimage.c-353-\t\t    img->photometric = PHOTOMETRIC_RGB;",
        "extlib/libtiff/tif_getimage.c-354-                    break;",
        "extlib/libtiff/tif_getimage.c-355-",
        "extlib/libtiff/tif_getimage.c-356-                default:",
        "extlib/libtiff/tif_getimage.c-357-                    /* do nothing */;",
        "extlib/libtiff/tif_getimage.c-358-                    break;",
        "extlib/libtiff/tif_getimage.c-359-\t    }",
        "extlib/libtiff/tif_getimage.c-360-\tbreak;",
        "extlib/libtiff/tif_getimage.c-361-    case PHOTOMETRIC_RGB: ",
        "extlib/libtiff/tif_getimage.c-362-\tif (colorchannels < 3) {",
        "extlib/libtiff/tif_getimage.c:363:\t    sprintf(emsg, \"Sorry, can not handle RGB image with %s=%d\",",
        "extlib/libtiff/tif_getimage.c-364-\t\t\"Color channels\", colorchannels);",
        "extlib/libtiff/tif_getimage.c-365-\t    return (0);",
        "extlib/libtiff/tif_getimage.c-366-\t}",
        "extlib/libtiff/tif_getimage.c-367-\tbreak;",
        "extlib/libtiff/tif_getimage.c-368-    case PHOTOMETRIC_SEPARATED: {",
        "extlib/libtiff/tif_getimage.c-369-\tuint16 inkset;",
        "extlib/libtiff/tif_getimage.c-370-\tTIFFGetFieldDefaulted(tif, TIFFTAG_INKSET, &inkset);",
        "extlib/libtiff/tif_getimage.c-371-\tif (inkset != INKSET_CMYK) {",
        "extlib/libtiff/tif_getimage.c:372:\t    sprintf(emsg, \"Sorry, can not handle separated image with %s=%d\",",
        "extlib/libtiff/tif_getimage.c-373-\t\t\"InkSet\", inkset);",
        "extlib/libtiff/tif_getimage.c-374-\t    return (0);",
        "extlib/libtiff/tif_getimage.c-375-\t}",
        "extlib/libtiff/tif_getimage.c-376-\tif (img->samplesperpixel < 4) {",
        "extlib/libtiff/tif_getimage.c:377:\t    sprintf(emsg, \"Sorry, can not handle separated image with %s=%d\",",
        "extlib/libtiff/tif_getimage.c-378-\t\t\"Samples/pixel\", img->samplesperpixel);",
        "extlib/libtiff/tif_getimage.c-379-\t    return (0);",
        "extlib/libtiff/tif_getimage.c-380-\t}",
        "extlib/libtiff/tif_getimage.c-381-\tbreak;",
        "extlib/libtiff/tif_getimage.c-382-    }",
        "extlib/libtiff/tif_getimage.c-383-    case PHOTOMETRIC_LOGL:",
        "extlib/libtiff/tif_getimage.c-384-\tif (compress != COMPRESSION_SGILOG) {",
        "extlib/libtiff/tif_getimage.c:385:\t    sprintf(emsg, \"Sorry, LogL data must have %s=%d\",",
        "extlib/libtiff/tif_getimage.c-386-\t\t\"Compression\", COMPRESSION_SGILOG);",
        "extlib/libtiff/tif_getimage.c-387-\t    return (0);",
        "extlib/libtiff/tif_getimage.c-388-\t}",
        "extlib/libtiff/tif_getimage.c-389-\tTIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_8BIT);",
        "extlib/libtiff/tif_getimage.c-390-\timg->photometric = PHOTOMETRIC_MINISBLACK;\t/* little white lie */",
        "extlib/libtiff/tif_getimage.c-391-\timg->bitspersample = 8;",
        "extlib/libtiff/tif_getimage.c-392-\tbreak;",
        "extlib/libtiff/tif_getimage.c-393-    case PHOTOMETRIC_LOGLUV:",
        "extlib/libtiff/tif_getimage.c-394-\tif (compress != COMPRESSION_SGILOG && compress != COMPRESSION_SGILOG24) {",
        "extlib/libtiff/tif_getimage.c:395:\t    sprintf(emsg, \"Sorry, LogLuv data must have %s=%d or %d\",",
        "extlib/libtiff/tif_getimage.c-396-\t\t\"Compression\", COMPRESSION_SGILOG, COMPRESSION_SGILOG24);",
        "extlib/libtiff/tif_getimage.c-397-\t    return (0);",
        "extlib/libtiff/tif_getimage.c-398-\t}",
        "extlib/libtiff/tif_getimage.c-399-\tif (planarconfig != PLANARCONFIG_CONTIG) {",
        "extlib/libtiff/tif_getimage.c:400:\t    sprintf(emsg, \"Sorry, can not handle LogLuv images with %s=%d\",",
        "extlib/libtiff/tif_getimage.c-401-\t\t\"Planarconfiguration\", planarconfig);",
        "extlib/libtiff/tif_getimage.c-402-\t    return (0);",
        "extlib/libtiff/tif_getimage.c-403-\t}",
        "extlib/libtiff/tif_getimage.c-404-\tTIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_8BIT);",
        "extlib/libtiff/tif_getimage.c-405-\timg->photometric = PHOTOMETRIC_RGB;\t\t/* little white lie */",
        "extlib/libtiff/tif_getimage.c-406-\timg->bitspersample = 8;",
        "extlib/libtiff/tif_getimage.c-407-\tbreak;",
        "extlib/libtiff/tif_getimage.c-408-    case PHOTOMETRIC_CIELAB:",
        "extlib/libtiff/tif_getimage.c-409-\tbreak;",
        "extlib/libtiff/tif_getimage.c-410-    default:",
        "extlib/libtiff/tif_getimage.c:411:\tsprintf(emsg, \"Sorry, can not handle image with %s=%d\",",
        "extlib/libtiff/tif_getimage.c-412-\t    photoTag, img->photometric);",
        "extlib/libtiff/tif_getimage.c-413-\treturn (0);",
        "extlib/libtiff/tif_getimage.c-414-    }",
        "extlib/libtiff/tif_getimage.c-415-    img->Map = NULL;",
        "extlib/libtiff/tif_getimage.c-416-    img->BWmap = NULL;",
        "extlib/libtiff/tif_getimage.c-417-    img->PALmap = NULL;",
        "extlib/libtiff/tif_getimage.c-418-    img->ycbcr = NULL;",
        "extlib/libtiff/tif_getimage.c-419-    img->cielab = NULL;",
        "extlib/libtiff/tif_getimage.c-420-    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &img->width);",
        "extlib/libtiff/tif_getimage.c-421-    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &img->height);",
        "extlib/libtiff/tif_getimage.c-422-    TIFFGetFieldDefaulted(tif, TIFFTAG_ORIENTATION, &img->orientation);",
        "extlib/libtiff/tif_getimage.c-423-    img->isContig =",
        "extlib/libtiff/tif_getimage.c-424-\t!(planarconfig == PLANARCONFIG_SEPARATE && colorchannels > 1);",
        "extlib/libtiff/tif_getimage.c-425-    if (img->isContig) {",
        "extlib/libtiff/tif_getimage.c-426-\timg->get = TIFFIsTiled(tif) ? gtTileContig : gtStripContig;",
        "extlib/libtiff/tif_getimage.c-427-\tif (!pickTileContigCase(img)) {",
        "extlib/libtiff/tif_getimage.c:428:\t\tsprintf(emsg, \"Sorry, can not handle image\");",
        "extlib/libtiff/tif_getimage.c-429-\t\treturn 0;",
        "extlib/libtiff/tif_getimage.c-430-\t}",
        "extlib/libtiff/tif_getimage.c-431-    } else {",
        "extlib/libtiff/tif_getimage.c-432-\timg->get = TIFFIsTiled(tif) ? gtTileSeparate : gtStripSeparate;",
        "extlib/libtiff/tif_getimage.c-433-\tif (!pickTileSeparateCase(img)) {",
        "extlib/libtiff/tif_getimage.c:434:\t\tsprintf(emsg, \"Sorry, can not handle image\");",
        "extlib/libtiff/tif_getimage.c-435-\t\treturn 0;",
        "extlib/libtiff/tif_getimage.c-436-\t}",
        "extlib/libtiff/tif_getimage.c-437-    }",
        "extlib/libtiff/tif_getimage.c-438-    return 1;",
        "extlib/libtiff/tif_getimage.c-439-}",
        "extlib/libtiff/tif_getimage.c-440-",
        "extlib/libtiff/tif_getimage.c-441-int",
        "extlib/libtiff/tif_getimage.c-442-TIFFRGBAImageGet(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)",
        "extlib/libtiff/tif_getimage.c-443-{",
        "extlib/libtiff/tif_getimage.c-444-    if (img->get == NULL) {"
      ],
      "raw_content": [
        "\t\t    img->photometric = PHOTOMETRIC_RGB;",
        "                    break;",
        "",
        "                default:",
        "                    /* do nothing */;",
        "                    break;",
        "\t    }",
        "\tbreak;",
        "    case PHOTOMETRIC_RGB: ",
        "\tif (colorchannels < 3) {",
        "\t    sprintf(emsg, \"Sorry, can not handle RGB image with %s=%d\",",
        "\t\t\"Color channels\", colorchannels);",
        "\t    return (0);",
        "\t}",
        "\tbreak;",
        "    case PHOTOMETRIC_SEPARATED: {",
        "\tuint16 inkset;",
        "\tTIFFGetFieldDefaulted(tif, TIFFTAG_INKSET, &inkset);",
        "\tif (inkset != INKSET_CMYK) {",
        "\t    sprintf(emsg, \"Sorry, can not handle separated image with %s=%d\",",
        "\t\t\"InkSet\", inkset);",
        "\t    return (0);",
        "\t}",
        "\tif (img->samplesperpixel < 4) {",
        "\t    sprintf(emsg, \"Sorry, can not handle separated image with %s=%d\",",
        "\t\t\"Samples/pixel\", img->samplesperpixel);",
        "\t    return (0);",
        "\t}",
        "\tbreak;",
        "    }",
        "    case PHOTOMETRIC_LOGL:",
        "\tif (compress != COMPRESSION_SGILOG) {",
        "\t    sprintf(emsg, \"Sorry, LogL data must have %s=%d\",",
        "\t\t\"Compression\", COMPRESSION_SGILOG);",
        "\t    return (0);",
        "\t}",
        "\tTIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_8BIT);",
        "\timg->photometric = PHOTOMETRIC_MINISBLACK;\t/* little white lie */",
        "\timg->bitspersample = 8;",
        "\tbreak;",
        "    case PHOTOMETRIC_LOGLUV:",
        "\tif (compress != COMPRESSION_SGILOG && compress != COMPRESSION_SGILOG24) {",
        "\t    sprintf(emsg, \"Sorry, LogLuv data must have %s=%d or %d\",",
        "\t\t\"Compression\", COMPRESSION_SGILOG, COMPRESSION_SGILOG24);",
        "\t    return (0);",
        "\t}",
        "\tif (planarconfig != PLANARCONFIG_CONTIG) {",
        "\t    sprintf(emsg, \"Sorry, can not handle LogLuv images with %s=%d\",",
        "\t\t\"Planarconfiguration\", planarconfig);",
        "\t    return (0);",
        "\t}",
        "\tTIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_8BIT);",
        "\timg->photometric = PHOTOMETRIC_RGB;\t\t/* little white lie */",
        "\timg->bitspersample = 8;",
        "\tbreak;",
        "    case PHOTOMETRIC_CIELAB:",
        "\tbreak;",
        "    default:",
        "\tsprintf(emsg, \"Sorry, can not handle image with %s=%d\",",
        "\t    photoTag, img->photometric);",
        "\treturn (0);",
        "    }",
        "    img->Map = NULL;",
        "    img->BWmap = NULL;",
        "    img->PALmap = NULL;",
        "    img->ycbcr = NULL;",
        "    img->cielab = NULL;",
        "    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &img->width);",
        "    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &img->height);",
        "    TIFFGetFieldDefaulted(tif, TIFFTAG_ORIENTATION, &img->orientation);",
        "    img->isContig =",
        "\t!(planarconfig == PLANARCONFIG_SEPARATE && colorchannels > 1);",
        "    if (img->isContig) {",
        "\timg->get = TIFFIsTiled(tif) ? gtTileContig : gtStripContig;",
        "\tif (!pickTileContigCase(img)) {",
        "\t\tsprintf(emsg, \"Sorry, can not handle image\");",
        "\t\treturn 0;",
        "\t}",
        "    } else {",
        "\timg->get = TIFFIsTiled(tif) ? gtTileSeparate : gtStripSeparate;",
        "\tif (!pickTileSeparateCase(img)) {",
        "\t\tsprintf(emsg, \"Sorry, can not handle image\");",
        "\t\treturn 0;",
        "\t}",
        "    }",
        "    return 1;",
        "}",
        "",
        "int",
        "TIFFRGBAImageGet(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)",
        "{",
        "    if (img->get == NULL) {"
      ]
    },
    {
      "file_path": "extlib/libtiff/tif_win3.c",
      "matched_lines": [
        208,
        221
      ],
      "context_lines": [
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        209,
        210,
        211,
        212,
        213,
        214,
        215,
        216,
        217,
        218,
        219,
        220,
        222,
        223,
        224,
        225
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/libtiff/tif_win3.c-198-\t}",
        "extlib/libtiff/tif_win3.c-199-\treturn (0);",
        "extlib/libtiff/tif_win3.c-200-}",
        "extlib/libtiff/tif_win3.c-201-",
        "extlib/libtiff/tif_win3.c-202-static void",
        "extlib/libtiff/tif_win3.c-203-win3WarningHandler(const char* module, const char* fmt, va_list ap)",
        "extlib/libtiff/tif_win3.c-204-{",
        "extlib/libtiff/tif_win3.c-205-\tchar e[512] = { '\\0' };",
        "extlib/libtiff/tif_win3.c-206-\tif (module != NULL)",
        "extlib/libtiff/tif_win3.c-207-\t\tstrcat(strcpy(e, module), \":\");",
        "extlib/libtiff/tif_win3.c:208:\tvsprintf(e+strlen(e), fmt, ap);",
        "extlib/libtiff/tif_win3.c-209-\tstrcat(e, \".\");",
        "extlib/libtiff/tif_win3.c-210-\tMessageBox(GetActiveWindow(), e, \"LibTIFF Warning\",",
        "extlib/libtiff/tif_win3.c-211-\t    MB_OK|MB_ICONEXCLAMATION);",
        "extlib/libtiff/tif_win3.c-212-}",
        "extlib/libtiff/tif_win3.c-213-TIFFErrorHandler _TIFFwarningHandler = win3WarningHandler;",
        "extlib/libtiff/tif_win3.c-214-",
        "extlib/libtiff/tif_win3.c-215-static void",
        "extlib/libtiff/tif_win3.c-216-win3ErrorHandler(const char* module, const char* fmt, va_list ap)",
        "extlib/libtiff/tif_win3.c-217-{",
        "extlib/libtiff/tif_win3.c-218-\tchar e[512] = { '\\0' };",
        "extlib/libtiff/tif_win3.c-219-\tif (module != NULL)",
        "extlib/libtiff/tif_win3.c-220-\t\tstrcat(strcpy(e, module), \":\");",
        "extlib/libtiff/tif_win3.c:221:\tvsprintf(e+strlen(e), fmt, ap);",
        "extlib/libtiff/tif_win3.c-222-\tstrcat(e, \".\");",
        "extlib/libtiff/tif_win3.c-223-\tMessageBox(GetActiveWindow(), e, \"LibTIFF Error\", MB_OK|MB_ICONSTOP);",
        "extlib/libtiff/tif_win3.c-224-}",
        "extlib/libtiff/tif_win3.c-225-TIFFErrorHandler _TIFFerrorHandler = win3ErrorHandler;"
      ],
      "raw_content": [
        "\t}",
        "\treturn (0);",
        "}",
        "",
        "static void",
        "win3WarningHandler(const char* module, const char* fmt, va_list ap)",
        "{",
        "\tchar e[512] = { '\\0' };",
        "\tif (module != NULL)",
        "\t\tstrcat(strcpy(e, module), \":\");",
        "\tvsprintf(e+strlen(e), fmt, ap);",
        "\tstrcat(e, \".\");",
        "\tMessageBox(GetActiveWindow(), e, \"LibTIFF Warning\",",
        "\t    MB_OK|MB_ICONEXCLAMATION);",
        "}",
        "TIFFErrorHandler _TIFFwarningHandler = win3WarningHandler;",
        "",
        "static void",
        "win3ErrorHandler(const char* module, const char* fmt, va_list ap)",
        "{",
        "\tchar e[512] = { '\\0' };",
        "\tif (module != NULL)",
        "\t\tstrcat(strcpy(e, module), \":\");",
        "\tvsprintf(e+strlen(e), fmt, ap);",
        "\tstrcat(e, \".\");",
        "\tMessageBox(GetActiveWindow(), e, \"LibTIFF Error\", MB_OK|MB_ICONSTOP);",
        "}",
        "TIFFErrorHandler _TIFFerrorHandler = win3ErrorHandler;"
      ]
    },
    {
      "file_path": "extlib/libtiff/tif_win32.c",
      "matched_lines": [
        349,
        351
      ],
      "context_lines": [
        339,
        340,
        341,
        342,
        343,
        344,
        345,
        346,
        347,
        348,
        350,
        352,
        353,
        354,
        355,
        356,
        357,
        358,
        359,
        360,
        361
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/libtiff/tif_win32.c-339-{",
        "extlib/libtiff/tif_win32.c-340-#ifndef TIF_PLATFORM_CONSOLE",
        "extlib/libtiff/tif_win32.c-341-\tLPTSTR szTitle;",
        "extlib/libtiff/tif_win32.c-342-\tLPTSTR szTmp;",
        "extlib/libtiff/tif_win32.c-343-\tLPCTSTR szTitleText = \"%s Warning\";",
        "extlib/libtiff/tif_win32.c-344-\tLPCTSTR szDefaultModule = \"LIBTIFF\";",
        "extlib/libtiff/tif_win32.c-345-\tLPCTSTR szTmpModule = (module == NULL) ? szDefaultModule : module;",
        "extlib/libtiff/tif_win32.c-346-\tif ((szTitle = (LPTSTR)LocalAlloc(LMEM_FIXED, (strlen(szTmpModule) +",
        "extlib/libtiff/tif_win32.c-347-\t\tstrlen(szTitleText) + strlen(fmt) + 128)*sizeof(char))) == NULL)",
        "extlib/libtiff/tif_win32.c-348-\t\treturn;",
        "extlib/libtiff/tif_win32.c:349:\tsprintf(szTitle, szTitleText, szTmpModule);",
        "extlib/libtiff/tif_win32.c-350-\tszTmp = szTitle + (strlen(szTitle)+2)*sizeof(char);",
        "extlib/libtiff/tif_win32.c:351:\tvsprintf(szTmp, fmt, ap);",
        "extlib/libtiff/tif_win32.c-352-\tMessageBoxA(GetFocus(), szTmp, szTitle, MB_OK | MB_ICONINFORMATION);",
        "extlib/libtiff/tif_win32.c-353-\tLocalFree(szTitle);",
        "extlib/libtiff/tif_win32.c-354-\treturn;",
        "extlib/libtiff/tif_win32.c-355-#else",
        "extlib/libtiff/tif_win32.c-356-\tif (module != NULL)",
        "extlib/libtiff/tif_win32.c-357-\t\tfprintf(stderr, \"%s: \", module);",
        "extlib/libtiff/tif_win32.c-358-\tfprintf(stderr, \"Warning, \");",
        "extlib/libtiff/tif_win32.c-359-\tvfprintf(stderr, fmt, ap);",
        "extlib/libtiff/tif_win32.c-360-\tfprintf(stderr, \".\\n\");",
        "extlib/libtiff/tif_win32.c-361-#endif        "
      ],
      "raw_content": [
        "{",
        "#ifndef TIF_PLATFORM_CONSOLE",
        "\tLPTSTR szTitle;",
        "\tLPTSTR szTmp;",
        "\tLPCTSTR szTitleText = \"%s Warning\";",
        "\tLPCTSTR szDefaultModule = \"LIBTIFF\";",
        "\tLPCTSTR szTmpModule = (module == NULL) ? szDefaultModule : module;",
        "\tif ((szTitle = (LPTSTR)LocalAlloc(LMEM_FIXED, (strlen(szTmpModule) +",
        "\t\tstrlen(szTitleText) + strlen(fmt) + 128)*sizeof(char))) == NULL)",
        "\t\treturn;",
        "\tsprintf(szTitle, szTitleText, szTmpModule);",
        "\tszTmp = szTitle + (strlen(szTitle)+2)*sizeof(char);",
        "\tvsprintf(szTmp, fmt, ap);",
        "\tMessageBoxA(GetFocus(), szTmp, szTitle, MB_OK | MB_ICONINFORMATION);",
        "\tLocalFree(szTitle);",
        "\treturn;",
        "#else",
        "\tif (module != NULL)",
        "\t\tfprintf(stderr, \"%s: \", module);",
        "\tfprintf(stderr, \"Warning, \");",
        "\tvfprintf(stderr, fmt, ap);",
        "\tfprintf(stderr, \".\\n\");",
        "#endif        "
      ]
    },
    {
      "file_path": "extlib/libtiff/tif_win32.c",
      "matched_lines": [
        377,
        379
      ],
      "context_lines": [
        367,
        368,
        369,
        370,
        371,
        372,
        373,
        374,
        375,
        376,
        378,
        380,
        381,
        382,
        383,
        384,
        385,
        386,
        387,
        388,
        389
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/libtiff/tif_win32.c-367-{",
        "extlib/libtiff/tif_win32.c-368-#ifndef TIF_PLATFORM_CONSOLE",
        "extlib/libtiff/tif_win32.c-369-\tLPTSTR szTitle;",
        "extlib/libtiff/tif_win32.c-370-\tLPTSTR szTmp;",
        "extlib/libtiff/tif_win32.c-371-\tLPCTSTR szTitleText = \"%s Error\";",
        "extlib/libtiff/tif_win32.c-372-\tLPCTSTR szDefaultModule = \"LIBTIFF\";",
        "extlib/libtiff/tif_win32.c-373-\tLPCTSTR szTmpModule = (module == NULL) ? szDefaultModule : module;",
        "extlib/libtiff/tif_win32.c-374-\tif ((szTitle = (LPTSTR)LocalAlloc(LMEM_FIXED, (strlen(szTmpModule) +",
        "extlib/libtiff/tif_win32.c-375-\t\tstrlen(szTitleText) + strlen(fmt) + 128)*sizeof(char))) == NULL)",
        "extlib/libtiff/tif_win32.c-376-\t\treturn;",
        "extlib/libtiff/tif_win32.c:377:\tsprintf(szTitle, szTitleText, szTmpModule);",
        "extlib/libtiff/tif_win32.c-378-\tszTmp = szTitle + (strlen(szTitle)+2)*sizeof(char);",
        "extlib/libtiff/tif_win32.c:379:\tvsprintf(szTmp, fmt, ap);",
        "extlib/libtiff/tif_win32.c-380-\tMessageBoxA(GetFocus(), szTmp, szTitle, MB_OK | MB_ICONEXCLAMATION);",
        "extlib/libtiff/tif_win32.c-381-\tLocalFree(szTitle);",
        "extlib/libtiff/tif_win32.c-382-\treturn;",
        "extlib/libtiff/tif_win32.c-383-#else",
        "extlib/libtiff/tif_win32.c-384-\tif (module != NULL)",
        "extlib/libtiff/tif_win32.c-385-\t\tfprintf(stderr, \"%s: \", module);",
        "extlib/libtiff/tif_win32.c-386-\tvfprintf(stderr, fmt, ap);",
        "extlib/libtiff/tif_win32.c-387-\tfprintf(stderr, \".\\n\");",
        "extlib/libtiff/tif_win32.c-388-#endif        ",
        "extlib/libtiff/tif_win32.c-389-}"
      ],
      "raw_content": [
        "{",
        "#ifndef TIF_PLATFORM_CONSOLE",
        "\tLPTSTR szTitle;",
        "\tLPTSTR szTmp;",
        "\tLPCTSTR szTitleText = \"%s Error\";",
        "\tLPCTSTR szDefaultModule = \"LIBTIFF\";",
        "\tLPCTSTR szTmpModule = (module == NULL) ? szDefaultModule : module;",
        "\tif ((szTitle = (LPTSTR)LocalAlloc(LMEM_FIXED, (strlen(szTmpModule) +",
        "\t\tstrlen(szTitleText) + strlen(fmt) + 128)*sizeof(char))) == NULL)",
        "\t\treturn;",
        "\tsprintf(szTitle, szTitleText, szTmpModule);",
        "\tszTmp = szTitle + (strlen(szTitle)+2)*sizeof(char);",
        "\tvsprintf(szTmp, fmt, ap);",
        "\tMessageBoxA(GetFocus(), szTmp, szTitle, MB_OK | MB_ICONEXCLAMATION);",
        "\tLocalFree(szTitle);",
        "\treturn;",
        "#else",
        "\tif (module != NULL)",
        "\t\tfprintf(stderr, \"%s: \", module);",
        "\tvfprintf(stderr, fmt, ap);",
        "\tfprintf(stderr, \".\\n\");",
        "#endif        ",
        "}"
      ]
    },
    {
      "file_path": "extlib/zlib/gzio.c",
      "matched_lines": [
        226
      ],
      "context_lines": [
        216,
        217,
        218,
        219,
        220,
        221,
        222,
        223,
        224,
        225,
        227,
        228,
        229,
        230,
        231,
        232,
        233,
        234,
        235,
        236
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/zlib/gzio.c-216-     Associate a gzFile with the file descriptor fd. fd is not dup'ed here",
        "extlib/zlib/gzio.c-217-   to mimic the behavio(u)r of fdopen.",
        "extlib/zlib/gzio.c-218-*/",
        "extlib/zlib/gzio.c-219-gzFile ZEXPORT gzdopen (fd, mode)",
        "extlib/zlib/gzio.c-220-    int fd;",
        "extlib/zlib/gzio.c-221-    const char *mode;",
        "extlib/zlib/gzio.c-222-{",
        "extlib/zlib/gzio.c-223-    char name[46];      /* allow for up to 128-bit integers */",
        "extlib/zlib/gzio.c-224-",
        "extlib/zlib/gzio.c-225-    if (fd < 0) return (gzFile)Z_NULL;",
        "extlib/zlib/gzio.c:226:    sprintf(name, \"<fd:%d>\", fd); /* for debugging */",
        "extlib/zlib/gzio.c-227-",
        "extlib/zlib/gzio.c-228-    return gz_open (name, mode, fd);",
        "extlib/zlib/gzio.c-229-}",
        "extlib/zlib/gzio.c-230-",
        "extlib/zlib/gzio.c-231-/* ===========================================================================",
        "extlib/zlib/gzio.c-232- * Update the compression level and strategy",
        "extlib/zlib/gzio.c-233- */",
        "extlib/zlib/gzio.c-234-int ZEXPORT gzsetparams (file, level, strategy)",
        "extlib/zlib/gzio.c-235-    gzFile file;",
        "extlib/zlib/gzio.c-236-    int level;"
      ],
      "raw_content": [
        "     Associate a gzFile with the file descriptor fd. fd is not dup'ed here",
        "   to mimic the behavio(u)r of fdopen.",
        "*/",
        "gzFile ZEXPORT gzdopen (fd, mode)",
        "    int fd;",
        "    const char *mode;",
        "{",
        "    char name[46];      /* allow for up to 128-bit integers */",
        "",
        "    if (fd < 0) return (gzFile)Z_NULL;",
        "    sprintf(name, \"<fd:%d>\", fd); /* for debugging */",
        "",
        "    return gz_open (name, mode, fd);",
        "}",
        "",
        "/* ===========================================================================",
        " * Update the compression level and strategy",
        " */",
        "int ZEXPORT gzsetparams (file, level, strategy)",
        "    gzFile file;",
        "    int level;"
      ]
    },
    {
      "file_path": "extlib/zlib/gzio.c",
      "matched_lines": [
        612,
        613,
        618
      ],
      "context_lines": [
        602,
        603,
        604,
        605,
        606,
        607,
        608,
        609,
        610,
        611,
        614,
        615,
        616,
        617,
        619,
        620,
        621,
        622,
        623,
        624,
        625,
        626,
        627,
        628
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/zlib/gzio.c-602-",
        "extlib/zlib/gzio.c-603-int ZEXPORTVA gzprintf (gzFile file, const char *format, /* args */ ...)",
        "extlib/zlib/gzio.c-604-{",
        "extlib/zlib/gzio.c-605-    char buf[Z_PRINTF_BUFSIZE];",
        "extlib/zlib/gzio.c-606-    va_list va;",
        "extlib/zlib/gzio.c-607-    int len;",
        "extlib/zlib/gzio.c-608-",
        "extlib/zlib/gzio.c-609-    buf[sizeof(buf) - 1] = 0;",
        "extlib/zlib/gzio.c-610-    va_start(va, format);",
        "extlib/zlib/gzio.c-611-#ifdef NO_vsnprintf",
        "extlib/zlib/gzio.c:612:#  ifdef HAS_vsprintf_void",
        "extlib/zlib/gzio.c:613:    (void)vsprintf(buf, format, va);",
        "extlib/zlib/gzio.c-614-    va_end(va);",
        "extlib/zlib/gzio.c-615-    for (len = 0; len < sizeof(buf); len++)",
        "extlib/zlib/gzio.c-616-        if (buf[len] == 0) break;",
        "extlib/zlib/gzio.c-617-#  else",
        "extlib/zlib/gzio.c:618:    len = vsprintf(buf, format, va);",
        "extlib/zlib/gzio.c-619-    va_end(va);",
        "extlib/zlib/gzio.c-620-#  endif",
        "extlib/zlib/gzio.c-621-#else",
        "extlib/zlib/gzio.c-622-#  ifdef HAS_vsnprintf_void",
        "extlib/zlib/gzio.c-623-    (void)vsnprintf(buf, sizeof(buf), format, va);",
        "extlib/zlib/gzio.c-624-    va_end(va);",
        "extlib/zlib/gzio.c-625-    len = strlen(buf);",
        "extlib/zlib/gzio.c-626-#  else",
        "extlib/zlib/gzio.c-627-    len = vsnprintf(buf, sizeof(buf), format, va);",
        "extlib/zlib/gzio.c-628-    va_end(va);"
      ],
      "raw_content": [
        "",
        "int ZEXPORTVA gzprintf (gzFile file, const char *format, /* args */ ...)",
        "{",
        "    char buf[Z_PRINTF_BUFSIZE];",
        "    va_list va;",
        "    int len;",
        "",
        "    buf[sizeof(buf) - 1] = 0;",
        "    va_start(va, format);",
        "#ifdef NO_vsnprintf",
        "#  ifdef HAS_vsprintf_void",
        "    (void)vsprintf(buf, format, va);",
        "    va_end(va);",
        "    for (len = 0; len < sizeof(buf); len++)",
        "        if (buf[len] == 0) break;",
        "#  else",
        "    len = vsprintf(buf, format, va);",
        "    va_end(va);",
        "#  endif",
        "#else",
        "#  ifdef HAS_vsnprintf_void",
        "    (void)vsnprintf(buf, sizeof(buf), format, va);",
        "    va_end(va);",
        "    len = strlen(buf);",
        "#  else",
        "    len = vsnprintf(buf, sizeof(buf), format, va);",
        "    va_end(va);"
      ]
    },
    {
      "file_path": "extlib/zlib/gzio.c",
      "matched_lines": [
        649,
        650,
        655
      ],
      "context_lines": [
        639,
        640,
        641,
        642,
        643,
        644,
        645,
        646,
        647,
        648,
        651,
        652,
        653,
        654,
        656,
        657,
        658,
        659,
        660,
        661,
        662,
        663,
        664,
        665
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/zlib/gzio.c-639-    gzFile file;",
        "extlib/zlib/gzio.c-640-    const char *format;",
        "extlib/zlib/gzio.c-641-    int a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,",
        "extlib/zlib/gzio.c-642-        a11, a12, a13, a14, a15, a16, a17, a18, a19, a20;",
        "extlib/zlib/gzio.c-643-{",
        "extlib/zlib/gzio.c-644-    char buf[Z_PRINTF_BUFSIZE];",
        "extlib/zlib/gzio.c-645-    int len;",
        "extlib/zlib/gzio.c-646-",
        "extlib/zlib/gzio.c-647-    buf[sizeof(buf) - 1] = 0;",
        "extlib/zlib/gzio.c-648-#ifdef NO_snprintf",
        "extlib/zlib/gzio.c:649:#  ifdef HAS_sprintf_void",
        "extlib/zlib/gzio.c:650:    sprintf(buf, format, a1, a2, a3, a4, a5, a6, a7, a8,",
        "extlib/zlib/gzio.c-651-            a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);",
        "extlib/zlib/gzio.c-652-    for (len = 0; len < sizeof(buf); len++)",
        "extlib/zlib/gzio.c-653-        if (buf[len] == 0) break;",
        "extlib/zlib/gzio.c-654-#  else",
        "extlib/zlib/gzio.c:655:    len = sprintf(buf, format, a1, a2, a3, a4, a5, a6, a7, a8,",
        "extlib/zlib/gzio.c-656-                a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);",
        "extlib/zlib/gzio.c-657-#  endif",
        "extlib/zlib/gzio.c-658-#else",
        "extlib/zlib/gzio.c-659-#  ifdef HAS_snprintf_void",
        "extlib/zlib/gzio.c-660-    snprintf(buf, sizeof(buf), format, a1, a2, a3, a4, a5, a6, a7, a8,",
        "extlib/zlib/gzio.c-661-             a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);",
        "extlib/zlib/gzio.c-662-    len = strlen(buf);",
        "extlib/zlib/gzio.c-663-#  else",
        "extlib/zlib/gzio.c-664-    len = snprintf(buf, sizeof(buf), format, a1, a2, a3, a4, a5, a6, a7, a8,",
        "extlib/zlib/gzio.c-665-                 a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);"
      ],
      "raw_content": [
        "    gzFile file;",
        "    const char *format;",
        "    int a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,",
        "        a11, a12, a13, a14, a15, a16, a17, a18, a19, a20;",
        "{",
        "    char buf[Z_PRINTF_BUFSIZE];",
        "    int len;",
        "",
        "    buf[sizeof(buf) - 1] = 0;",
        "#ifdef NO_snprintf",
        "#  ifdef HAS_sprintf_void",
        "    sprintf(buf, format, a1, a2, a3, a4, a5, a6, a7, a8,",
        "            a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);",
        "    for (len = 0; len < sizeof(buf); len++)",
        "        if (buf[len] == 0) break;",
        "#  else",
        "    len = sprintf(buf, format, a1, a2, a3, a4, a5, a6, a7, a8,",
        "                a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);",
        "#  endif",
        "#else",
        "#  ifdef HAS_snprintf_void",
        "    snprintf(buf, sizeof(buf), format, a1, a2, a3, a4, a5, a6, a7, a8,",
        "             a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);",
        "    len = strlen(buf);",
        "#  else",
        "    len = snprintf(buf, sizeof(buf), format, a1, a2, a3, a4, a5, a6, a7, a8,",
        "                 a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);"
      ]
    },
    {
      "file_path": "extlib/zlib/zlib.h",
      "matched_lines": [
        989
      ],
      "context_lines": [
        979,
        980,
        981,
        982,
        983,
        984,
        985,
        986,
        987,
        988,
        990,
        991,
        992,
        993,
        994,
        995,
        996,
        997,
        998,
        999
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/zlib/zlib.h-979-                          deflate code when not needed)",
        "extlib/zlib/zlib.h-980-     17: NO_GZIP -- deflate can't write gzip streams, and inflate can't detect",
        "extlib/zlib/zlib.h-981-                    and decode gzip streams (to avoid linking crc code)",
        "extlib/zlib/zlib.h-982-     18-19: 0 (reserved)",
        "extlib/zlib/zlib.h-983-",
        "extlib/zlib/zlib.h-984-    Operation variations (changes in library functionality):",
        "extlib/zlib/zlib.h-985-     20: PKZIP_BUG_WORKAROUND -- slightly more permissive inflate",
        "extlib/zlib/zlib.h-986-     21: FASTEST -- deflate algorithm with only one, lowest compression level",
        "extlib/zlib/zlib.h-987-     22,23: 0 (reserved)",
        "extlib/zlib/zlib.h-988-",
        "extlib/zlib/zlib.h:989:    The sprintf variant used by gzprintf (zero is best):",
        "extlib/zlib/zlib.h-990-     24: 0 = vs*, 1 = s* -- 1 means limited to 20 arguments after the format",
        "extlib/zlib/zlib.h-991-     25: 0 = *nprintf, 1 = *printf -- 1 means gzprintf() not secure!",
        "extlib/zlib/zlib.h-992-     26: 0 = returns value, 1 = void -- 1 means inferred string length returned",
        "extlib/zlib/zlib.h-993-",
        "extlib/zlib/zlib.h-994-    Remainder:",
        "extlib/zlib/zlib.h-995-     27-31: 0 (reserved)",
        "extlib/zlib/zlib.h-996- */",
        "extlib/zlib/zlib.h-997-",
        "extlib/zlib/zlib.h-998-",
        "extlib/zlib/zlib.h-999-                        /* utility functions */"
      ],
      "raw_content": [
        "                          deflate code when not needed)",
        "     17: NO_GZIP -- deflate can't write gzip streams, and inflate can't detect",
        "                    and decode gzip streams (to avoid linking crc code)",
        "     18-19: 0 (reserved)",
        "",
        "    Operation variations (changes in library functionality):",
        "     20: PKZIP_BUG_WORKAROUND -- slightly more permissive inflate",
        "     21: FASTEST -- deflate algorithm with only one, lowest compression level",
        "     22,23: 0 (reserved)",
        "",
        "    The sprintf variant used by gzprintf (zero is best):",
        "     24: 0 = vs*, 1 = s* -- 1 means limited to 20 arguments after the format",
        "     25: 0 = *nprintf, 1 = *printf -- 1 means gzprintf() not secure!",
        "     26: 0 = returns value, 1 = void -- 1 means inferred string length returned",
        "",
        "    Remainder:",
        "     27-31: 0 (reserved)",
        " */",
        "",
        "",
        "                        /* utility functions */"
      ]
    },
    {
      "file_path": "extlib/zlib/zlib.h",
      "matched_lines": [
        1131
      ],
      "context_lines": [
        1121,
        1122,
        1123,
        1124,
        1125,
        1126,
        1127,
        1128,
        1129,
        1130,
        1132,
        1133,
        1134,
        1135,
        1136,
        1137,
        1138,
        1139,
        1140,
        1141
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/zlib/zlib.h-1121-",
        "extlib/zlib/zlib.h-1122-ZEXTERN int ZEXPORTVA   gzprintf OF((gzFile file, const char *format, ...));",
        "extlib/zlib/zlib.h-1123-/*",
        "extlib/zlib/zlib.h-1124-     Converts, formats, and writes the args to the compressed file under",
        "extlib/zlib/zlib.h-1125-   control of the format string, as in fprintf. gzprintf returns the number of",
        "extlib/zlib/zlib.h-1126-   uncompressed bytes actually written (0 in case of error).  The number of",
        "extlib/zlib/zlib.h-1127-   uncompressed bytes written is limited to 4095. The caller should assure that",
        "extlib/zlib/zlib.h-1128-   this limit is not exceeded. If it is exceeded, then gzprintf() will return",
        "extlib/zlib/zlib.h-1129-   return an error (0) with nothing written. In this case, there may also be a",
        "extlib/zlib/zlib.h-1130-   buffer overflow with unpredictable consequences, which is possible only if",
        "extlib/zlib/zlib.h:1131:   zlib was compiled with the insecure functions sprintf() or vsprintf()",
        "extlib/zlib/zlib.h-1132-   because the secure snprintf() or vsnprintf() functions were not available.",
        "extlib/zlib/zlib.h-1133-*/",
        "extlib/zlib/zlib.h-1134-",
        "extlib/zlib/zlib.h-1135-ZEXTERN int ZEXPORT gzputs OF((gzFile file, const char *s));",
        "extlib/zlib/zlib.h-1136-/*",
        "extlib/zlib/zlib.h-1137-      Writes the given null-terminated string to the compressed file, excluding",
        "extlib/zlib/zlib.h-1138-   the terminating null character.",
        "extlib/zlib/zlib.h-1139-      gzputs returns the number of characters written, or -1 in case of error.",
        "extlib/zlib/zlib.h-1140-*/",
        "extlib/zlib/zlib.h-1141-"
      ],
      "raw_content": [
        "",
        "ZEXTERN int ZEXPORTVA   gzprintf OF((gzFile file, const char *format, ...));",
        "/*",
        "     Converts, formats, and writes the args to the compressed file under",
        "   control of the format string, as in fprintf. gzprintf returns the number of",
        "   uncompressed bytes actually written (0 in case of error).  The number of",
        "   uncompressed bytes written is limited to 4095. The caller should assure that",
        "   this limit is not exceeded. If it is exceeded, then gzprintf() will return",
        "   return an error (0) with nothing written. In this case, there may also be a",
        "   buffer overflow with unpredictable consequences, which is possible only if",
        "   zlib was compiled with the insecure functions sprintf() or vsprintf()",
        "   because the secure snprintf() or vsnprintf() functions were not available.",
        "*/",
        "",
        "ZEXTERN int ZEXPORT gzputs OF((gzFile file, const char *s));",
        "/*",
        "      Writes the given null-terminated string to the compressed file, excluding",
        "   the terminating null character.",
        "      gzputs returns the number of characters written, or -1 in case of error.",
        "*/",
        ""
      ]
    },
    {
      "file_path": "extlib/zlib/zutil.c",
      "matched_lines": [
        91,
        103
      ],
      "context_lines": [
        81,
        82,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        92,
        93,
        94,
        95,
        96,
        97,
        98,
        99,
        100,
        101,
        102,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        111,
        112,
        113
      ],
      "raw_surrounding_git_grep_lines": [
        "extlib/zlib/zutil.c-81-#endif",
        "extlib/zlib/zutil.c-82-#ifdef PKZIP_BUG_WORKAROUND",
        "extlib/zlib/zutil.c-83-    flags += 1L << 20;",
        "extlib/zlib/zutil.c-84-#endif",
        "extlib/zlib/zutil.c-85-#ifdef FASTEST",
        "extlib/zlib/zutil.c-86-    flags += 1L << 21;",
        "extlib/zlib/zutil.c-87-#endif",
        "extlib/zlib/zutil.c-88-#ifdef STDC",
        "extlib/zlib/zutil.c-89-#  ifdef NO_vsnprintf",
        "extlib/zlib/zutil.c-90-        flags += 1L << 25;",
        "extlib/zlib/zutil.c:91:#    ifdef HAS_vsprintf_void",
        "extlib/zlib/zutil.c-92-        flags += 1L << 26;",
        "extlib/zlib/zutil.c-93-#    endif",
        "extlib/zlib/zutil.c-94-#  else",
        "extlib/zlib/zutil.c-95-#    ifdef HAS_vsnprintf_void",
        "extlib/zlib/zutil.c-96-        flags += 1L << 26;",
        "extlib/zlib/zutil.c-97-#    endif",
        "extlib/zlib/zutil.c-98-#  endif",
        "extlib/zlib/zutil.c-99-#else",
        "extlib/zlib/zutil.c-100-        flags += 1L << 24;",
        "extlib/zlib/zutil.c-101-#  ifdef NO_snprintf",
        "extlib/zlib/zutil.c-102-        flags += 1L << 25;",
        "extlib/zlib/zutil.c:103:#    ifdef HAS_sprintf_void",
        "extlib/zlib/zutil.c-104-        flags += 1L << 26;",
        "extlib/zlib/zutil.c-105-#    endif",
        "extlib/zlib/zutil.c-106-#  else",
        "extlib/zlib/zutil.c-107-#    ifdef HAS_snprintf_void",
        "extlib/zlib/zutil.c-108-        flags += 1L << 26;",
        "extlib/zlib/zutil.c-109-#    endif",
        "extlib/zlib/zutil.c-110-#  endif",
        "extlib/zlib/zutil.c-111-#endif",
        "extlib/zlib/zutil.c-112-    return flags;",
        "extlib/zlib/zutil.c-113-}"
      ],
      "raw_content": [
        "#endif",
        "#ifdef PKZIP_BUG_WORKAROUND",
        "    flags += 1L << 20;",
        "#endif",
        "#ifdef FASTEST",
        "    flags += 1L << 21;",
        "#endif",
        "#ifdef STDC",
        "#  ifdef NO_vsnprintf",
        "        flags += 1L << 25;",
        "#    ifdef HAS_vsprintf_void",
        "        flags += 1L << 26;",
        "#    endif",
        "#  else",
        "#    ifdef HAS_vsnprintf_void",
        "        flags += 1L << 26;",
        "#    endif",
        "#  endif",
        "#else",
        "        flags += 1L << 24;",
        "#  ifdef NO_snprintf",
        "        flags += 1L << 25;",
        "#    ifdef HAS_sprintf_void",
        "        flags += 1L << 26;",
        "#    endif",
        "#  else",
        "#    ifdef HAS_snprintf_void",
        "        flags += 1L << 26;",
        "#    endif",
        "#  endif",
        "#endif",
        "    return flags;",
        "}"
      ]
    },
    {
      "file_path": "src/Library/Volume/Volume.h",
      "matched_lines": [
        83
      ],
      "context_lines": [
        73,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        82,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        91,
        92,
        93
      ],
      "raw_surrounding_git_grep_lines": [
        "src/Library/Volume/Volume.h-73-\t\tm_nSliceSize( width*height )",
        "src/Library/Volume/Volume.h-74-\t\t{",
        "src/Library/Volume/Volume.h-75-\t\t\tm_OVMaxValue = 1.0 / ( Scalar( 1 << (sizeof( T )*8) ) - 1.0 );",
        "src/Library/Volume/Volume.h-76-",
        "src/Library/Volume/Volume.h-77-\t\t\tm_pData = new T[m_nDepth*m_nHeight*m_nWidth];",
        "src/Library/Volume/Volume.h-78-",
        "src/Library/Volume/Volume.h-79-\t\t\tfor( unsigned int i=zstart, cnt=0; i<=zend; i++, cnt++ )",
        "src/Library/Volume/Volume.h-80-\t\t\t{",
        "src/Library/Volume/Volume.h-81-\t\t\t\tchar buffer[1024] = {0};",
        "src/Library/Volume/Volume.h-82-",
        "src/Library/Volume/Volume.h:83:\t\t\t\tsprintf( buffer, szFilePattern, i );",
        "src/Library/Volume/Volume.h-84-\t\t\t\tFILE* f = fopen( GlobalMediaPathLocator().Find(buffer).c_str(), \"rb\" );",
        "src/Library/Volume/Volume.h-85-",
        "src/Library/Volume/Volume.h-86-\t\t\t\tif( f ) {",
        "src/Library/Volume/Volume.h-87-\t\t\t\t\tfread( &m_pData[cnt*width*height], sizeof( T ), m_nWidth*m_nHeight, f );",
        "src/Library/Volume/Volume.h-88-\t\t\t\t\tfclose( f );",
        "src/Library/Volume/Volume.h-89-\t\t\t\t}",
        "src/Library/Volume/Volume.h-90-\t\t\t}",
        "src/Library/Volume/Volume.h-91-",
        "src/Library/Volume/Volume.h-92-\t\t\tm_nWidthOV2 = m_nWidth>>1;",
        "src/Library/Volume/Volume.h-93-\t\t\tm_nHeightOV2 = m_nHeight>>1;"
      ],
      "raw_content": [
        "\t\tm_nSliceSize( width*height )",
        "\t\t{",
        "\t\t\tm_OVMaxValue = 1.0 / ( Scalar( 1 << (sizeof( T )*8) ) - 1.0 );",
        "",
        "\t\t\tm_pData = new T[m_nDepth*m_nHeight*m_nWidth];",
        "",
        "\t\t\tfor( unsigned int i=zstart, cnt=0; i<=zend; i++, cnt++ )",
        "\t\t\t{",
        "\t\t\t\tchar buffer[1024] = {0};",
        "",
        "\t\t\t\tsprintf( buffer, szFilePattern, i );",
        "\t\t\t\tFILE* f = fopen( GlobalMediaPathLocator().Find(buffer).c_str(), \"rb\" );",
        "",
        "\t\t\t\tif( f ) {",
        "\t\t\t\t\tfread( &m_pData[cnt*width*height], sizeof( T ), m_nWidth*m_nHeight, f );",
        "\t\t\t\t\tfclose( f );",
        "\t\t\t\t}",
        "\t\t\t}",
        "",
        "\t\t\tm_nWidthOV2 = m_nWidth>>1;",
        "\t\t\tm_nHeightOV2 = m_nHeight>>1;"
      ]
    }
  ]
}