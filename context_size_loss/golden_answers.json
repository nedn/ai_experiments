{
  "snippet_000": "// TODO: Convert sprintf to snprintf in:\n   }\n\n#if defined(_WIN32_WCE)\n   {\n      wchar_t time_buf[29];\n      wsprintf(time_buf, TEXT(\"%d %S %d %02d:%02d:%02d +0000\"),\n          ptime->day % 32, short_months[(ptime->month - 1) % 12],\n        ptime->year, ptime->hour % 24, ptime->minute % 60,\n          ptime->second % 61);\n      WideCharToMultiByte(CP_ACP, 0, time_buf, -1, png_ptr->time_buffer, 29,\n          NULL, NULL);\n   }\n#else\n#ifdef USE_FAR_KEYWORD\n   {\n      char near_time_buf[29];\n      sprintf(near_time_buf, \"%d %s %d %02d:%02d:%02d +0000\",\n          ptime->day % 32, short_months[(ptime->month - 1) % 12],\n          ptime->year, ptime->hour % 24, ptime->minute % 60,\n          ptime->second % 61);\n      png_memcpy(png_ptr->time_buffer, near_time_buf,\n          29*png_sizeof(char));\n   }\n#else\n   sprintf(png_ptr->time_buffer, \"%d %s %d %02d:%02d:%02d +0000\",\n       ptime->day % 32, short_months[(ptime->month - 1) % 12],\n       ptime->year, ptime->hour % 24, ptime->minute % 60,\n       ptime->second % 61);\n#endif\n#endif /* _WIN32_WCE */",
  "snippet_001": "// TODO: Convert sprintf to snprintf in:\n\n#ifdef PNG_DEBUG\n   png_debug(1, \"in png_read_filter_row (pnggccrd.c)\\n\");\n   switch (filter)\n   {\n      case 0: sprintf(filnm, \"none\");\n         break;\n      case 1: sprintf(filnm, \"sub-%s\",\n#if defined(PNG_ASSEMBLER_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)\n#if !defined(PNG_1_0_X)\n        (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_SUB)? \"MMX\" : \n#endif\n#endif\n\"x86\");\n         break;\n      case 2: sprintf(filnm, \"up-%s\",\n#ifdef PNG_ASSEMBLER_CODE_SUPPORTED\n#if !defined(PNG_1_0_X)\n        (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_UP)? \"MMX\" :\n#endif\n#endif\n \"x86\");\n         break;\n      case 3: sprintf(filnm, \"avg-%s\",\n#if defined(PNG_ASSEMBLER_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)\n#if !defined(PNG_1_0_X)\n        (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_AVG)? \"MMX\" :\n#endif\n#endif\n \"x86\");\n         break;\n      case 4: sprintf(filnm, \"Paeth-%s\",\n#if defined(PNG_ASSEMBLER_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)\n#if !defined(PNG_1_0_X)\n        (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_PAETH)? \"MMX\":\n#endif\n#endif\n\"x86\");\n         break;\n      default: sprintf(filnm, \"unknw\");\n         break;\n   }\n   png_debug2(0, \"row_number=%5ld, %5s, \", png_ptr->row_number, filnm);\n   png_debug1(0, \"row=0x%08lx, \", (unsigned long)row);\n   png_debug2(0, \"pixdepth=%2d, bytes=%d, \", (int)row_info->pixel_depth,",
  "snippet_002": "// TODO: Convert sprintf to snprintf in:\n     {\n#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)\n        char msg[80];\n        if (user_png_ver)\n        {\n          sprintf(msg, \"Application was compiled with png.h from libpng-%.20s\",\n             user_png_ver);\n          png_warning(png_ptr, msg);\n        }\n        sprintf(msg, \"Application  is  running with png.c from libpng-%.20s\",\n           png_libpng_ver);\n        png_warning(png_ptr, msg);\n#endif\n#ifdef PNG_ERROR_NUMBERS_SUPPORTED\n        png_ptr->flags=0;",
  "snippet_003": "// TODO: Convert sprintf to snprintf in:\n   {\n      char msg[80];\n      png_ptr->warning_fn=NULL;\n      if (user_png_ver)\n      {\n        sprintf(msg, \"Application was compiled with png.h from libpng-%.20s\",\n           user_png_ver);\n        png_warning(png_ptr, msg);\n      }\n      sprintf(msg, \"Application  is  running with png.c from libpng-%.20s\",\n         png_libpng_ver);\n      png_warning(png_ptr, msg);\n   }\n#endif\n   if(png_sizeof(png_struct) > png_struct_size)",
  "snippet_004": "// TODO: Convert sprintf to snprintf in:\n   if (png_ptr->row_buf == NULL)\n   {\n#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)\n      char msg[50];\n\n      sprintf(msg, \"NULL row buffer for row %ld, pass %d\", png_ptr->row_number,\n         png_ptr->pass);\n      png_error(png_ptr, msg);\n#else\n      png_error(png_ptr, \"NULL row buffer\");\n#endif",
  "snippet_005": "// TODO: Convert sprintf to snprintf in:\n      {\n#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)\n         char umsg[50];\n\n         if (ret == Z_BUF_ERROR)\n            sprintf(umsg,\"Buffer error in compressed datastream in %s chunk\",\n                png_ptr->chunk_name);\n         else if (ret == Z_DATA_ERROR)\n            sprintf(umsg,\"Data error in compressed datastream in %s chunk\",\n                png_ptr->chunk_name);\n         else\n            sprintf(umsg,\"Incomplete compressed datastream in %s chunk\",\n                png_ptr->chunk_name);\n         png_warning(png_ptr, umsg);\n#else\n         png_warning(png_ptr,\n            \"Incomplete compressed datastream in chunk other than IDAT\");",
  "snippet_006": "// TODO: Convert sprintf to snprintf in:\n   else /* if (comp_type != PNG_COMPRESSION_TYPE_BASE) */\n   {\n#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)\n      char umsg[50];\n\n      sprintf(umsg, \"Unknown zTXt compression type %d\", comp_type);\n      png_warning(png_ptr, umsg);\n#else\n      png_warning(png_ptr, \"Unknown zTXt compression type\");\n#endif\n",
  "snippet_007": "// TODO: Convert sprintf to snprintf in:\n\n#ifdef PNG_DEBUG\n   png_debug(1, \"in png_read_filter_row\\n\");\n   switch (filter)\n   {\n      case 0: sprintf(filnm, \"none\");\n         break;\n#if !defined(PNG_1_0_X)\n      case 1: sprintf(filnm, \"sub-%s\",\n        (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_SUB)? \"MMX\" : \"x86\");\n         break;\n      case 2: sprintf(filnm, \"up-%s\",\n        (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_UP)? \"MMX\" : \"x86\");\n         break;\n      case 3: sprintf(filnm, \"avg-%s\",\n        (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_AVG)? \"MMX\" : \"x86\");\n         break;\n      case 4: sprintf(filnm, \"Paeth-%s\",\n        (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_PAETH)? \"MMX\":\"x86\");\n         break;\n#else\n      case 1: sprintf(filnm, \"sub\");\n         break;\n      case 2: sprintf(filnm, \"up\");\n         break;\n      case 3: sprintf(filnm, \"avg\");\n         break;\n      case 4: sprintf(filnm, \"Paeth\");\n         break;\n#endif\n      default: sprintf(filnm, \"unknw\");\n         break;\n   }\n   png_debug2(0,\"row=%5d, %s, \", png_ptr->row_number, filnm);\n   png_debug2(0, \"pd=%2d, b=%d, \", (int)row_info->pixel_depth,\n      (int)((row_info->pixel_depth + 7) >> 3));",
  "snippet_008": "// TODO: Convert sprintf to snprintf in:\n     {\n#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)\n        char msg[80];\n        if (user_png_ver)\n        {\n          sprintf(msg, \"Application was compiled with png.h from libpng-%.20s\",\n             user_png_ver);\n          png_warning(png_ptr, msg);\n        }\n        sprintf(msg, \"Application  is  running with png.c from libpng-%.20s\",\n           png_libpng_ver);\n        png_warning(png_ptr, msg);\n#endif\n#ifdef PNG_ERROR_NUMBERS_SUPPORTED\n        png_ptr->flags=0;",
  "snippet_009": "// TODO: Convert sprintf to snprintf in:\n   {\n      char msg[80];\n      png_ptr->warning_fn=NULL;\n      if (user_png_ver)\n      {\n        sprintf(msg, \"Application was compiled with png.h from libpng-%.20s\",\n           user_png_ver);\n        png_warning(png_ptr, msg);\n      }\n      sprintf(msg, \"Application  is  running with png.c from libpng-%.20s\",\n         png_libpng_ver);\n      png_warning(png_ptr, msg);\n   }\n#endif\n   if(png_sizeof(png_struct) > png_struct_size)",
  "snippet_010": "// TODO: Convert sprintf to snprintf in:\n\n   if (compression >= PNG_TEXT_COMPRESSION_LAST)\n   {\n#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)\n      char msg[50];\n      sprintf(msg, \"Unknown compression type %d\", compression);\n      png_warning(png_ptr, msg);\n#else\n      png_warning(png_ptr, \"Unknown compression type\");\n#endif\n   }",
  "snippet_011": "// TODO: Convert sprintf to snprintf in:\n      if (*kp < 0x20 || (*kp > 0x7E && (png_byte)*kp < 0xA1))\n      {\n#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)\n         char msg[40];\n\n         sprintf(msg, \"invalid keyword character 0x%02X\", *kp);\n         png_warning(png_ptr, msg);\n#else\n         png_warning(png_ptr, \"invalid character in keyword\");\n#endif\n         *dp = ' ';",
  "snippet_012": "// TODO: Convert sprintf to snprintf in:\n   png_byte bunit = unit;\n\n   png_debug(1, \"in png_write_sCAL\\n\");\n\n#if defined(_WIN32_WCE)\n/* sprintf() function is not supported on WindowsCE */\n   {\n      wchar_t wc_buf[32];\n      swprintf(wc_buf, TEXT(\"%12.12e\"), width);\n      WideCharToMultiByte(CP_ACP, 0, wc_buf, -1, wbuf, 32, NULL, NULL);\n      swprintf(wc_buf, TEXT(\"%12.12e\"), height);\n      WideCharToMultiByte(CP_ACP, 0, wc_buf, -1, hbuf, 32, NULL, NULL);\n   }\n#else\n   sprintf(wbuf, \"%12.12e\", width);\n   sprintf(hbuf, \"%12.12e\", height);\n#endif\n   total_len = 1 + png_strlen(wbuf)+1 + png_strlen(hbuf);\n\n   png_debug1(3, \"sCAL total length = %d\\n\", (int)total_len);\n   png_write_chunk_start(png_ptr, (png_bytep)png_sCAL, (png_uint_32)total_len);",
  "snippet_013": "// TODO: Convert sprintf to snprintf in:\n\t}\n\n\t/* note that this name is a special sign to TIFFClose() and\n\t * _TIFFSetupFieldInfo() to free the field\n\t */\n\tsprintf(fld->field_name, \"Tag %d\", (int) tag);\n\n\treturn fld;    \n}\n\n/* vim: set ts=8 sts=8 sw=8 noet: */",
  "snippet_014": "// TODO: Convert sprintf to snprintf in:\n    TIFFDirectory* td = &tif->tif_dir;\n    uint16 photometric;\n    int colorchannels;\n\n    if (!tif->tif_decodestatus) {\n\tsprintf(emsg, \"Sorry, requested compression method is not configured\");\n\treturn (0);\n    }\n    switch (td->td_bitspersample) {\n    case 1: case 2: case 4:\n    case 8: case 16:\n\tbreak;\n    default:\n\tsprintf(emsg, \"Sorry, can not handle images with %d-bit samples\",\n\t    td->td_bitspersample);\n\treturn (0);\n    }\n    colorchannels = td->td_samplesperpixel - td->td_extrasamples;\n    if (!TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric)) {",
  "snippet_015": "// TODO: Convert sprintf to snprintf in:\n\t    break;\n\tcase 3:\n\t    photometric = PHOTOMETRIC_RGB;\n\t    break;\n\tdefault:\n\t    sprintf(emsg, \"Missing needed %s tag\", photoTag);\n\t    return (0);\n\t}\n    }\n    switch (photometric) {\n    case PHOTOMETRIC_MINISWHITE:\n    case PHOTOMETRIC_MINISBLACK:\n    case PHOTOMETRIC_PALETTE:\n\tif (td->td_planarconfig == PLANARCONFIG_CONTIG \n            && td->td_samplesperpixel != 1\n            && td->td_bitspersample < 8 ) {\n\t    sprintf(emsg,\n                    \"Sorry, can not handle contiguous data with %s=%d, \"\n                    \"and %s=%d and Bits/Sample=%d\",\n                    photoTag, photometric,\n                    \"Samples/pixel\", td->td_samplesperpixel,\n                    td->td_bitspersample);",
  "snippet_016": "// TODO: Convert sprintf to snprintf in:\n        ** them.  But for now we won't bother with this. \n        */\n\tbreak;\n    case PHOTOMETRIC_YCBCR:\n\tif (td->td_planarconfig != PLANARCONFIG_CONTIG) {\n\t    sprintf(emsg, \"Sorry, can not handle YCbCr images with %s=%d\",\n\t\t\"Planarconfiguration\", td->td_planarconfig);\n\t    return (0);\n\t}\n\tbreak;\n    case PHOTOMETRIC_RGB: \n\tif (colorchannels < 3) {\n\t    sprintf(emsg, \"Sorry, can not handle RGB image with %s=%d\",\n\t\t\"Color channels\", colorchannels);\n\t    return (0);\n\t}\n\tbreak;\n    case PHOTOMETRIC_SEPARATED:\n\t{\n\t\tuint16 inkset;\n\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_INKSET, &inkset);\n\t\tif (inkset != INKSET_CMYK) {\n\t\t    sprintf(emsg,\n\t\t\t    \"Sorry, can not handle separated image with %s=%d\",\n\t\t\t    \"InkSet\", inkset);\n\t\t    return 0;\n\t\t}\n\t\tif (td->td_samplesperpixel < 4) {\n\t\t    sprintf(emsg,\n\t\t\t    \"Sorry, can not handle separated image with %s=%d\",\n\t\t\t    \"Samples/pixel\", td->td_samplesperpixel);\n\t\t    return 0;\n\t\t}\n\t\tbreak;\n\t}\n    case PHOTOMETRIC_LOGL:\n\tif (td->td_compression != COMPRESSION_SGILOG) {\n\t    sprintf(emsg, \"Sorry, LogL data must have %s=%d\",\n\t\t\"Compression\", COMPRESSION_SGILOG);\n\t    return (0);\n\t}\n\tbreak;\n    case PHOTOMETRIC_LOGLUV:\n\tif (td->td_compression != COMPRESSION_SGILOG &&\n\t\ttd->td_compression != COMPRESSION_SGILOG24) {\n\t    sprintf(emsg, \"Sorry, LogLuv data must have %s=%d or %d\",\n\t\t\"Compression\", COMPRESSION_SGILOG, COMPRESSION_SGILOG24);\n\t    return (0);\n\t}\n\tif (td->td_planarconfig != PLANARCONFIG_CONTIG) {\n\t    sprintf(emsg, \"Sorry, can not handle LogLuv images with %s=%d\",\n\t\t\"Planarconfiguration\", td->td_planarconfig);\n\t    return (0);\n\t}\n\tbreak;\n    case PHOTOMETRIC_CIELAB:\n\tbreak;\n    default:\n\tsprintf(emsg, \"Sorry, can not handle image with %s=%d\",\n\t    photoTag, photometric);\n\treturn (0);\n    }\n    return (1);\n}",
  "snippet_017": "// TODO: Convert sprintf to snprintf in:\n    switch (img->bitspersample) {\n    case 1: case 2: case 4:\n    case 8: case 16:\n\tbreak;\n    default:\n\tsprintf(emsg, \"Sorry, can not handle images with %d-bit samples\",\n\t    img->bitspersample);\n\treturn (0);\n    }\n    img->alpha = 0;\n    TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &img->samplesperpixel);",
  "snippet_018": "// TODO: Convert sprintf to snprintf in:\n\t    break;\n\tcase 3:\n\t    img->photometric = PHOTOMETRIC_RGB;\n\t    break;\n\tdefault:\n\t    sprintf(emsg, \"Missing needed %s tag\", photoTag);\n\t    return (0);\n\t}\n    }\n    switch (img->photometric) {\n    case PHOTOMETRIC_PALETTE:\n\tif (!TIFFGetField(tif, TIFFTAG_COLORMAP,\n\t    &red_orig, &green_orig, &blue_orig)) {\n\t    sprintf(emsg, \"Missing required \\\"Colormap\\\" tag\");\n\t    return (0);\n\t}\n\n        /* copy the colormaps so we can modify them */\n        n_color = (1L << img->bitspersample);\n        img->redcmap = (uint16 *) _TIFFmalloc(sizeof(uint16)*n_color);\n        img->greencmap = (uint16 *) _TIFFmalloc(sizeof(uint16)*n_color);\n        img->bluecmap = (uint16 *) _TIFFmalloc(sizeof(uint16)*n_color);\n        if( !img->redcmap || !img->greencmap || !img->bluecmap ) {\n\t    sprintf(emsg, \"Out of memory for colormap copy\");\n\t    return (0);\n        }\n\n        _TIFFmemcpy( img->redcmap, red_orig, n_color * 2 );\n        _TIFFmemcpy( img->greencmap, green_orig, n_color * 2 );",
  "snippet_019": "// TODO: Convert sprintf to snprintf in:\n    case PHOTOMETRIC_MINISWHITE:\n    case PHOTOMETRIC_MINISBLACK:\n\tif (planarconfig == PLANARCONFIG_CONTIG \n            && img->samplesperpixel != 1\n            && img->bitspersample < 8 ) {\n\t    sprintf(emsg,\n                    \"Sorry, can not handle contiguous data with %s=%d, \"\n                    \"and %s=%d and Bits/Sample=%d\",\n                    photoTag, img->photometric,\n                    \"Samples/pixel\", img->samplesperpixel,\n                    img->bitspersample);\n\t    return (0);\n\t}\n\tbreak;\n    case PHOTOMETRIC_YCBCR:\n\tif (planarconfig != PLANARCONFIG_CONTIG) {\n\t    sprintf(emsg, \"Sorry, can not handle YCbCr images with %s=%d\",\n\t\t\"Planarconfiguration\", planarconfig);\n\t    return (0);\n\t}\n\t/* It would probably be nice to have a reality check here. */\n\tif (planarconfig == PLANARCONFIG_CONTIG)",
  "snippet_020": "// TODO: Convert sprintf to snprintf in:\n                    break;\n\t    }\n\tbreak;\n    case PHOTOMETRIC_RGB: \n\tif (colorchannels < 3) {\n\t    sprintf(emsg, \"Sorry, can not handle RGB image with %s=%d\",\n\t\t\"Color channels\", colorchannels);\n\t    return (0);\n\t}\n\tbreak;\n    case PHOTOMETRIC_SEPARATED: {\n\tuint16 inkset;\n\tTIFFGetFieldDefaulted(tif, TIFFTAG_INKSET, &inkset);\n\tif (inkset != INKSET_CMYK) {\n\t    sprintf(emsg, \"Sorry, can not handle separated image with %s=%d\",\n\t\t\"InkSet\", inkset);\n\t    return (0);\n\t}\n\tif (img->samplesperpixel < 4) {\n\t    sprintf(emsg, \"Sorry, can not handle separated image with %s=%d\",\n\t\t\"Samples/pixel\", img->samplesperpixel);\n\t    return (0);\n\t}\n\tbreak;\n    }\n    case PHOTOMETRIC_LOGL:\n\tif (compress != COMPRESSION_SGILOG) {\n\t    sprintf(emsg, \"Sorry, LogL data must have %s=%d\",\n\t\t\"Compression\", COMPRESSION_SGILOG);\n\t    return (0);\n\t}\n\tTIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_8BIT);\n\timg->photometric = PHOTOMETRIC_MINISBLACK;\t/* little white lie */\n\timg->bitspersample = 8;\n\tbreak;\n    case PHOTOMETRIC_LOGLUV:\n\tif (compress != COMPRESSION_SGILOG && compress != COMPRESSION_SGILOG24) {\n\t    sprintf(emsg, \"Sorry, LogLuv data must have %s=%d or %d\",\n\t\t\"Compression\", COMPRESSION_SGILOG, COMPRESSION_SGILOG24);\n\t    return (0);\n\t}\n\tif (planarconfig != PLANARCONFIG_CONTIG) {\n\t    sprintf(emsg, \"Sorry, can not handle LogLuv images with %s=%d\",\n\t\t\"Planarconfiguration\", planarconfig);\n\t    return (0);\n\t}\n\tTIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_8BIT);\n\timg->photometric = PHOTOMETRIC_RGB;\t\t/* little white lie */\n\timg->bitspersample = 8;\n\tbreak;\n    case PHOTOMETRIC_CIELAB:\n\tbreak;\n    default:\n\tsprintf(emsg, \"Sorry, can not handle image with %s=%d\",\n\t    photoTag, img->photometric);\n\treturn (0);\n    }\n    img->Map = NULL;\n    img->BWmap = NULL;",
  "snippet_021": "// TODO: Convert sprintf to snprintf in:\n    img->isContig =\n\t!(planarconfig == PLANARCONFIG_SEPARATE && colorchannels > 1);\n    if (img->isContig) {\n\timg->get = TIFFIsTiled(tif) ? gtTileContig : gtStripContig;\n\tif (!pickTileContigCase(img)) {\n\t\tsprintf(emsg, \"Sorry, can not handle image\");\n\t\treturn 0;\n\t}\n    } else {\n\timg->get = TIFFIsTiled(tif) ? gtTileSeparate : gtStripSeparate;\n\tif (!pickTileSeparateCase(img)) {\n\t\tsprintf(emsg, \"Sorry, can not handle image\");\n\t\treturn 0;\n\t}\n    }\n    return 1;\n}",
  "snippet_022": "// TODO: Convert sprintf to snprintf in:\nwin3WarningHandler(const char* module, const char* fmt, va_list ap)\n{\n\tchar e[512] = { '\\0' };\n\tif (module != NULL)\n\t\tstrcat(strcpy(e, module), \":\");\n\tvsprintf(e+strlen(e), fmt, ap);\n\tstrcat(e, \".\");\n\tMessageBox(GetActiveWindow(), e, \"LibTIFF Warning\",\n\t    MB_OK|MB_ICONEXCLAMATION);\n}\nTIFFErrorHandler _TIFFwarningHandler = win3WarningHandler;",
  "snippet_023": "// TODO: Convert sprintf to snprintf in:\nwin3ErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n\tchar e[512] = { '\\0' };\n\tif (module != NULL)\n\t\tstrcat(strcpy(e, module), \":\");\n\tvsprintf(e+strlen(e), fmt, ap);\n\tstrcat(e, \".\");\n\tMessageBox(GetActiveWindow(), e, \"LibTIFF Error\", MB_OK|MB_ICONSTOP);\n}\nTIFFErrorHandler _TIFFerrorHandler = win3ErrorHandler;",
  "snippet_024": "// TODO: Convert sprintf to snprintf in:\n\tLPCTSTR szDefaultModule = \"LIBTIFF\";\n\tLPCTSTR szTmpModule = (module == NULL) ? szDefaultModule : module;\n\tif ((szTitle = (LPTSTR)LocalAlloc(LMEM_FIXED, (strlen(szTmpModule) +\n\t\tstrlen(szTitleText) + strlen(fmt) + 128)*sizeof(char))) == NULL)\n\t\treturn;\n\tsprintf(szTitle, szTitleText, szTmpModule);\n\tszTmp = szTitle + (strlen(szTitle)+2)*sizeof(char);\n\tvsprintf(szTmp, fmt, ap);\n\tMessageBoxA(GetFocus(), szTmp, szTitle, MB_OK | MB_ICONINFORMATION);\n\tLocalFree(szTitle);\n\treturn;\n#else\n\tif (module != NULL)",
  "snippet_025": "// TODO: Convert sprintf to snprintf in:\n\tLPCTSTR szDefaultModule = \"LIBTIFF\";\n\tLPCTSTR szTmpModule = (module == NULL) ? szDefaultModule : module;\n\tif ((szTitle = (LPTSTR)LocalAlloc(LMEM_FIXED, (strlen(szTmpModule) +\n\t\tstrlen(szTitleText) + strlen(fmt) + 128)*sizeof(char))) == NULL)\n\t\treturn;\n\tsprintf(szTitle, szTitleText, szTmpModule);\n\tszTmp = szTitle + (strlen(szTitle)+2)*sizeof(char);\n\tvsprintf(szTmp, fmt, ap);\n\tMessageBoxA(GetFocus(), szTmp, szTitle, MB_OK | MB_ICONEXCLAMATION);\n\tLocalFree(szTitle);\n\treturn;\n#else\n\tif (module != NULL)",
  "snippet_026": "// TODO: Convert sprintf to snprintf in:\n    const char *mode;\n{\n    char name[46];      /* allow for up to 128-bit integers */\n\n    if (fd < 0) return (gzFile)Z_NULL;\n    sprintf(name, \"<fd:%d>\", fd); /* for debugging */\n\n    return gz_open (name, mode, fd);\n}\n\n/* ===========================================================================",
  "snippet_027": "// TODO: Convert sprintf to snprintf in:\n    int len;\n\n    buf[sizeof(buf) - 1] = 0;\n    va_start(va, format);\n#ifdef NO_vsnprintf\n#  ifdef HAS_vsprintf_void\n    (void)vsprintf(buf, format, va);\n    va_end(va);\n    for (len = 0; len < sizeof(buf); len++)\n        if (buf[len] == 0) break;\n#  else\n    len = vsprintf(buf, format, va);\n    va_end(va);\n#  endif\n#else\n#  ifdef HAS_vsnprintf_void\n    (void)vsnprintf(buf, sizeof(buf), format, va);",
  "snippet_028": "// TODO: Convert sprintf to snprintf in:\n    char buf[Z_PRINTF_BUFSIZE];\n    int len;\n\n    buf[sizeof(buf) - 1] = 0;\n#ifdef NO_snprintf\n#  ifdef HAS_sprintf_void\n    sprintf(buf, format, a1, a2, a3, a4, a5, a6, a7, a8,\n            a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);\n    for (len = 0; len < sizeof(buf); len++)\n        if (buf[len] == 0) break;\n#  else\n    len = sprintf(buf, format, a1, a2, a3, a4, a5, a6, a7, a8,\n                a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);\n#  endif\n#else\n#  ifdef HAS_snprintf_void\n    snprintf(buf, sizeof(buf), format, a1, a2, a3, a4, a5, a6, a7, a8,",
  "snippet_029": "// TODO: Convert sprintf to snprintf in:\n    Operation variations (changes in library functionality):\n     20: PKZIP_BUG_WORKAROUND -- slightly more permissive inflate\n     21: FASTEST -- deflate algorithm with only one, lowest compression level\n     22,23: 0 (reserved)\n\n    The sprintf variant used by gzprintf (zero is best):\n     24: 0 = vs*, 1 = s* -- 1 means limited to 20 arguments after the format\n     25: 0 = *nprintf, 1 = *printf -- 1 means gzprintf() not secure!\n     26: 0 = returns value, 1 = void -- 1 means inferred string length returned\n\n    Remainder:",
  "snippet_030": "// TODO: Convert sprintf to snprintf in:\n   uncompressed bytes actually written (0 in case of error).  The number of\n   uncompressed bytes written is limited to 4095. The caller should assure that\n   this limit is not exceeded. If it is exceeded, then gzprintf() will return\n   return an error (0) with nothing written. In this case, there may also be a\n   buffer overflow with unpredictable consequences, which is possible only if\n   zlib was compiled with the insecure functions sprintf() or vsprintf()\n   because the secure snprintf() or vsnprintf() functions were not available.\n*/\n\nZEXTERN int ZEXPORT gzputs OF((gzFile file, const char *s));\n/*",
  "snippet_031": "// TODO: Convert sprintf to snprintf in:\n    flags += 1L << 21;\n#endif\n#ifdef STDC\n#  ifdef NO_vsnprintf\n        flags += 1L << 25;\n#    ifdef HAS_vsprintf_void\n        flags += 1L << 26;\n#    endif\n#  else\n#    ifdef HAS_vsnprintf_void\n        flags += 1L << 26;",
  "snippet_032": "// TODO: Convert sprintf to snprintf in:\n#  endif\n#else\n        flags += 1L << 24;\n#  ifdef NO_snprintf\n        flags += 1L << 25;\n#    ifdef HAS_sprintf_void\n        flags += 1L << 26;\n#    endif\n#  else\n#    ifdef HAS_snprintf_void\n        flags += 1L << 26;",
  "snippet_033": "// TODO: Convert sprintf to snprintf in:\n\t\t// to change the existing camera setting's parameters\n\t\tchar val[256] = {0};\n\n\t\t// Location\n\t\t{\n\t\t\tsprintf( val, \"%lf %lf %lf\", loc[0], loc[1], loc[2] );\n\t\t\tRISE::IKeyframeParameter* p = pCamera->KeyframeFromParameters( \"location\", val );\n\t\t\tif( p ) {\n\t\t\t\tpCamera->SetIntermediateValue( *p );\n\t\t\t\tp->release();\n\t\t\t}\n\t\t}\n\n\t\t// Look at\n\t\t{\n\t\t\tsprintf( val, \"%lf %lf %lf\", lookat[0], lookat[1], lookat[2] );\n\t\t\tRISE::IKeyframeParameter* p = pCamera->KeyframeFromParameters( \"lookat\", val );\n\t\t\tif( p ) {\n\t\t\t\tpCamera->SetIntermediateValue( *p );\n\t\t\t\tp->release();\n\t\t\t}\n\t\t}\n\n\t\t// Up vector\n\t\t{\n\t\t\tsprintf( val, \"%lf %lf %lf\", up[0], up[1], up[2] );\n\t\t\tRISE::IKeyframeParameter* p = pCamera->KeyframeFromParameters( \"up\", val );\n\t\t\tif( p ) {\n\t\t\t\tpCamera->SetIntermediateValue( *p );\n\t\t\t\tp->release();\n\t\t\t}\n\t\t}\n\n\t\t// FOV\n\t\t{\n\t\t\tsprintf( val, \"%lf\", fov* RAD_TO_DEG );\n\t\t\tRISE::IKeyframeParameter* p = pCamera->KeyframeFromParameters( \"fov\", val );\n\t\t\tif( p ) {\n\t\t\t\tpCamera->SetIntermediateValue( *p );\n\t\t\t\tp->release();\n\t\t\t}\n\t\t}\n\n\t\t// Width\n\t\t{\n\t\t\tsprintf( val, \"%u\", width );\n\t\t\tRISE::IKeyframeParameter* p = pCamera->KeyframeFromParameters( \"width\", val );\n\t\t\tif( p ) {\n\t\t\t\tpCamera->SetIntermediateValue( *p );\n\t\t\t\tp->release();\n\t\t\t}\n\t\t}\n\n\t\t// Height\n\t\t{\n\t\t\tsprintf( val, \"%u\", height );\n\t\t\tRISE::IKeyframeParameter* p = pCamera->KeyframeFromParameters( \"height\", val );\n\t\t\tif( p ) {\n\t\t\t\tpCamera->SetIntermediateValue( *p );\n\t\t\t\tp->release();\n\t\t\t}",
  "snippet_034": "// TODO: Convert sprintf to snprintf in:\n\t\tif( it != geoms.end() ) {\n\t\t\t// Instance of object already exists!\n\t\t\tstrcpy( geomname, it->second.c_str() );\n\t\t} else {\n\t\t\t// Create the geometry instance \n\t\t\tsprintf( geomname, \"Geom::%s\", pInst->GetName() );\n\n\t\t\tMAXGeometry* pGeometry = new MAXGeometry( pInst );\n\t\t\tRISE::GlobalLog()->PrintNew( pGeometry, __FILE__, __LINE__, \"MAX geometry\" );\n\t\t\tpJob->GetGeometries()->AddItem( pGeometry, geomname );\n\t\t\tpGeometry->release();",
  "snippet_035": "// TODO: Convert sprintf to snprintf in:\n\t\t\t\t\t\t\tstrcat( rs, \"::specular\" );\n\t\t\t\t\t\t\tdouble s[3] = {specular.r*shininessStrength, specular.g*shininessStrength, specular.b*shininessStrength};\n\t\t\t\t\t\t\tpJob->AddUniformColorPainter( rs, s, \"RGB\" );\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar phong[256] = {0};\n\t\t\t\t\t\t\tsprintf( phong, \"%f\", shininess*100.0 );\n\n\t\t\t\t\t\t\tpJob->AddIsotropicPhongMaterial( material_name, rd, rs, phong );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpJob->AddLambertianMaterial( material_name, rd );\n\t\t\t\t\t\t}",
  "snippet_036": "// TODO: Convert sprintf to snprintf in:\n\t\t\tconst double intensity = light->pDesc->ls.intens * PI;\n\n\t\t\tdouble srgb[3] = {col.r,col.g,col.b};\n\n\t\t\tchar lightname[256] = {0};\n\t\t\tsprintf( lightname, \"light%d\", i );\n\n\t\t\tif( light->pDesc->ls.type == OMNI_LGT )\n\t\t\t{\n\t\t\t\t// OMNI Light --------------\n\t\t\t\tdouble pos[3] = {p.x,p.y,p.z};",
  "snippet_037": "// TODO: Convert sprintf to snprintf in:\n\t\t\t{\n\t\t\t\tchar fname[1024] = {0};\n\n\t\t\t\tIRasterizerOutput* fro = 0;\n\n\t\t\t\tsprintf( fname, \"%s_%.5d\", szOutputFileName, id );\n\t\t\t\tRISE_API_CreateFileRasterizerOutput( &fro, fname, false, 2, 16, eColorSpace_ProPhotoRGB );\n\n\t\t\t\tfro->OutputImage( *pOutputImage, 0, 0 );\n\t\t\t\tfro->release();\n\t\t\t}",
  "snippet_038": "// TODO: Convert sprintf to snprintf in:\n\t\t\t\tunsigned int\t\tms = timeforTask % 1000;\n\n\t\t\t\tchar buf[1024] = {0};\n\t\t\t\tstrcat( buf, \"Total Rasterization Time: \" );\n\t\t\t\tchar daybuf[32] = {0};\n\t\t\t\tsprintf( daybuf, \"%d days \", days );\n\t\t\t\tchar hourbuf[32] = {0};\n\t\t\t\tsprintf( hourbuf, \"%d hours \", hours );\n\t\t\t\tchar minbuf[32] = {0};\n\t\t\t\tsprintf( minbuf, \"%d minutes \", mins );\n\t\t\t\tchar secbuf[32] = {0};\n\t\t\t\tsprintf( secbuf, \"%d seconds \", secs );\n\t\t\t\tchar msbuf[32] = {0};\n\t\t\t\tsprintf( msbuf, \"%d ms\", ms );\n\n\t\t\t\tif( days ) {\n\t\t\t\t\tstrcat( buf, daybuf );\n\t\t\t\t}\n",
  "snippet_039": "// TODO: Convert sprintf to snprintf in:\n\t\t\t\t{\n\t\t\t\t\tchar fname[1024] = {0};\n\n\t\t\t\t\tIRasterizerOutput* fro = 0;\n\n\t\t\t\t\tsprintf( fname, \"%s-sRGB\", szOutputFileName );\n\t\t\t\t\tRISE_API_CreateFileRasterizerOutput( &fro, fname, false, 2, 8, eColorSpace_sRGB );\n\n\t\t\t\t\tfro->OutputImage( *pOutputImage, 0, 0 );\n\t\t\t\t\tfro->release();\n\n\t\t\t\t\tsprintf( fname, \"%s-ProPhoto\", szOutputFileName );\n\t\t\t\t\tRISE_API_CreateFileRasterizerOutput( &fro, fname, false, 2, 16, eColorSpace_ProPhotoRGB );\n\n\t\t\t\t\tfro->OutputImage( *pOutputImage, 0, 0 );\n\t\t\t\t\tfro->release();\t\t\t\t\n\t\t\t\t}",
  "snippet_040": "// TODO: Convert sprintf to snprintf in:\n\t\t\t\tunsigned int\t\tms = timeforTask % 1000;\n\n\t\t\t\tchar buf[1024] = {0};\n\t\t\t\tstrcat( buf, \"Total Rasterization Time: \" );\n\t\t\t\tchar daybuf[32] = {0};\n\t\t\t\tsprintf( daybuf, \"%d days \", days );\n\t\t\t\tchar hourbuf[32] = {0};\n\t\t\t\tsprintf( hourbuf, \"%d hours \", hours );\n\t\t\t\tchar minbuf[32] = {0};\n\t\t\t\tsprintf( minbuf, \"%d minutes \", mins );\n\t\t\t\tchar secbuf[32] = {0};\n\t\t\t\tsprintf( secbuf, \"%d seconds \", secs );\n\t\t\t\tchar msbuf[32] = {0};\n\t\t\t\tsprintf( msbuf, \"%d ms\", ms );\n\n\t\t\t\tif( days ) {\n\t\t\t\t\tstrcat( buf, daybuf );\n\t\t\t\t}\n",
  "snippet_041": "// TODO: Convert sprintf to snprintf in:\n\t\tunsigned int\t\tms = duration % 1000;\n\n\t\tchar buf[1024] = {0};\n\t\tstrcat( buf, \"Predicted Rasterization Time: \" );\n\t\tchar daybuf[32] = {0};\n\t\tsprintf( daybuf, \"%d days \", days );\n\t\tchar hourbuf[32] = {0};\n\t\tsprintf( hourbuf, \"%d hours \", hours );\n\t\tchar minbuf[32] = {0};\n\t\tsprintf( minbuf, \"%d minutes \", mins );\n\t\tchar secbuf[32] = {0};\n\t\tsprintf( secbuf, \"%d seconds \", secs );\n\t\tchar msbuf[32] = {0};\n\t\tsprintf( msbuf, \"%d ms\", ms );\n\n\t\tif( days ) {\n\t\t\tstrcat( buf, daybuf );\n\t\t}\n",
  "snippet_042": "// TODO: Convert sprintf to snprintf in:\n\tunsigned int\t\tms = duration % 1000;\n\n\tchar buf[1024] = {0};\n\tstrcat( buf, \"Total Rasterization Time: \" );\n\tchar daybuf[32] = {0};\n\tsprintf( daybuf, \"%d days \", days );\n\tchar hourbuf[32] = {0};\n\tsprintf( hourbuf, \"%d hours \", hours );\n\tchar minbuf[32] = {0};\n\tsprintf( minbuf, \"%d minutes \", mins );\n\tchar secbuf[32] = {0};\n\tsprintf( secbuf, \"%d seconds \", secs );\n\tchar msbuf[32] = {0};\n\tsprintf( msbuf, \"%d ms\", ms );\n\n\tif( days ) {\n\t\tstrcat( buf, daybuf );\n\t}\n",
  "snippet_043": "// TODO: Convert sprintf to snprintf in:\n\tunsigned int\t\tms = duration % 1000;\n\n\tchar buf[1024] = {0};\n\tstrcat( buf, \"Total Rasterization Time: \" );\n\tchar daybuf[32] = {0};\n\tsprintf( daybuf, \"%d days \", days );\n\tchar hourbuf[32] = {0};\n\tsprintf( hourbuf, \"%d hours \", hours );\n\tchar minbuf[32] = {0};\n\tsprintf( minbuf, \"%d minutes \", mins );\n\tchar secbuf[32] = {0};\n\tsprintf( secbuf, \"%d seconds \", secs );\n\tchar msbuf[32] = {0};\n\tsprintf( msbuf, \"%d ms\", ms );\n\n\tif( days ) {\n\t\tstrcat( buf, daybuf );\n\t}\n",
  "snippet_044": "// TODO: Convert sprintf to snprintf in:\n\t\tbreak;\n\t}\n\n\t// assemble together\n\tchar evaluated[64] = {0};\n\tsprintf( evaluated, \"%.12f\", val );\n\n\tprocessed.append( evaluated );\n\tprocessed.append( str.substr( y+1, str.length()-1 ) );\n\n\ttoken = String(processed.c_str());",
  "snippet_045": "// TODO: Convert sprintf to snprintf in:\n\tif( expr.error() ) {\n\t\treturn false;\n\t}\n\n\tchar evaluated[64] = {0};\n\tsprintf( evaluated, \"%.12f\", expr.eval() );\n\n\ttoken = String(evaluated);\n\treturn true;\n}\n",
  "snippet_046": "// TODO: Convert sprintf to snprintf in:\n\t\t}\n\n\t\t// Re-assemble the string\n\t\tchar buf[64] = {0};\n\t\tif( macro_char == '@' ) {\n\t\t\tsprintf( buf, \"%.12f\", it->second );\n\t\t} else {\n\t\t\tsprintf( buf, \"%.4d\", (int)it->second );\n\t\t}\n\t\tprocessed.append( buf );\n\n\t\tif( x<str.size() ) {\n\t\t\tprocessed.append( str.substr( x, str.size() ) );",
  "snippet_047": "// TODO: Convert sprintf to snprintf in:\n//  License Information: Please see the attached LICENSE.TXT file\n//\n//////////////////////////////////////////////////////////////////////\n\n#include \"pch.h\"\n#include <stdio.h>\t\t\t\t\t// for sprintf\n#include <string.h>\t\t\t\t\t// for strlen and strncmp\n#include \"HDRWriter.h\"\n#include \"../Interfaces/ILog.h\"\n#include \"../Version.h\"\n",
  "snippet_048": "// TODO: Convert sprintf to snprintf in:\n\t// Build the header\n\tchar szHeader[2048] = {0};\n\t{\n\t\tstatic const char * szSignature = \"#?RADIANCE\\n\";\n\t\tchar szWhoWroteIt[256] = {0};\n\t\tsprintf( szWhoWroteIt, \"# Generated by R.I.S.E. v%d.%d.%d build %d\\n\", RISE_VER_MAJOR_VERSION, RISE_VER_MINOR_VERSION, RISE_VER_REVISION_VERSION, RISE_VER_BUILD_VERSION );\n\t\tstatic const char * szImageType = \"FORMAT=32-bit_rle_rgbe\\n\\n\";\n\t\tchar szImageDimensions[256] = {0};\n\t\tsprintf( szImageDimensions,\"-Y %d +X %d\\n\", height, width );\n\n\t\tstrcpy( szHeader, szSignature );\n\t\tstrcat( szHeader, szWhoWroteIt );\n\t\tstrcat( szHeader, szImageType );\n\t\tstrcat( szHeader, szImageDimensions );",
  "snippet_049": "// TODO: Convert sprintf to snprintf in:\nvoid PPMWriter::BeginWrite( const unsigned int width, const unsigned int height )\n{\n\t// Write the header\n\t// Get a string with the header\n\tchar\theader[256] = {0};\n\tsprintf( header, \"P6\\n%d %d\\n255\\n\", width, height );\n\n\t// Make sure the buffer is the correct size\n\tpWriteBuffer.Resize( strlen( header ) + width*height*3 );\n\n\t// Copy the header",
  "snippet_050": "// TODO: Convert sprintf to snprintf in:\n//  License Information: Please see the attached LICENSE.TXT file\n//\n//////////////////////////////////////////////////////////////////////\n\n#include \"pch.h\"\n#include <stdio.h>\t\t\t\t\t// for sprintf\n#include <string.h>\t\t\t\t\t// for strlen and strncmp\n#include \"RGBEAWriter.h\"\n#include \"../Interfaces/ILog.h\"\n#include \"../Version.h\"\n",
  "snippet_051": "// TODO: Convert sprintf to snprintf in:\n\t// Build the header\n\tchar szHeader[2048] = {0};\n\t{\n\t\tstatic const char * szSignature = \"#?RGBEA\\n\";\n\t\tchar szWhoWroteIt[256] = {0};\n\t\tsprintf( szWhoWroteIt, \"# Generated by R.I.S.E. v%d.%d.%d build %d\\n\", RISE_VER_MAJOR_VERSION, RISE_VER_MINOR_VERSION, RISE_VER_REVISION_VERSION, RISE_VER_BUILD_VERSION );\n\t\tstatic const char * szImageType = \"FORMAT=64-bit_rle_rgbea\\n\\n\";\n\t\tchar szImageDimensions[256] = {0};\n\t\tsprintf( szImageDimensions,\"-Y %d +X %d\\n\", height, width );\n\n\t\tstrcpy( szHeader, szSignature );\n\t\tstrcat( szHeader, szWhoWroteIt );\n\t\tstrcat( szHeader, szImageType );\n\t\tstrcat( szHeader, szImageDimensions );",
  "snippet_052": "// TODO: Convert sprintf to snprintf in:\n\tIRasterImageWriter*\t\tpWriter = 0;\n\n\tchar\tbuf[2048];\n\n\tif( bMultiple ) {\n\t\tsprintf( buf, \"%s%.4d.%s\", szPattern, frame, extensions[type] );\n\t} else {\n\t\tsprintf( buf, \"%s.%s\", szPattern, extensions[type] );\n\t}\n\n\tDiskFileWriteBuffer*\t\tmb = new DiskFileWriteBuffer( buf );\n\t\n\tif( !mb->ReadyToWrite() ) {",
  "snippet_053": "// TODO: Convert sprintf to snprintf in:\n\n\t\tsafe_release( mb );\n\n\t\tconst FileRasterizerOutput* pMe = this;\n\t\tif( bMultiple ) {\n\t\t\tsprintf( buf, \"fro_temp_%d_%.4d.%s\", VoidPtrToUInt((void*)pMe), frame, extensions[type] );\n\t\t} else {\n\t\t\tsprintf( buf, \"fro_temp_%d.%s\", VoidPtrToUInt((void*)pMe), extensions[type] );\n\t\t}\n\n\t\tmb = new DiskFileWriteBuffer( buf );\n\n\t\t// If that doesn't work either we are just screwed",
  "snippet_054": "// TODO: Convert sprintf to snprintf in:\n\t\t\tmemset( &pBits[y*width*4+x*4+2], 0, 1 );\n\t\t}\n\t}\n\t\n\tchar buf[_MAX_PATH] = {0};\n\tsprintf( buf, \"RISE_Neverset_Thread_Handle_%d_%d\", GetTickCount(), rand() );\n\thStop = CreateEvent( 0, FALSE, FALSE, buf );\n\n\t// We need to create a message pump so that this window can keep processing messages\n\thThread = CreateThread( 0, 0, WindowMessagePump, (LPVOID)this, 0, 0 );\n}",
  "snippet_055": "// TODO: Convert sprintf to snprintf in:\n\t// that requires a unique name for this particular context... <sigh>\n\n\thInstance = GetModuleHandle( NULL );\n\n\tszClassName[0] = 0;\n\tsprintf( szClassName, \"RISE::Win32Context::%d::%d\", GetTickCount(), rand() );\n\n\tWNDCLASSEX\t\twc = {\tsizeof(WNDCLASSEX),\n\t\t\t\t\t\t\tCS_CLASSDC,\n\t\t\t\t\t\t\tMsgProc,\n\t\t\t\t\t\t\t0L, 0L, ",
  "snippet_056": "// TODO: Convert sprintf to snprintf in:\n\n\terror = WSAStartup( d_winsockVersion, &d_winsockData );\n\tif( error == SOCKET_ERROR )\n\t{\n\t\tif( error == WSAVERNOTSUPPORTED ) {\n\t\t\tsprintf( buffer, \"WSAStartup error.\\nRequested Winsock v%d.%d, found v%d.%d.\",\n\t\t\tWINSOCK_MAJOR_VERSION, WINSOCK_MINOR_VERSION,\n\t\t\tLOBYTE( d_winsockData.wVersion ), HIBYTE( d_winsockData.wVersion ) );\n\t\t\tWSACleanup();\n\t\t} else {\n\t\t\tsprintf( buffer, \"WSAStartup error (%d)\", WSAGetLastError() );\n\t\t}\n\n\t\tGlobalLog()->PrintSourceError( buffer, __FILE__, __LINE__ );\n\t\treturn false;\n\t}",
  "snippet_057": "// TODO: Convert sprintf to snprintf in:\n\n\t\t\tfor( unsigned int i=zstart, cnt=0; i<=zend; i++, cnt++ )\n\t\t\t{\n\t\t\t\tchar buffer[1024] = {0};\n\n\t\t\t\tsprintf( buffer, szFilePattern, i );\n\t\t\t\tFILE* f = fopen( GlobalMediaPathLocator().Find(buffer).c_str(), \"rb\" );\n\n\t\t\t\tif( f ) {\n\t\t\t\t\tfread( &m_pData[cnt*width*height], sizeof( T ), m_nWidth*m_nHeight, f );\n\t\t\t\t\tfclose( f );",
  "snippet_058": "// TODO: Convert sprintf to snprintf in:\n\t{\n\t\tpMesh = new PRISEMeshGeometry(0,0,0,0);\n\t\tGlobalLog()->PrintNew( pMesh, __FILE__, __LINE__, \"geometry\" );\n\n\t\tchar szModelFileName[1024] = {0};\n\t\tsprintf( szModelFileName, \"%s_%d.prisemesh\", sceneModels.front().szFilename.c_str(), -1 );\n\n\t\tImplementation::MemoryBuffer*\t\t\tpBuffer = new Implementation::MemoryBuffer( szModelFileName );\n\t\tGlobalLog()->PrintNew( pBuffer, __FILE__, __LINE__, \"buffer\" );\n\n\t\tpMesh->Deserialize( *pBuffer );",
  "snippet_059": "// TODO: Convert sprintf to snprintf in:\n\t\tret = TrySendMessage( eMessage_ModelCount, true );\n\n\t\tstd::deque<MODEL_INFO>::const_iterator\tit;\n\t\tfor( it=szModels.begin(); it!=szModels.end(); it++ ) {\n\t\t\tchar szModelFileName[1024] = {0};\n\t\t\tsprintf( szModelFileName, \"%s_%d.prisemesh\", it->szFilename.c_str(), nWorkerID );\n\n\t\t\tunsigned int length = strlen(szModelFileName); \n\t\t\tunsigned int matlength = strlen(it->material.c_str());\n\t\t\tpSendBuffer->Resize( sizeof( Point3D ) + sizeof( Vector3D ) + length + matlength + 2, true );\n\t\t\tpSendBuffer->seek( IBuffer::START, 0 );",
  "snippet_060": "// TODO: Convert sprintf to snprintf in:\n\n\t// Disable aspects of the logger, so that different processes don't conflict on the same log file\n\tGlobalLogPriv()->RemoveAllPrinters();\n\n\tchar buf[1024];\n\tsprintf( buf, \"PRISE_Worker_Log_Proc%d.txt\", rank );\n\tstd::ofstream*\t\tfs = new std::ofstream( buf );\n\tStreamPrinter*\t\tpB = new StreamPrinter( fs, true );\n\tGlobalLog()->PrintNew( pB, __FILE__, __LINE__, \"file stream printer\" );\n\tGlobalLogPriv()->AddPrinter( pB );\n\tpB->RemoveRef();",
  "snippet_061": "// TODO: Convert sprintf to snprintf in:\n\n\tConsoleWin32* pA = new ConsoleWin32( eLog_Win32Console, TYPICAL_PRIORITY, HIGHEST_PRIORITY );\n\tGlobalLog()->PrintNew( pA, __FILE__, __LINE__, \"Win32 Console printer\" );\n\tconst char *szWndTitle = \"Parallel Realistic Image Synthesis Engine (P.R.I.S.E) Scheduler Console\";\n\tchar szWindowName[1024];\n\tsprintf( szWindowName, \"%s v. %d.%d.%d build %d\", szWndTitle, RISE_VER_MAJOR_VERSION, RISE_VER_MINOR_VERSION, RISE_VER_REVISION_VERSION, RISE_VER_BUILD_VERSION );\n\tpA->Init( szWindowName, hInstance );\n\tGlobalLogPriv()->AddPrinter( pA );\n\tpA->RemoveRef();\n\n\tGlobalLog()->PrintEasyEvent( \"============================================================\" );",
  "snippet_062": "// TODO: Convert sprintf to snprintf in:\n\n\tConsoleWin32* pA = new ConsoleWin32( eLog_Win32Console, TYPICAL_PRIORITY, HIGHEST_PRIORITY );\n\tGlobalLog()->PrintNew( pA, __FILE__, __LINE__, \"Win32 Console printer\" );\n\tconst char *szWndTitle = \"Parallel Realistic Image Synthesis Engine (P.R.I.S.E) Worker Console\";\n\tchar szWindowName[1024];\n\tsprintf( szWindowName, \"%s v. %d.%d.%d build %d\", szWndTitle, RISE_VER_MAJOR_VERSION, RISE_VER_MINOR_VERSION, RISE_VER_REVISION_VERSION, RISE_VER_BUILD_VERSION );\n\tpA->Init( szWindowName, hInstance );\n\tGlobalLogPriv()->AddPrinter( pA );\n\tpA->RemoveRef();\n\n\tGlobalLog()->PrintEasyEvent( \"============================================================\" );",
  "snippet_063": "// TODO: Convert sprintf to snprintf in:\n\t\tMemoryBuffer*\tmb = new MemoryBuffer();\n\t\tmb->Resize( 0x10000000 );\n\t\tgeom->SerializeForCPU( *mb, i );\n\n\t\tchar\tfilename[1024];\n\t\tsprintf( filename, \"%s_%d.prisemesh\", argv[2], i );\n\n\t\tmb->DumpToFileToCursor( filename );\n\t\tmb->RemoveRef();\n\t}\n",
  "snippet_064": "// TODO: Convert sprintf to snprintf in:\n\tpBuffer->setInt( numPositions );\t\t// Number of emitter positions\n\tpBuffer->setInt( numPatches );\t\t\t// Number of patches\n\t\n\tfor( unsigned int i=0; i<numPositions; i++ ) {\n\t\tchar buf[256] = {0};\n\t\tsprintf( buf, \"Performing measurement %.2d of %.2d: \", i+1, numPositions );\n\t\tStdOutProgress\tprogress( buf );\n\n\t\tconst Scalar dEmitterTheta = (PI_OV_TWO/(numPositions-1))*(i);\n\n\t\tpDetector->PerformMeasurement(",
  "snippet_065": "// TODO: Convert sprintf to snprintf in:\n\t// Disable aspects of the logger, so that different processes don't conflict on the same log file\n\tGlobalLogPriv()->RemoveAllPrinters();\n\n\t// Now add back the file printer\n\tchar buf[1024];\n\tsprintf( buf, \"RISELog_Proc%d.txt\", rank );\n\tstd::ofstream*\t\tfs = new std::ofstream( buf );\n\tStreamPrinter*\t\tpB = new StreamPrinter( fs, true );\n\tGlobalLog()->PrintNew( pB, __FILE__, __LINE__, \"file stream printer\" );\n\tGlobalLogPriv()->AddPrinter( pB );\n\tpB->release();"
}