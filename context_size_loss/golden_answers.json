{
  "snippet_000": {
    "original_content": [
      "   }",
      "",
      "#if defined(_WIN32_WCE)",
      "   {",
      "      wchar_t time_buf[29];",
      "      wsprintf(time_buf, TEXT(\"%d %S %d %02d:%02d:%02d +0000\"),",
      "          ptime->day % 32, short_months[(ptime->month - 1) % 12],",
      "        ptime->year, ptime->hour % 24, ptime->minute % 60,",
      "          ptime->second % 61);",
      "      WideCharToMultiByte(CP_ACP, 0, time_buf, -1, png_ptr->time_buffer, 29,",
      "          NULL, NULL);",
      "   }",
      "#else",
      "#ifdef USE_FAR_KEYWORD",
      "   {",
      "      char near_time_buf[29];",
      "      sprintf(near_time_buf, \"%d %s %d %02d:%02d:%02d +0000\",",
      "          ptime->day % 32, short_months[(ptime->month - 1) % 12],",
      "          ptime->year, ptime->hour % 24, ptime->minute % 60,",
      "          ptime->second % 61);",
      "      png_memcpy(png_ptr->time_buffer, near_time_buf,",
      "          29*png_sizeof(char));",
      "   }",
      "#else",
      "   sprintf(png_ptr->time_buffer, \"%d %s %d %02d:%02d:%02d +0000\",",
      "       ptime->day % 32, short_months[(ptime->month - 1) % 12],",
      "       ptime->year, ptime->hour % 24, ptime->minute % 60,",
      "       ptime->second % 61);",
      "#endif",
      "#endif /* _WIN32_WCE */"
    ],
    "golden_answer": [
      "}",
      "",
      "#if defined(_WIN32_WCE)",
      "   {",
      "      wchar_t time_buf[29];",
      "      int ret;",
      "",
      "      /* Use _snwprintf for safe formatting on Windows CE. */",
      "      ret = _snwprintf(time_buf, 29, TEXT(\"%d %S %d %02d:%02d:%02d +0000\"),",
      "          ptime->day % 32, short_months[(ptime->month - 1) % 12],",
      "          ptime->year, ptime->hour % 24, ptime->minute % 60,",
      "          ptime->second % 61);",
      "",
      "      /* Older versions of _snwprintf may not null-terminate on truncation. */",
      "      if (ret < 0)",
      "      {",
      "         /* Manually null-terminate if an error or truncation occurred. */",
      "         time_buf[28] = L'\\0';",
      "      }",
      "",
      "      WideCharToMultiByte(CP_ACP, 0, time_buf, -1, png_ptr->time_buffer, 29,",
      "          NULL, NULL);",
      "   }",
      "#else",
      "#ifdef USE_FAR_KEYWORD",
      "   {",
      "      char near_time_buf[29];",
      "      int ret;",
      "",
      "      /* Use snprintf for safe, null-terminated string formatting. */",
      "      ret = snprintf(near_time_buf, 29, \"%d %s %d %02d:%02d:%02d +0000\",",
      "          ptime->day % 32, short_months[(ptime->month - 1) % 12],",
      "          ptime->year, ptime->hour % 24, ptime->minute % 60,",
      "          ptime->second % 61);",
      "",
      "      /*",
      "       * Check for truncation or encoding errors. The buffer is guaranteed",
      "       * to be null-terminated by snprintf. A warning could be logged here.",
      "       */",
      "      if (ret < 0 || ret >= 29)",
      "      {",
      "         /* An error or truncation occurred, but the buffer is safe to use. */",
      "      }",
      "",
      "      png_memcpy(png_ptr->time_buffer, near_time_buf,",
      "          29*png_sizeof(char));",
      "   }",
      "#else",
      "   {",
      "      int ret;",
      "",
      "      /* Use snprintf for safe, null-terminated string formatting. */",
      "      ret = snprintf(png_ptr->time_buffer, 29, \"%d %s %d %02d:%02d:%02d +0000\",",
      "          ptime->day % 32, short_months[(ptime->month - 1) % 12],",
      "          ptime->year, ptime->hour % 24, ptime->minute % 60,",
      "          ptime->second % 61);",
      "",
      "      /*",
      "       * Check for truncation or encoding errors. The buffer is guaranteed",
      "       * to be null-terminated by snprintf. A warning could be logged here.",
      "       */",
      "      if (ret < 0 || ret >= 29)",
      "      {",
      "         /* An error or truncation occurred, but the buffer is safe to use. */",
      "      }",
      "   }",
      "#endif",
      "#endif /* _WIN32_WCE */"
    ]
  },
  "snippet_001": {
    "original_content": [
      "",
      "#ifdef PNG_DEBUG",
      "   png_debug(1, \"in png_read_filter_row (pnggccrd.c)\\n\");",
      "   switch (filter)",
      "   {",
      "      case 0: sprintf(filnm, \"none\");",
      "         break;",
      "      case 1: sprintf(filnm, \"sub-%s\",",
      "#if defined(PNG_ASSEMBLER_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)",
      "#if !defined(PNG_1_0_X)",
      "        (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_SUB)? \"MMX\" : ",
      "#endif",
      "#endif",
      "\"x86\");",
      "         break;",
      "      case 2: sprintf(filnm, \"up-%s\",",
      "#ifdef PNG_ASSEMBLER_CODE_SUPPORTED",
      "#if !defined(PNG_1_0_X)",
      "        (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_UP)? \"MMX\" :",
      "#endif",
      "#endif",
      " \"x86\");",
      "         break;",
      "      case 3: sprintf(filnm, \"avg-%s\",",
      "#if defined(PNG_ASSEMBLER_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)",
      "#if !defined(PNG_1_0_X)",
      "        (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_AVG)? \"MMX\" :",
      "#endif",
      "#endif",
      " \"x86\");",
      "         break;",
      "      case 4: sprintf(filnm, \"Paeth-%s\",",
      "#if defined(PNG_ASSEMBLER_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)",
      "#if !defined(PNG_1_0_X)",
      "        (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_PAETH)? \"MMX\":",
      "#endif",
      "#endif",
      "\"x86\");",
      "         break;",
      "      default: sprintf(filnm, \"unknw\");",
      "         break;",
      "   }",
      "   png_debug2(0, \"row_number=%5ld, %5s, \", png_ptr->row_number, filnm);",
      "   png_debug1(0, \"row=0x%08lx, \", (unsigned long)row);",
      "   png_debug2(0, \"pixdepth=%2d, bytes=%d, \", (int)row_info->pixel_depth,"
    ],
    "golden_answer": [
      "#ifdef PNG_DEBUG",
      "   png_debug(1, \"in png_read_filter_row (pnggccrd.c)\\n\");",
      "   switch (filter)",
      "   {",
      "      case 0: (void)snprintf(filnm, sizeof(filnm), \"none\");",
      "         break;",
      "      case 1: (void)snprintf(filnm, sizeof(filnm), \"sub-%s\",",
      "#if defined(PNG_ASSEMBLER_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)",
      "#if !defined(PNG_1_0_X)",
      "        (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_SUB)? \"MMX\" :",
      "#endif",
      "#endif",
      "\"x86\");",
      "         break;",
      "      case 2: (void)snprintf(filnm, sizeof(filnm), \"up-%s\",",
      "#ifdef PNG_ASSEMBLER_CODE_SUPPORTED",
      "#if !defined(PNG_1_0_X)",
      "        (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_UP)? \"MMX\" :",
      "#endif",
      "#endif",
      " \"x86\");",
      "         break;",
      "      case 3: (void)snprintf(filnm, sizeof(filnm), \"avg-%s\",",
      "#if defined(PNG_ASSEMBLER_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)",
      "#if !defined(PNG_1_0_X)",
      "        (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_AVG)? \"MMX\" :",
      "#endif",
      "#endif",
      " \"x86\");",
      "         break;",
      "      case 4: (void)snprintf(filnm, sizeof(filnm), \"Paeth-%s\",",
      "#if defined(PNG_ASSEMBLER_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)",
      "#if !defined(PNG_1_0_X)",
      "        (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_PAETH)? \"MMX\":",
      "#endif",
      "#endif",
      "\"x86\");",
      "         break;",
      "      default: (void)snprintf(filnm, sizeof(filnm), \"unknw\");",
      "         break;",
      "   }",
      "   png_debug2(0, \"row_number=%5ld, %5s, \", png_ptr->row_number, filnm);",
      "   png_debug1(0, \"row=0x%08lx, \", (unsigned long)row);",
      "   png_debug2(0, \"pixdepth=%2d, bytes=%d, \", (int)row_info->pixel_depth,"
    ]
  },
  "snippet_002": {
    "original_content": [
      "     {",
      "#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)",
      "        char msg[80];",
      "        if (user_png_ver)",
      "        {",
      "          sprintf(msg, \"Application was compiled with png.h from libpng-%.20s\",",
      "             user_png_ver);",
      "          png_warning(png_ptr, msg);",
      "        }",
      "        sprintf(msg, \"Application  is  running with png.c from libpng-%.20s\",",
      "           png_libpng_ver);",
      "        png_warning(png_ptr, msg);",
      "#endif",
      "#ifdef PNG_ERROR_NUMBERS_SUPPORTED",
      "        png_ptr->flags=0;"
    ],
    "golden_answer": [
      "{",
      "#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)",
      "        char msg[80];",
      "        int ret;",
      "        if (user_png_ver)",
      "        {",
      "          /* Use snprintf for buffer safety. It returns the number of chars",
      "           * that would have been written, or a negative value on error.",
      "           */",
      "          ret = snprintf(msg, sizeof(msg),",
      "             \"Application was compiled with png.h from libpng-%.20s\",",
      "             user_png_ver);",
      "          /* We proceed on success or truncation; msg is safely null-terminated.",
      "           * Only skip the warning on an encoding error (negative return value).",
      "           */",
      "          if (ret >= 0)",
      "             png_warning(png_ptr, msg);",
      "        }",
      "",
      "        ret = snprintf(msg, sizeof(msg),",
      "           \"Application  is  running with png.c from libpng-%.20s\",",
      "           png_libpng_ver);",
      "        if (ret >= 0)",
      "           png_warning(png_ptr, msg);",
      "#endif",
      "#ifdef PNG_ERROR_NUMBERS_SUPPORTED",
      "        png_ptr->flags=0;"
    ]
  },
  "snippet_003": {
    "original_content": [
      "   {",
      "      char msg[80];",
      "      png_ptr->warning_fn=NULL;",
      "      if (user_png_ver)",
      "      {",
      "        sprintf(msg, \"Application was compiled with png.h from libpng-%.20s\",",
      "           user_png_ver);",
      "        png_warning(png_ptr, msg);",
      "      }",
      "      sprintf(msg, \"Application  is  running with png.c from libpng-%.20s\",",
      "         png_libpng_ver);",
      "      png_warning(png_ptr, msg);",
      "   }",
      "#endif",
      "   if(png_sizeof(png_struct) > png_struct_size)"
    ],
    "golden_answer": [
      "{",
      "      char msg[80];",
      "      int len;",
      "      png_ptr->warning_fn=NULL;",
      "      if (user_png_ver)",
      "      {",
      "        len = snprintf(msg, sizeof(msg), \"Application was compiled with png.h from libpng-%.20s\",",
      "           user_png_ver);",
      "        /* Check for encoding errors before issuing the warning. A truncated",
      "         * message is acceptable, as snprintf guarantees null-termination. */",
      "        if (len >= 0)",
      "           png_warning(png_ptr, msg);",
      "      }",
      "      len = snprintf(msg, sizeof(msg), \"Application  is  running with png.c from libpng-%.20s\",",
      "         png_libpng_ver);",
      "      /* Check for encoding errors before using the formatted string. */",
      "      if (len >= 0)",
      "         png_warning(png_ptr, msg);",
      "   }",
      "#endif",
      "   if(png_sizeof(png_struct) > png_struct_size)"
    ]
  },
  "snippet_004": {
    "original_content": [
      "   if (png_ptr->row_buf == NULL)",
      "   {",
      "#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)",
      "      char msg[50];",
      "",
      "      sprintf(msg, \"NULL row buffer for row %ld, pass %d\", png_ptr->row_number,",
      "         png_ptr->pass);",
      "      png_error(png_ptr, msg);",
      "#else",
      "      png_error(png_ptr, \"NULL row buffer\");",
      "#endif"
    ],
    "golden_answer": [
      "if (png_ptr->row_buf == NULL)",
      "   {",
      "#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)",
      "      char msg[50];",
      "      int ret;",
      "",
      "      /* Use snprintf to prevent buffer overflows.",
      "       * It takes the buffer size as an argument and guarantees",
      "       * null-termination.",
      "       */",
      "      ret = snprintf(msg, sizeof(msg), \"NULL row buffer for row %ld, pass %d\",",
      "         png_ptr->row_number, png_ptr->pass);",
      "",
      "      /* A negative return value indicates an encoding error. In this",
      "       * unlikely event, we fall back to a generic error message.",
      "       * Truncation (ret >= sizeof(msg)) is handled gracefully, as",
      "       * snprintf will still provide a null-terminated string.",
      "       */",
      "      if (ret < 0)",
      "      {",
      "         png_error(png_ptr, \"NULL row buffer (and snprintf encoding error)\");",
      "      }",
      "      else",
      "      {",
      "         png_error(png_ptr, msg);",
      "      }",
      "#else",
      "      png_error(png_ptr, \"NULL row buffer\");",
      "#endif"
    ]
  },
  "snippet_005": {
    "original_content": [
      "      {",
      "#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)",
      "         char umsg[50];",
      "",
      "         if (ret == Z_BUF_ERROR)",
      "            sprintf(umsg,\"Buffer error in compressed datastream in %s chunk\",",
      "                png_ptr->chunk_name);",
      "         else if (ret == Z_DATA_ERROR)",
      "            sprintf(umsg,\"Data error in compressed datastream in %s chunk\",",
      "                png_ptr->chunk_name);",
      "         else",
      "            sprintf(umsg,\"Incomplete compressed datastream in %s chunk\",",
      "                png_ptr->chunk_name);",
      "         png_warning(png_ptr, umsg);",
      "#else",
      "         png_warning(png_ptr,",
      "            \"Incomplete compressed datastream in chunk other than IDAT\");"
    ],
    "golden_answer": [
      "{",
      "#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)",
      "         char umsg[50];",
      "         int bytes_written;",
      "",
      "         if (ret == Z_BUF_ERROR)",
      "         {",
      "            bytes_written = snprintf(umsg, sizeof(umsg),",
      "               \"Buffer error in compressed datastream in %s chunk\",",
      "               png_ptr->chunk_name);",
      "         }",
      "         else if (ret == Z_DATA_ERROR)",
      "         {",
      "            bytes_written = snprintf(umsg, sizeof(umsg),",
      "               \"Data error in compressed datastream in %s chunk\",",
      "               png_ptr->chunk_name);",
      "         }",
      "         else",
      "         {",
      "            bytes_written = snprintf(umsg, sizeof(umsg),",
      "               \"Incomplete compressed datastream in %s chunk\",",
      "               png_ptr->chunk_name);",
      "         }",
      "",
      "         // Handle the snprintf return value appropriately.",
      "         // A negative value indicates an encoding error. In this unlikely case,",
      "         // we overwrite the buffer with a generic error to ensure a valid",
      "         // message is passed to png_warning.",
      "         // If bytes_written >= sizeof(umsg), the message was truncated,",
      "         // but snprintf guarantees a null-terminated string, which is safe to use.",
      "         if (bytes_written < 0)",
      "         {",
      "            snprintf(umsg, sizeof(umsg), \"Error formatting zlib warning\");",
      "         }",
      "",
      "         png_warning(png_ptr, umsg);",
      "#else",
      "         png_warning(png_ptr,",
      "            \"Incomplete compressed datastream in chunk other than IDAT\");"
    ]
  },
  "snippet_006": {
    "original_content": [
      "   else /* if (comp_type != PNG_COMPRESSION_TYPE_BASE) */",
      "   {",
      "#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)",
      "      char umsg[50];",
      "",
      "      sprintf(umsg, \"Unknown zTXt compression type %d\", comp_type);",
      "      png_warning(png_ptr, umsg);",
      "#else",
      "      png_warning(png_ptr, \"Unknown zTXt compression type\");",
      "#endif",
      ""
    ],
    "golden_answer": [
      "else /* if (comp_type != PNG_COMPRESSION_TYPE_BASE) */",
      "   {",
      "#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)",
      "      char umsg[50];",
      "      int ret;",
      "",
      "      /* Use snprintf for buffer safety. It will not write more than",
      "       * sizeof(umsg) bytes, including the null terminator.",
      "       */",
      "      ret = snprintf(umsg, sizeof(umsg), \"Unknown zTXt compression type %d\",",
      "         comp_type);",
      "",
      "      /* Check for encoding errors or truncation. A return value greater than",
      "       * or equal to the buffer size indicates the output was truncated.",
      "       */",
      "      if (ret < 0 || (size_t)ret >= sizeof(umsg))",
      "      {",
      "         /* If formatting failed or was truncated, fall back to a generic message. */",
      "         png_warning(png_ptr, \"Unknown zTXt compression type\");",
      "      }",
      "      else",
      "      {",
      "         /* The message was formatted successfully and fits in the buffer. */",
      "         png_warning(png_ptr, umsg);",
      "      }",
      "#else",
      "      png_warning(png_ptr, \"Unknown zTXt compression type\");",
      "#endif"
    ]
  },
  "snippet_007": {
    "original_content": [
      "",
      "#ifdef PNG_DEBUG",
      "   png_debug(1, \"in png_read_filter_row\\n\");",
      "   switch (filter)",
      "   {",
      "      case 0: sprintf(filnm, \"none\");",
      "         break;",
      "#if !defined(PNG_1_0_X)",
      "      case 1: sprintf(filnm, \"sub-%s\",",
      "        (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_SUB)? \"MMX\" : \"x86\");",
      "         break;",
      "      case 2: sprintf(filnm, \"up-%s\",",
      "        (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_UP)? \"MMX\" : \"x86\");",
      "         break;",
      "      case 3: sprintf(filnm, \"avg-%s\",",
      "        (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_AVG)? \"MMX\" : \"x86\");",
      "         break;",
      "      case 4: sprintf(filnm, \"Paeth-%s\",",
      "        (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_PAETH)? \"MMX\":\"x86\");",
      "         break;",
      "#else",
      "      case 1: sprintf(filnm, \"sub\");",
      "         break;",
      "      case 2: sprintf(filnm, \"up\");",
      "         break;",
      "      case 3: sprintf(filnm, \"avg\");",
      "         break;",
      "      case 4: sprintf(filnm, \"Paeth\");",
      "         break;",
      "#endif",
      "      default: sprintf(filnm, \"unknw\");",
      "         break;",
      "   }",
      "   png_debug2(0,\"row=%5d, %s, \", png_ptr->row_number, filnm);",
      "   png_debug2(0, \"pd=%2d, b=%d, \", (int)row_info->pixel_depth,",
      "      (int)((row_info->pixel_depth + 7) >> 3));"
    ],
    "golden_answer": [
      "#ifdef PNG_DEBUG",
      "   png_debug(1, \"in png_read_filter_row\\n\");",
      "",
      "   /*",
      "    * Use snprintf instead of sprintf for buffer safety.",
      "    * The second argument, sizeof(filnm), ensures that we do not write",
      "    * beyond the bounds of the filnm buffer.",
      "    *",
      "    * The return value of snprintf is the number of characters that *would*",
      "    * have been written if the buffer were large enough. We could check if",
      "    * this value is >= sizeof(filnm) to detect truncation. However, for",
      "    * this debug logging, simply ensuring the string is safely null-terminated",
      "    * is sufficient.",
      "    */",
      "   switch (filter)",
      "   {",
      "      case 0: snprintf(filnm, sizeof(filnm), \"none\");",
      "         break;",
      "#if !defined(PNG_1_0_X)",
      "      case 1: snprintf(filnm, sizeof(filnm), \"sub-%s\",",
      "        (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_SUB)? \"MMX\" : \"x86\");",
      "         break;",
      "      case 2: snprintf(filnm, sizeof(filnm), \"up-%s\",",
      "        (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_UP)? \"MMX\" : \"x86\");",
      "         break;",
      "      case 3: snprintf(filnm, sizeof(filnm), \"avg-%s\",",
      "        (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_AVG)? \"MMX\" : \"x86\");",
      "         break;",
      "      case 4: snprintf(filnm, sizeof(filnm), \"Paeth-%s\",",
      "        (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_PAETH)? \"MMX\":\"x86\");",
      "         break;",
      "#else",
      "      case 1: snprintf(filnm, sizeof(filnm), \"sub\");",
      "         break;",
      "      case 2: snprintf(filnm, sizeof(filnm), \"up\");",
      "         break;",
      "      case 3: snprintf(filnm, sizeof(filnm), \"avg\");",
      "         break;",
      "      case 4: snprintf(filnm, sizeof(filnm), \"Paeth\");",
      "         break;",
      "#endif",
      "      default: snprintf(filnm, sizeof(filnm), \"unknw\");",
      "         break;",
      "   }",
      "   png_debug2(0,\"row=%5d, %s, \", png_ptr->row_number, filnm);",
      "   png_debug2(0, \"pd=%2d, b=%d, \", (int)row_info->pixel_depth,",
      "      (int)((row_info->pixel_depth + 7) >> 3));"
    ]
  },
  "snippet_008": {
    "original_content": [
      "     {",
      "#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)",
      "        char msg[80];",
      "        if (user_png_ver)",
      "        {",
      "          sprintf(msg, \"Application was compiled with png.h from libpng-%.20s\",",
      "             user_png_ver);",
      "          png_warning(png_ptr, msg);",
      "        }",
      "        sprintf(msg, \"Application  is  running with png.c from libpng-%.20s\",",
      "           png_libpng_ver);",
      "        png_warning(png_ptr, msg);",
      "#endif",
      "#ifdef PNG_ERROR_NUMBERS_SUPPORTED",
      "        png_ptr->flags=0;"
    ],
    "golden_answer": [
      "{",
      "#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)",
      "        char msg[80];",
      "        int written; // To hold the return value of snprintf",
      "",
      "        if (user_png_ver)",
      "        {",
      "          // Use snprintf to prevent buffer overflows.",
      "          // The second argument is the total size of the buffer.",
      "          written = snprintf(msg, sizeof(msg),",
      "             \"Application was compiled with png.h from libpng-%.20s\",",
      "             user_png_ver);",
      "",
      "          // Check for encoding errors. A truncated message is acceptable for a warning,",
      "          // but a negative return value indicates an error we should handle.",
      "          if (written >= 0)",
      "          {",
      "             png_warning(png_ptr, msg);",
      "          }",
      "        }",
      "",
      "        // Use snprintf again for the second message.",
      "        written = snprintf(msg, sizeof(msg),",
      "           \"Application  is  running with png.c from libpng-%.20s\",",
      "           png_libpng_ver);",
      "",
      "        // Perform the same safety check.",
      "        if (written >= 0)",
      "        {",
      "           png_warning(png_ptr, msg);",
      "        }",
      "#endif",
      "#ifdef PNG_ERROR_NUMBERS_SUPPORTED",
      "        png_ptr->flags=0;"
    ]
  },
  "snippet_009": {
    "original_content": [
      "   {",
      "      char msg[80];",
      "      png_ptr->warning_fn=NULL;",
      "      if (user_png_ver)",
      "      {",
      "        sprintf(msg, \"Application was compiled with png.h from libpng-%.20s\",",
      "           user_png_ver);",
      "        png_warning(png_ptr, msg);",
      "      }",
      "      sprintf(msg, \"Application  is  running with png.c from libpng-%.20s\",",
      "         png_libpng_ver);",
      "      png_warning(png_ptr, msg);",
      "   }",
      "#endif",
      "   if(png_sizeof(png_struct) > png_struct_size)"
    ],
    "golden_answer": [
      "{",
      "      char msg[80];",
      "      int ret;",
      "      png_ptr->warning_fn=NULL;",
      "      if (user_png_ver)",
      "      {",
      "        // Use snprintf for buffer safety. It requires the buffer size",
      "        // as an argument to prevent overflows.",
      "        ret = snprintf(msg, sizeof(msg), \"Application was compiled with png.h from libpng-%.20s\",",
      "           user_png_ver);",
      "        ",
      "        // Only use the formatted string if snprintf was successful (returned a non-negative value).",
      "        // Even if the string was truncated (ret >= sizeof(msg)), it is still",
      "        // safely null-terminated and can be used.",
      "        if (ret >= 0)",
      "        {",
      "           png_warning(png_ptr, msg);",
      "        }",
      "      }",
      "      ",
      "      // Convert the second call to snprintf as well.",
      "      ret = snprintf(msg, sizeof(msg), \"Application  is  running with png.c from libpng-%.20s\",",
      "         png_libpng_ver);",
      "      ",
      "      // Perform the same safety check.",
      "      if (ret >= 0)",
      "      {",
      "         png_warning(png_ptr, msg);",
      "      }",
      "   }",
      "#endif",
      "   if(png_sizeof(png_struct) > png_struct_size)"
    ]
  },
  "snippet_010": {
    "original_content": [
      "",
      "   if (compression >= PNG_TEXT_COMPRESSION_LAST)",
      "   {",
      "#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)",
      "      char msg[50];",
      "      sprintf(msg, \"Unknown compression type %d\", compression);",
      "      png_warning(png_ptr, msg);",
      "#else",
      "      png_warning(png_ptr, \"Unknown compression type\");",
      "#endif",
      "   }"
    ],
    "golden_answer": [
      "if (compression >= PNG_TEXT_COMPRESSION_LAST)",
      "   {",
      "#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)",
      "      char msg[50];",
      "      int ret = snprintf(msg, sizeof(msg), \"Unknown compression type %d\",",
      "          compression);",
      "",
      "      /*",
      "       * Check the return value of snprintf.",
      "       * If ret < 0, an encoding error occurred.",
      "       * If ret >= sizeof(msg), the message was truncated.",
      "       * In either case, fall back to a generic warning message.",
      "       */",
      "      if (ret < 0 || (size_t)ret >= sizeof(msg))",
      "      {",
      "         png_warning(png_ptr, \"Unknown compression type\");",
      "      }",
      "      else",
      "      {",
      "         png_warning(png_ptr, msg);",
      "      }",
      "#else",
      "      png_warning(png_ptr, \"Unknown compression type\");",
      "#endif",
      "   }"
    ]
  },
  "snippet_011": {
    "original_content": [
      "      if (*kp < 0x20 || (*kp > 0x7E && (png_byte)*kp < 0xA1))",
      "      {",
      "#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)",
      "         char msg[40];",
      "",
      "         sprintf(msg, \"invalid keyword character 0x%02X\", *kp);",
      "         png_warning(png_ptr, msg);",
      "#else",
      "         png_warning(png_ptr, \"invalid character in keyword\");",
      "#endif",
      "         *dp = ' ';"
    ],
    "golden_answer": [
      "if (*kp < 0x20 || (*kp > 0x7E && (png_byte)*kp < 0xA1))",
      "      {",
      "#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)",
      "         char msg[40];",
      "         int ret;",
      "",
      "         /* Use snprintf for buffer safety. The return value is the number of",
      "          * characters that would have been written, excluding the null terminator.",
      "          */",
      "         ret = snprintf(msg, sizeof(msg), \"invalid keyword character 0x%02X\", *kp);",
      "",
      "         /* Check for truncation (ret >= sizeof(msg)) or encoding errors (ret < 0).",
      "          * In either case, fall back to a generic warning message.",
      "          */",
      "         if (ret < 0 || (size_t)ret >= sizeof(msg))",
      "         {",
      "            png_warning(png_ptr, \"invalid character in keyword\");",
      "         }",
      "         else",
      "         {",
      "            png_warning(png_ptr, msg);",
      "         }",
      "#else",
      "         png_warning(png_ptr, \"invalid character in keyword\");",
      "#endif",
      "         *dp = ' ';"
    ]
  },
  "snippet_012": {
    "original_content": [
      "   png_byte bunit = unit;",
      "",
      "   png_debug(1, \"in png_write_sCAL\\n\");",
      "",
      "#if defined(_WIN32_WCE)",
      "/* sprintf() function is not supported on WindowsCE */",
      "   {",
      "      wchar_t wc_buf[32];",
      "      swprintf(wc_buf, TEXT(\"%12.12e\"), width);",
      "      WideCharToMultiByte(CP_ACP, 0, wc_buf, -1, wbuf, 32, NULL, NULL);",
      "      swprintf(wc_buf, TEXT(\"%12.12e\"), height);",
      "      WideCharToMultiByte(CP_ACP, 0, wc_buf, -1, hbuf, 32, NULL, NULL);",
      "   }",
      "#else",
      "   sprintf(wbuf, \"%12.12e\", width);",
      "   sprintf(hbuf, \"%12.12e\", height);",
      "#endif",
      "   total_len = 1 + png_strlen(wbuf)+1 + png_strlen(hbuf);",
      "",
      "   png_debug1(3, \"sCAL total length = %d\\n\", (int)total_len);",
      "   png_write_chunk_start(png_ptr, (png_bytep)png_sCAL, (png_uint_32)total_len);"
    ],
    "golden_answer": [
      "png_byte bunit = unit;",
      "",
      "   png_debug(1, \"in png_write_sCAL\\n\");",
      "",
      "#if defined(_WIN32_WCE)",
      "/* sprintf() function is not supported on WindowsCE */",
      "   {",
      "      wchar_t wc_buf[32];",
      "      swprintf(wc_buf, TEXT(\"%12.12e\"), width);",
      "      WideCharToMultiByte(CP_ACP, 0, wc_buf, -1, wbuf, 32, NULL, NULL);",
      "      swprintf(wc_buf, TEXT(\"%12.12e\"), height);",
      "      WideCharToMultiByte(CP_ACP, 0, wc_buf, -1, hbuf, 32, NULL, NULL);",
      "      total_len = 1 + png_strlen(wbuf)+1 + png_strlen(hbuf);",
      "   }",
      "#else",
      "   /*",
      "    * Use snprintf instead of sprintf for buffer safety.",
      "    * The buffer size of 32 is chosen to match the _WIN32_WCE branch.",
      "    */",
      "#  define PNG_sCAL_BUFFER_SIZE 32",
      "   int wlen, hlen;",
      "",
      "   wlen = snprintf(wbuf, PNG_sCAL_BUFFER_SIZE, \"%12.12e\", width);",
      "   hlen = snprintf(hbuf, PNG_sCAL_BUFFER_SIZE, \"%12.12e\", height);",
      "",
      "   /*",
      "    * Check for encoding errors (negative return) or truncation (return >= size).",
      "    * In either case, the written data is not what we wanted.",
      "    */",
      "   if (wlen < 0 || (size_t)wlen >= PNG_sCAL_BUFFER_SIZE ||",
      "       hlen < 0 || (size_t)hlen >= PNG_sCAL_BUFFER_SIZE)",
      "   {",
      "      png_error(png_ptr, \"sCAL width or height value failed to format\");",
      "      return; /* Or appropriate error handling */",
      "   }",
      "",
      "   /* The total length is 1 byte for unit, plus the strings, plus a separator */",
      "   total_len = 1 + wlen + 1 + hlen;",
      "#endif",
      "",
      "   png_debug1(3, \"sCAL total length = %d\\n\", (int)total_len);",
      "   png_write_chunk_start(png_ptr, (png_bytep)png_sCAL, (png_uint_32)total_len);"
    ]
  },
  "snippet_013": {
    "original_content": [
      "\t}",
      "",
      "\t/* note that this name is a special sign to TIFFClose() and",
      "\t * _TIFFSetupFieldInfo() to free the field",
      "\t */",
      "\tsprintf(fld->field_name, \"Tag %d\", (int) tag);",
      "",
      "\treturn fld;    ",
      "}",
      "",
      "/* vim: set ts=8 sts=8 sw=8 noet: */"
    ],
    "golden_answer": [
      "}",
      "",
      "\t/* note that this name is a special sign to TIFFClose() and",
      "\t * _TIFFSetupFieldInfo() to free the field",
      "\t */",
      "\tint len = snprintf(fld->field_name, sizeof(fld->field_name), \"Tag %d\", (int) tag);",
      "",
      "\t/*",
      "\t * Check the return value of snprintf.",
      "\t * A negative value indicates an encoding error.",
      "\t * A value greater than or equal to the buffer size indicates that",
      "\t * the output was truncated. Both are considered errors here, as a",
      "\t * truncated name might not be correctly interpreted.",
      "\t */",
      "\tif (len < 0 || (size_t)len >= sizeof(fld->field_name)) {",
      "\t\t/* ",
      "\t\t * Error handling: The field name could not be created safely.",
      "\t\t * The calling function should be notified of the failure.",
      "\t\t * A common pattern is to free the allocated memory and return NULL.",
      "\t\t */",
      "\t\t_TIFFfree(fld); /* Assuming fld was allocated in this function */",
      "\t\treturn NULL;",
      "\t}",
      "",
      "\treturn fld;    ",
      "}",
      "",
      "/* vim: set ts=8 sts=8 sw=8 noet: */"
    ]
  },
  "snippet_014": {
    "original_content": [
      "    TIFFDirectory* td = &tif->tif_dir;",
      "    uint16 photometric;",
      "    int colorchannels;",
      "",
      "    if (!tif->tif_decodestatus) {",
      "\tsprintf(emsg, \"Sorry, requested compression method is not configured\");",
      "\treturn (0);",
      "    }",
      "    switch (td->td_bitspersample) {",
      "    case 1: case 2: case 4:",
      "    case 8: case 16:",
      "\tbreak;",
      "    default:",
      "\tsprintf(emsg, \"Sorry, can not handle images with %d-bit samples\",",
      "\t    td->td_bitspersample);",
      "\treturn (0);",
      "    }",
      "    colorchannels = td->td_samplesperpixel - td->td_extrasamples;",
      "    if (!TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric)) {"
    ],
    "golden_answer": [
      "/*",
      "     * To make this a complete example, we must assume a buffer and its size.",
      "     * In a real application, 'emsg' would likely be passed in as a parameter",
      "     * or be a member of a struct (e.g., tif->tif_emsg).",
      "     */",
      "    const size_t EMSG_SIZE = 1024;",
      "    char emsg[EMSG_SIZE];",
      "",
      "    TIFFDirectory* td = &tif->tif_dir;",
      "    uint16 photometric;",
      "    int colorchannels;",
      "    int n; /* To store the return value of snprintf */",
      "",
      "    if (!tif->tif_decodestatus) {",
      "        /*",
      "         * Replaced sprintf with snprintf.",
      "         * 1. Pass the buffer size (EMSG_SIZE) as the second argument.",
      "         * 2. Capture the return value to check for errors or truncation.",
      "         */",
      "        n = snprintf(emsg, EMSG_SIZE, \"Sorry, requested compression method is not configured\");",
      "        if (n < 0 || (size_t)n >= EMSG_SIZE) {",
      "            /* Handle encoding error or truncation if necessary */",
      "        }",
      "        return (0);",
      "    }",
      "    switch (td->td_bitspersample) {",
      "    case 1: case 2: case 4:",
      "    case 8: case 16:",
      "        break;",
      "    default:",
      "        /*",
      "         * This call is more critical as the output length depends on an input value.",
      "         * snprintf ensures that no matter how many digits td_bitspersample has,",
      "         * we will not write past the end of the 'emsg' buffer.",
      "         */",
      "        n = snprintf(emsg, EMSG_SIZE, \"Sorry, can not handle images with %d-bit samples\",",
      "            td->td_bitspersample);",
      "        if (n < 0 || (size_t)n >= EMSG_SIZE) {",
      "            /* Handle encoding error or truncation if necessary */",
      "        }",
      "        return (0);",
      "    }",
      "    colorchannels = td->td_samplesperpixel - td->td_extrasamples;",
      "    if (!TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric)) {"
    ]
  },
  "snippet_015": {
    "original_content": [
      "\t    break;",
      "\tcase 3:",
      "\t    photometric = PHOTOMETRIC_RGB;",
      "\t    break;",
      "\tdefault:",
      "\t    sprintf(emsg, \"Missing needed %s tag\", photoTag);",
      "\t    return (0);",
      "\t}",
      "    }",
      "    switch (photometric) {",
      "    case PHOTOMETRIC_MINISWHITE:",
      "    case PHOTOMETRIC_MINISBLACK:",
      "    case PHOTOMETRIC_PALETTE:",
      "\tif (td->td_planarconfig == PLANARCONFIG_CONTIG ",
      "            && td->td_samplesperpixel != 1",
      "            && td->td_bitspersample < 8 ) {",
      "\t    sprintf(emsg,",
      "                    \"Sorry, can not handle contiguous data with %s=%d, \"",
      "                    \"and %s=%d and Bits/Sample=%d\",",
      "                    photoTag, photometric,",
      "                    \"Samples/pixel\", td->td_samplesperpixel,",
      "                    td->td_bitspersample);"
    ],
    "golden_answer": [
      "break;",
      "\tcase 3:",
      "\t    photometric = PHOTOMETRIC_RGB;",
      "\t    break;",
      "\tdefault:",
      "        /* ",
      "         * NOTE: We are assuming 'emsg' is a char buffer and 'emsg_size'",
      "         * holds its total capacity, for example:",
      "         *   char emsg[1024];",
      "         *   size_t emsg_size = sizeof(emsg);",
      "         */",
      "        snprintf(emsg, emsg_size, \"Missing needed %s tag\", photoTag);",
      "        /*",
      "         * snprintf is guaranteed to null-terminate the buffer as long as",
      "         * emsg_size > 0. The return value indicates if the output was",
      "         * truncated, but since we are returning an error anyway, the",
      "         * primary goal of preventing a buffer overflow is achieved.",
      "         */",
      "\t    return (0);",
      "\t}",
      "    }",
      "    switch (photometric) {",
      "    case PHOTOMETRIC_MINISWHITE:",
      "    case PHOTOMETRIC_MINISBLACK:",
      "    case PHOTOMETRIC_PALETTE:",
      "\tif (td->td_planarconfig == PLANARCONFIG_CONTIG ",
      "            && td->td_samplesperpixel != 1",
      "            && td->td_bitspersample < 8 ) {",
      "        int ret = snprintf(emsg, emsg_size,",
      "                    \"Sorry, can not handle contiguous data with %s=%d, \"",
      "                    \"and %s=%d and Bits/Sample=%d\",",
      "                    photoTag, photometric,",
      "                    \"Samples/pixel\", td->td_samplesperpixel,",
      "                    td->td_bitspersample);",
      "        /*",
      "         * Appropriately handling the return value means checking for",
      "         * potential issues. A negative value indicates an encoding error.",
      "         * A value >= emsg_size indicates the message was truncated.",
      "         */",
      "        if (ret < 0 || (size_t)ret >= emsg_size) {",
      "            // Optional: Log that the error message itself was truncated",
      "            // or that an encoding error occurred.",
      "        }"
    ]
  },
  "snippet_016": {
    "original_content": [
      "        ** them.  But for now we won't bother with this. ",
      "        */",
      "\tbreak;",
      "    case PHOTOMETRIC_YCBCR:",
      "\tif (td->td_planarconfig != PLANARCONFIG_CONTIG) {",
      "\t    sprintf(emsg, \"Sorry, can not handle YCbCr images with %s=%d\",",
      "\t\t\"Planarconfiguration\", td->td_planarconfig);",
      "\t    return (0);",
      "\t}",
      "\tbreak;",
      "    case PHOTOMETRIC_RGB: ",
      "\tif (colorchannels < 3) {",
      "\t    sprintf(emsg, \"Sorry, can not handle RGB image with %s=%d\",",
      "\t\t\"Color channels\", colorchannels);",
      "\t    return (0);",
      "\t}",
      "\tbreak;",
      "    case PHOTOMETRIC_SEPARATED:",
      "\t{",
      "\t\tuint16 inkset;",
      "\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_INKSET, &inkset);",
      "\t\tif (inkset != INKSET_CMYK) {",
      "\t\t    sprintf(emsg,",
      "\t\t\t    \"Sorry, can not handle separated image with %s=%d\",",
      "\t\t\t    \"InkSet\", inkset);",
      "\t\t    return 0;",
      "\t\t}",
      "\t\tif (td->td_samplesperpixel < 4) {",
      "\t\t    sprintf(emsg,",
      "\t\t\t    \"Sorry, can not handle separated image with %s=%d\",",
      "\t\t\t    \"Samples/pixel\", td->td_samplesperpixel);",
      "\t\t    return 0;",
      "\t\t}",
      "\t\tbreak;",
      "\t}",
      "    case PHOTOMETRIC_LOGL:",
      "\tif (td->td_compression != COMPRESSION_SGILOG) {",
      "\t    sprintf(emsg, \"Sorry, LogL data must have %s=%d\",",
      "\t\t\"Compression\", COMPRESSION_SGILOG);",
      "\t    return (0);",
      "\t}",
      "\tbreak;",
      "    case PHOTOMETRIC_LOGLUV:",
      "\tif (td->td_compression != COMPRESSION_SGILOG &&",
      "\t\ttd->td_compression != COMPRESSION_SGILOG24) {",
      "\t    sprintf(emsg, \"Sorry, LogLuv data must have %s=%d or %d\",",
      "\t\t\"Compression\", COMPRESSION_SGILOG, COMPRESSION_SGILOG24);",
      "\t    return (0);",
      "\t}",
      "\tif (td->td_planarconfig != PLANARCONFIG_CONTIG) {",
      "\t    sprintf(emsg, \"Sorry, can not handle LogLuv images with %s=%d\",",
      "\t\t\"Planarconfiguration\", td->td_planarconfig);",
      "\t    return (0);",
      "\t}",
      "\tbreak;",
      "    case PHOTOMETRIC_CIELAB:",
      "\tbreak;",
      "    default:",
      "\tsprintf(emsg, \"Sorry, can not handle image with %s=%d\",",
      "\t    photoTag, photometric);",
      "\treturn (0);",
      "    }",
      "    return (1);",
      "}"
    ],
    "golden_answer": [
      "** them.  But for now we won't bother with this. ",
      "        */",
      "\tbreak;",
      "    case PHOTOMETRIC_YCBCR:",
      "\tif (td->td_planarconfig != PLANARCONFIG_CONTIG) {",
      "\t    snprintf(emsg, sizeof(emsg), \"Sorry, can not handle YCbCr images with %s=%d\",",
      "\t\t\"Planarconfiguration\", td->td_planarconfig);",
      "\t    return (0);",
      "\t}",
      "\tbreak;",
      "    case PHOTOMETRIC_RGB: ",
      "\tif (colorchannels < 3) {",
      "\t    snprintf(emsg, sizeof(emsg), \"Sorry, can not handle RGB image with %s=%d\",",
      "\t\t\"Color channels\", colorchannels);",
      "\t    return (0);",
      "\t}",
      "\tbreak;",
      "    case PHOTOMETRIC_SEPARATED:",
      "\t{",
      "\t\tuint16 inkset;",
      "\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_INKSET, &inkset);",
      "\t\tif (inkset != INKSET_CMYK) {",
      "\t\t    snprintf(emsg, sizeof(emsg),",
      "\t\t\t    \"Sorry, can not handle separated image with %s=%d\",",
      "\t\t\t    \"InkSet\", inkset);",
      "\t\t    return 0;",
      "\t\t}",
      "\t\tif (td->td_samplesperpixel < 4) {",
      "\t\t    snprintf(emsg, sizeof(emsg),",
      "\t\t\t    \"Sorry, can not handle separated image with %s=%d\",",
      "\t\t\t    \"Samples/pixel\", td->td_samplesperpixel);",
      "\t\t    return 0;",
      "\t\t}",
      "\t\tbreak;",
      "\t}",
      "    case PHOTOMETRIC_LOGL:",
      "\tif (td->td_compression != COMPRESSION_SGILOG) {",
      "\t    snprintf(emsg, sizeof(emsg), \"Sorry, LogL data must have %s=%d\",",
      "\t\t\"Compression\", COMPRESSION_SGILOG);",
      "\t    return (0);",
      "\t}",
      "\tbreak;",
      "    case PHOTOMETRIC_LOGLUV:",
      "\tif (td->td_compression != COMPRESSION_SGILOG &&",
      "\t\ttd->td_compression != COMPRESSION_SGILOG24) {",
      "\t    snprintf(emsg, sizeof(emsg), \"Sorry, LogLuv data must have %s=%d or %d\",",
      "\t\t\"Compression\", COMPRESSION_SGILOG, COMPRESSION_SGILOG24);",
      "\t    return (0);",
      "\t}",
      "\tif (td->td_planarconfig != PLANARCONFIG_CONTIG) {",
      "\t    snprintf(emsg, sizeof(emsg), \"Sorry, can not handle LogLuv images with %s=%d\",",
      "\t\t\"Planarconfiguration\", td->td_planarconfig);",
      "\t    return (0);",
      "\t}",
      "\tbreak;",
      "    case PHOTOMETRIC_CIELAB:",
      "\tbreak;",
      "    default:",
      "\tsnprintf(emsg, sizeof(emsg), \"Sorry, can not handle image with %s=%d\",",
      "\t    photoTag, photometric);",
      "\treturn (0);",
      "    }",
      "    return (1);",
      "}"
    ]
  },
  "snippet_017": {
    "original_content": [
      "    switch (img->bitspersample) {",
      "    case 1: case 2: case 4:",
      "    case 8: case 16:",
      "\tbreak;",
      "    default:",
      "\tsprintf(emsg, \"Sorry, can not handle images with %d-bit samples\",",
      "\t    img->bitspersample);",
      "\treturn (0);",
      "    }",
      "    img->alpha = 0;",
      "    TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &img->samplesperpixel);"
    ],
    "golden_answer": [
      "switch (img->bitspersample) {",
      "    case 1: case 2: case 4:",
      "    case 8: case 16:",
      "        break;",
      "    default:",
      "        {",
      "            /* Assuming 'emsg' is a char array, e.g., char emsg[256]; */",
      "            int ret = snprintf(emsg, sizeof(emsg),",
      "                \"Sorry, can not handle images with %d-bit samples\",",
      "                img->bitspersample);",
      "",
      "            /*",
      "             * Best Practice: Check the return value of snprintf.",
      "             * A negative value indicates an encoding error.",
      "             * A value >= sizeof(emsg) indicates the output was truncated.",
      "             * In either case, the buffer is safely null-terminated.",
      "             */",
      "            if (ret < 0) {",
      "                // snprintf failed. Fall back to a generic, safe message.",
      "                snprintf(emsg, sizeof(emsg), \"Failed to format the error message.\");",
      "            } else if (ret >= sizeof(emsg)) {",
      "                // The message was truncated. For an error message that precedes",
      "                // program termination, this is often acceptable.",
      "                // A log message could be added here for developers if desired.",
      "            }",
      "        }",
      "        return (0);",
      "    }",
      "    img->alpha = 0;",
      "    TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &img->samplesperpixel);"
    ]
  },
  "snippet_018": {
    "original_content": [
      "\t    break;",
      "\tcase 3:",
      "\t    img->photometric = PHOTOMETRIC_RGB;",
      "\t    break;",
      "\tdefault:",
      "\t    sprintf(emsg, \"Missing needed %s tag\", photoTag);",
      "\t    return (0);",
      "\t}",
      "    }",
      "    switch (img->photometric) {",
      "    case PHOTOMETRIC_PALETTE:",
      "\tif (!TIFFGetField(tif, TIFFTAG_COLORMAP,",
      "\t    &red_orig, &green_orig, &blue_orig)) {",
      "\t    sprintf(emsg, \"Missing required \\\"Colormap\\\" tag\");",
      "\t    return (0);",
      "\t}",
      "",
      "        /* copy the colormaps so we can modify them */",
      "        n_color = (1L << img->bitspersample);",
      "        img->redcmap = (uint16 *) _TIFFmalloc(sizeof(uint16)*n_color);",
      "        img->greencmap = (uint16 *) _TIFFmalloc(sizeof(uint16)*n_color);",
      "        img->bluecmap = (uint16 *) _TIFFmalloc(sizeof(uint16)*n_color);",
      "        if( !img->redcmap || !img->greencmap || !img->bluecmap ) {",
      "\t    sprintf(emsg, \"Out of memory for colormap copy\");",
      "\t    return (0);",
      "        }",
      "",
      "        _TIFFmemcpy( img->redcmap, red_orig, n_color * 2 );",
      "        _TIFFmemcpy( img->greencmap, green_orig, n_color * 2 );"
    ],
    "golden_answer": [
      "break;",
      "\tcase 3:",
      "\t    img->photometric = PHOTOMETRIC_RGB;",
      "\t    break;",
      "\tdefault:",
      "\t    /* ",
      "\t     * Use snprintf for buffer safety. It takes the buffer size ",
      "\t     * as an argument to prevent overflows. We assume 'emsg' is a ",
      "\t     * statically allocated array (e.g., char emsg[1024];) so that ",
      "\t     * sizeof(emsg) correctly provides its size.",
      "\t     */",
      "\t    snprintf(emsg, sizeof(emsg), \"Missing needed %s tag\", photoTag);",
      "\t    return (0);",
      "\t}",
      "    }",
      "    switch (img->photometric) {",
      "    case PHOTOMETRIC_PALETTE:",
      "\tif (!TIFFGetField(tif, TIFFTAG_COLORMAP,",
      "\t    &red_orig, &green_orig, &blue_orig)) {",
      "\t    snprintf(emsg, sizeof(emsg), \"Missing required \\\"Colormap\\\" tag\");",
      "\t    return (0);",
      "\t}",
      "",
      "        /* copy the colormaps so we can modify them */",
      "        n_color = (1L << img->bitspersample);",
      "        img->redcmap = (uint16 *) _TIFFmalloc(sizeof(uint16)*n_color);",
      "        img->greencmap = (uint16 *) _TIFFmalloc(sizeof(uint16)*n_color);",
      "        img->bluecmap = (uint16 *) _TIFFmalloc(sizeof(uint16)*n_color);",
      "        if( !img->redcmap || !img->greencmap || !img->bluecmap ) {",
      "\t    snprintf(emsg, sizeof(emsg), \"Out of memory for colormap copy\");",
      "\t    return (0);",
      "        }",
      "",
      "        _TIFFmemcpy( img->redcmap, red_orig, n_color * 2 );",
      "        _TIFFmemcpy( img->greencmap, green_orig, n_color * 2 );"
    ]
  },
  "snippet_019": {
    "original_content": [
      "    case PHOTOMETRIC_MINISWHITE:",
      "    case PHOTOMETRIC_MINISBLACK:",
      "\tif (planarconfig == PLANARCONFIG_CONTIG ",
      "            && img->samplesperpixel != 1",
      "            && img->bitspersample < 8 ) {",
      "\t    sprintf(emsg,",
      "                    \"Sorry, can not handle contiguous data with %s=%d, \"",
      "                    \"and %s=%d and Bits/Sample=%d\",",
      "                    photoTag, img->photometric,",
      "                    \"Samples/pixel\", img->samplesperpixel,",
      "                    img->bitspersample);",
      "\t    return (0);",
      "\t}",
      "\tbreak;",
      "    case PHOTOMETRIC_YCBCR:",
      "\tif (planarconfig != PLANARCONFIG_CONTIG) {",
      "\t    sprintf(emsg, \"Sorry, can not handle YCbCr images with %s=%d\",",
      "\t\t\"Planarconfiguration\", planarconfig);",
      "\t    return (0);",
      "\t}",
      "\t/* It would probably be nice to have a reality check here. */",
      "\tif (planarconfig == PLANARCONFIG_CONTIG)"
    ],
    "golden_answer": [
      "/*",
      "     * A placeholder for the actual size of the emsg buffer.",
      "     * This should be defined or replaced with the real buffer capacity.",
      "     * For example: #define EMSG_SIZE 1024",
      "     * Or, if emsg is an array: sizeof(emsg)",
      "     */",
      "    #define EMSG_SIZE 1024",
      "",
      "    /* ... */",
      "",
      "    case PHOTOMETRIC_MINISWHITE:",
      "    case PHOTOMETRIC_MINISBLACK:",
      "\tif (planarconfig == PLANARCONFIG_CONTIG ",
      "            && img->samplesperpixel != 1",
      "            && img->bitspersample < 8 ) {",
      "\t    int n = snprintf(emsg, EMSG_SIZE,",
      "                    \"Sorry, can not handle contiguous data with %s=%d, \"",
      "                    \"and %s=%d and Bits/Sample=%d\",",
      "                    photoTag, img->photometric,",
      "                    \"Samples/pixel\", img->samplesperpixel,",
      "                    img->bitspersample);",
      "            /*",
      "             * Check snprintf's return value.",
      "             * A negative value indicates an encoding error.",
      "             * A value >= EMSG_SIZE indicates the message was truncated.",
      "             * In either case, the buffer is safe from overflow, and we",
      "             * proceed to return the error code.",
      "             */",
      "            if (n < 0) {",
      "                /* Handle encoding error, e.g., by setting a generic message */",
      "                snprintf(emsg, EMSG_SIZE, \"Error formatting an error message.\");",
      "            }",
      "\t    return (0);",
      "\t}",
      "\tbreak;",
      "    case PHOTOMETRIC_YCBCR:",
      "\tif (planarconfig != PLANARCONFIG_CONTIG) {",
      "\t    int n = snprintf(emsg, EMSG_SIZE, \"Sorry, can not handle YCbCr images with %s=%d\",",
      "\t\t\"Planarconfiguration\", planarconfig);",
      "            /* Check snprintf's return value for safety and completeness. */",
      "            if (n < 0) {",
      "                snprintf(emsg, EMSG_SIZE, \"Error formatting an error message.\");",
      "            }",
      "\t    return (0);",
      "\t}",
      "\t/* It would probably be nice to have a reality check here. */",
      "\tif (planarconfig == PLANARCONFIG_CONTIG)"
    ]
  },
  "snippet_020": {
    "original_content": [
      "                    break;",
      "\t    }",
      "\tbreak;",
      "    case PHOTOMETRIC_RGB: ",
      "\tif (colorchannels < 3) {",
      "\t    sprintf(emsg, \"Sorry, can not handle RGB image with %s=%d\",",
      "\t\t\"Color channels\", colorchannels);",
      "\t    return (0);",
      "\t}",
      "\tbreak;",
      "    case PHOTOMETRIC_SEPARATED: {",
      "\tuint16 inkset;",
      "\tTIFFGetFieldDefaulted(tif, TIFFTAG_INKSET, &inkset);",
      "\tif (inkset != INKSET_CMYK) {",
      "\t    sprintf(emsg, \"Sorry, can not handle separated image with %s=%d\",",
      "\t\t\"InkSet\", inkset);",
      "\t    return (0);",
      "\t}",
      "\tif (img->samplesperpixel < 4) {",
      "\t    sprintf(emsg, \"Sorry, can not handle separated image with %s=%d\",",
      "\t\t\"Samples/pixel\", img->samplesperpixel);",
      "\t    return (0);",
      "\t}",
      "\tbreak;",
      "    }",
      "    case PHOTOMETRIC_LOGL:",
      "\tif (compress != COMPRESSION_SGILOG) {",
      "\t    sprintf(emsg, \"Sorry, LogL data must have %s=%d\",",
      "\t\t\"Compression\", COMPRESSION_SGILOG);",
      "\t    return (0);",
      "\t}",
      "\tTIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_8BIT);",
      "\timg->photometric = PHOTOMETRIC_MINISBLACK;\t/* little white lie */",
      "\timg->bitspersample = 8;",
      "\tbreak;",
      "    case PHOTOMETRIC_LOGLUV:",
      "\tif (compress != COMPRESSION_SGILOG && compress != COMPRESSION_SGILOG24) {",
      "\t    sprintf(emsg, \"Sorry, LogLuv data must have %s=%d or %d\",",
      "\t\t\"Compression\", COMPRESSION_SGILOG, COMPRESSION_SGILOG24);",
      "\t    return (0);",
      "\t}",
      "\tif (planarconfig != PLANARCONFIG_CONTIG) {",
      "\t    sprintf(emsg, \"Sorry, can not handle LogLuv images with %s=%d\",",
      "\t\t\"Planarconfiguration\", planarconfig);",
      "\t    return (0);",
      "\t}",
      "\tTIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_8BIT);",
      "\timg->photometric = PHOTOMETRIC_RGB;\t\t/* little white lie */",
      "\timg->bitspersample = 8;",
      "\tbreak;",
      "    case PHOTOMETRIC_CIELAB:",
      "\tbreak;",
      "    default:",
      "\tsprintf(emsg, \"Sorry, can not handle image with %s=%d\",",
      "\t    photoTag, img->photometric);",
      "\treturn (0);",
      "    }",
      "    img->Map = NULL;",
      "    img->BWmap = NULL;"
    ],
    "golden_answer": [
      "break;",
      "\t    }",
      "\tbreak;",
      "    case PHOTOMETRIC_RGB: ",
      "\tif (colorchannels < 3) {",
      "\t    snprintf(emsg, sizeof(emsg), \"Sorry, can not handle RGB image with %s=%d\",",
      "\t\t\"Color channels\", colorchannels);",
      "\t    return (0);",
      "\t}",
      "\tbreak;",
      "    case PHOTOMETRIC_SEPARATED: {",
      "\tuint16 inkset;",
      "\tTIFFGetFieldDefaulted(tif, TIFFTAG_INKSET, &inkset);",
      "\tif (inkset != INKSET_CMYK) {",
      "\t    snprintf(emsg, sizeof(emsg), \"Sorry, can not handle separated image with %s=%d\",",
      "\t\t\"InkSet\", inkset);",
      "\t    return (0);",
      "\t}",
      "\tif (img->samplesperpixel < 4) {",
      "\t    snprintf(emsg, sizeof(emsg), \"Sorry, can not handle separated image with %s=%d\",",
      "\t\t\"Samples/pixel\", img->samplesperpixel);",
      "\t    return (0);",
      "\t}",
      "\tbreak;",
      "    }",
      "    case PHOTOMETRIC_LOGL:",
      "\tif (compress != COMPRESSION_SGILOG) {",
      "\t    snprintf(emsg, sizeof(emsg), \"Sorry, LogL data must have %s=%d\",",
      "\t\t\"Compression\", COMPRESSION_SGILOG);",
      "\t    return (0);",
      "\t}",
      "\tTIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_8BIT);",
      "\timg->photometric = PHOTOMETRIC_MINISBLACK;\t/* little white lie */",
      "\timg->bitspersample = 8;",
      "\tbreak;",
      "    case PHOTOMETRIC_LOGLUV:",
      "\tif (compress != COMPRESSION_SGILOG && compress != COMPRESSION_SGILOG24) {",
      "\t    snprintf(emsg, sizeof(emsg), \"Sorry, LogLuv data must have %s=%d or %d\",",
      "\t\t\"Compression\", COMPRESSION_SGILOG, COMPRESSION_SGILOG24);",
      "\t    return (0);",
      "\t}",
      "\tif (planarconfig != PLANARCONFIG_CONTIG) {",
      "\t    snprintf(emsg, sizeof(emsg), \"Sorry, can not handle LogLuv images with %s=%d\",",
      "\t\t\"Planarconfiguration\", planarconfig);",
      "\t    return (0);",
      "\t}",
      "\tTIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_8BIT);",
      "\timg->photometric = PHOTOMETRIC_RGB;\t\t/* little white lie */",
      "\timg->bitspersample = 8;",
      "\tbreak;",
      "    case PHOTOMETRIC_CIELAB:",
      "\tbreak;",
      "    default:",
      "\tsnprintf(emsg, sizeof(emsg), \"Sorry, can not handle image with %s=%d\",",
      "\t    photoTag, img->photometric);",
      "\treturn (0);",
      "    }",
      "    img->Map = NULL;",
      "    img->BWmap = NULL;"
    ]
  },
  "snippet_021": {
    "original_content": [
      "    img->isContig =",
      "\t!(planarconfig == PLANARCONFIG_SEPARATE && colorchannels > 1);",
      "    if (img->isContig) {",
      "\timg->get = TIFFIsTiled(tif) ? gtTileContig : gtStripContig;",
      "\tif (!pickTileContigCase(img)) {",
      "\t\tsprintf(emsg, \"Sorry, can not handle image\");",
      "\t\treturn 0;",
      "\t}",
      "    } else {",
      "\timg->get = TIFFIsTiled(tif) ? gtTileSeparate : gtStripSeparate;",
      "\tif (!pickTileSeparateCase(img)) {",
      "\t\tsprintf(emsg, \"Sorry, can not handle image\");",
      "\t\treturn 0;",
      "\t}",
      "    }",
      "    return 1;",
      "}"
    ],
    "golden_answer": [
      "int ok;",
      "    img->isContig =",
      "\t!(planarconfig == PLANARCONFIG_SEPARATE && colorchannels > 1);",
      "",
      "    if (img->isContig) {",
      "\timg->get = TIFFIsTiled(tif) ? gtTileContig : gtStripContig;",
      "\tok = pickTileContigCase(img);",
      "    } else {",
      "\timg->get = TIFFIsTiled(tif) ? gtTileSeparate : gtStripSeparate;",
      "\tok = pickTileSeparateCase(img);",
      "    }",
      "",
      "    if (!ok) {",
      "\t// Use snprintf to prevent buffer overflows.",
      "\t// Assumes emsg_size is the total size of the emsg buffer.",
      "\tint ret = snprintf(emsg, emsg_size, \"Sorry, can not handle image\");",
      "",
      "\t// Appropriately handle the return value. A negative value indicates an",
      "\t// encoding error, in which case the buffer contents are indeterminate.",
      "\t// We ensure the string is safely terminated.",
      "\tif (ret < 0) {",
      "\t    if (emsg_size > 0) {",
      "\t\temsg[0] = '\\0';",
      "\t    }",
      "\t}",
      "\treturn 0;",
      "    }",
      "",
      "    return 1;",
      "}"
    ]
  },
  "snippet_022": {
    "original_content": [
      "win3WarningHandler(const char* module, const char* fmt, va_list ap)",
      "{",
      "\tchar e[512] = { '\\0' };",
      "\tif (module != NULL)",
      "\t\tstrcat(strcpy(e, module), \":\");",
      "\tvsprintf(e+strlen(e), fmt, ap);",
      "\tstrcat(e, \".\");",
      "\tMessageBox(GetActiveWindow(), e, \"LibTIFF Warning\",",
      "\t    MB_OK|MB_ICONEXCLAMATION);",
      "}",
      "TIFFErrorHandler _TIFFwarningHandler = win3WarningHandler;"
    ],
    "golden_answer": [
      "win3WarningHandler(const char* module, const char* fmt, va_list ap)",
      "{",
      "\tchar e[512];",
      "\tsize_t n = 0; // Tracks the current length of the string in buffer 'e'",
      "",
      "\t/*",
      "\t * Prepend the module name and a colon-space, if provided.",
      "\t * snprintf is used for safety. It returns the number of characters",
      "\t * that *would have been* written, excluding the null terminator.",
      "\t */",
      "\tif (module != NULL) {",
      "\t\tint ret = snprintf(e, sizeof(e), \"%s: \", module);",
      "\t\tif (ret < 0) {",
      "\t\t\t/* On encoding error, fall back to an empty string */",
      "\t\t\te[0] = '\\0';",
      "\t\t\tn = 0;",
      "\t\t} else if ((size_t)ret >= sizeof(e)) {",
      "\t\t\t/*",
      "\t\t\t * Output was truncated. The buffer is full but safely",
      "\t\t\t * null-terminated. We set n to the max possible length.",
      "\t\t\t */",
      "\t\t\tn = sizeof(e) - 1;",
      "\t\t} else {",
      "\t\t\t/* Success, no truncation. */",
      "\t\t\tn = ret;",
      "\t\t}",
      "\t}",
      "",
      "\t/*",
      "\t * Append the formatted warning message from the variable argument list.",
      "\t * We only write if there is space remaining in the buffer.",
      "\t * The available space is sizeof(e) - n.",
      "\t */",
      "\tif (n < sizeof(e)) {",
      "\t\tint ret = vsnprintf(e + n, sizeof(e) - n, fmt, ap);",
      "\t\tif (ret > 0) {",
      "\t\t\t/*",
      "\t\t\t * If the output was not truncated, add its length.",
      "\t\t\t * If it was truncated, vsnprintf still wrote a null-terminated",
      "\t\t\t * string, so we just add up to the buffer limit.",
      "\t\t\t */",
      "\t\t\tif ((size_t)ret >= sizeof(e) - n)",
      "\t\t\t\tn = sizeof(e) - 1;",
      "\t\t\telse",
      "\t\t\t\tn += ret;",
      "\t\t}",
      "\t}",
      "",
      "\t/*",
      "\t * Append a period at the end, if there's space.",
      "\t * We need space for the '.' and the final '\\0'.",
      "\t */",
      "\tif (n < sizeof(e) - 1) {",
      "\t\te[n++] = '.';",
      "\t\te[n] = '\\0';",
      "\t}",
      "",
      "\tMessageBox(GetActiveWindow(), e, \"LibTIFF Warning\",",
      "\t    MB_OK | MB_ICONEXCLAMATION);",
      "}",
      "TIFFErrorHandler _TIFFwarningHandler = win3WarningHandler;"
    ]
  },
  "snippet_023": {
    "original_content": [
      "win3ErrorHandler(const char* module, const char* fmt, va_list ap)",
      "{",
      "\tchar e[512] = { '\\0' };",
      "\tif (module != NULL)",
      "\t\tstrcat(strcpy(e, module), \":\");",
      "\tvsprintf(e+strlen(e), fmt, ap);",
      "\tstrcat(e, \".\");",
      "\tMessageBox(GetActiveWindow(), e, \"LibTIFF Error\", MB_OK|MB_ICONSTOP);",
      "}",
      "TIFFErrorHandler _TIFFerrorHandler = win3ErrorHandler;"
    ],
    "golden_answer": [
      "#include <stdio.h> // Required for vsnprintf, snprintf",
      "#include <string.h> // Required for strlen",
      "",
      "// Assuming necessary Windows headers are included for MessageBox, etc.",
      "// #include <windows.h>",
      "// #include <stdarg.h>",
      "",
      "win3ErrorHandler(const char* module, const char* fmt, va_list ap)",
      "{",
      "\t// The buffer remains the same size.",
      "\tchar e[512];",
      "\tint n = 0;",
      "\tsize_t e_size = sizeof(e);",
      "",
      "\t// 1. Safely print the module name and a colon into the buffer.",
      "\t// snprintf returns the number of characters that *would have been* written.",
      "\tif (module != NULL) {",
      "\t\tn = snprintf(e, e_size, \"%s:\", module);",
      "\t}",
      "",
      "\t// 2. Handle the return value and append the formatted error string.",
      "\t// We proceed only if snprintf did not encounter an error (n < 0) and",
      "\t// if there is still space left in the buffer ((size_t)n < e_size).",
      "\tif (n >= 0 && (size_t)n < e_size) {",
      "\t\t// Use vsnprintf for the va_list.",
      "\t\t// We write to the buffer starting at the new offset (e + n)",
      "\t\t// with the remaining buffer size (e_size - n).",
      "\t\tvsnprintf(e + n, e_size - n, fmt, ap);",
      "\t}",
      "",
      "\t// At this point, vsnprintf has safely written the string and",
      "\t// guaranteed null-termination, truncating if necessary.",
      "",
      "\t// 3. Safely append the final period.",
      "\t// Find the current length of the string.",
      "\tsize_t len = strlen(e);",
      "\t// Only add the period if there is room for it and a new null terminator.",
      "\tif (len < e_size - 1) {",
      "\t\te[len] = '.';",
      "\t\te[len + 1] = '\\0';",
      "\t}",
      "\t// If the buffer was already full, the period is safely omitted.",
      "",
      "\tMessageBox(GetActiveWindow(), e, \"LibTIFF Error\", MB_OK|MB_ICONSTOP);",
      "}",
      "TIFFErrorHandler _TIFFerrorHandler = win3ErrorHandler;"
    ]
  },
  "snippet_024": {
    "original_content": [
      "\tLPCTSTR szDefaultModule = \"LIBTIFF\";",
      "\tLPCTSTR szTmpModule = (module == NULL) ? szDefaultModule : module;",
      "\tif ((szTitle = (LPTSTR)LocalAlloc(LMEM_FIXED, (strlen(szTmpModule) +",
      "\t\tstrlen(szTitleText) + strlen(fmt) + 128)*sizeof(char))) == NULL)",
      "\t\treturn;",
      "\tsprintf(szTitle, szTitleText, szTmpModule);",
      "\tszTmp = szTitle + (strlen(szTitle)+2)*sizeof(char);",
      "\tvsprintf(szTmp, fmt, ap);",
      "\tMessageBoxA(GetFocus(), szTmp, szTitle, MB_OK | MB_ICONINFORMATION);",
      "\tLocalFree(szTitle);",
      "\treturn;",
      "#else",
      "\tif (module != NULL)"
    ],
    "golden_answer": [
      "LPCTSTR szDefaultModule = \"LIBTIFF\";",
      "\tLPCTSTR szTmpModule = (module == NULL) ? szDefaultModule : module;",
      "\tLPTSTR szTitle = NULL;",
      "\tLPTSTR szTmp = NULL;",
      "\tsize_t buffer_size;",
      "\tint title_chars_written;",
      "",
      "\t// Calculate the total buffer size needed. Using size_t is best practice.",
      "\tbuffer_size = strlen(szTmpModule) + strlen(szTitleText) + strlen(fmt) + 128;",
      "\tif ((szTitle = (LPTSTR)LocalAlloc(LMEM_FIXED, buffer_size)) == NULL)",
      "\t\treturn;",
      "",
      "\t// 1. Use snprintf to safely format the title string.",
      "\t// It prevents buffer overflows by never writing more than buffer_size bytes.",
      "\ttitle_chars_written = snprintf(szTitle, buffer_size, szTitleText, szTmpModule);",
      "",
      "\t// 2. Handle the return value of snprintf.",
      "\t// A negative value indicates an encoding error.",
      "\tif (title_chars_written < 0) {",
      "\t\tLocalFree(szTitle);",
      "\t\treturn;",
      "\t}",
      "",
      "\t// Safely calculate the starting position for the message body.",
      "\t// This is placed right after the null terminator of the title string.",
      "\t// We use strlen() on the result to correctly handle cases where snprintf truncated the output.",
      "\tszTmp = szTitle + strlen(szTitle) + 1;",
      "",
      "\t// Calculate the remaining size in the buffer for the second string.",
      "\t// The subtraction (szTmp - szTitle) gives the number of bytes already used.",
      "\tsize_t remaining_size = buffer_size - (szTmp - szTitle);",
      "",
      "\t// 3. Use vsnprintf to safely format the message body into the remaining buffer space.",
      "\t// If remaining_size is zero or too small, vsnprintf will still safely",
      "\t// null-terminate the string (if space allows) and prevent a buffer overflow.",
      "\tvsnprintf(szTmp, remaining_size, fmt, ap);",
      "",
      "\tMessageBoxA(GetFocus(), szTmp, szTitle, MB_OK | MB_ICONINFORMATION);",
      "\tLocalFree(szTitle);",
      "\treturn;",
      "#else",
      "\tif (module != NULL)"
    ]
  },
  "snippet_025": {
    "original_content": [
      "\tLPCTSTR szDefaultModule = \"LIBTIFF\";",
      "\tLPCTSTR szTmpModule = (module == NULL) ? szDefaultModule : module;",
      "\tif ((szTitle = (LPTSTR)LocalAlloc(LMEM_FIXED, (strlen(szTmpModule) +",
      "\t\tstrlen(szTitleText) + strlen(fmt) + 128)*sizeof(char))) == NULL)",
      "\t\treturn;",
      "\tsprintf(szTitle, szTitleText, szTmpModule);",
      "\tszTmp = szTitle + (strlen(szTitle)+2)*sizeof(char);",
      "\tvsprintf(szTmp, fmt, ap);",
      "\tMessageBoxA(GetFocus(), szTmp, szTitle, MB_OK | MB_ICONEXCLAMATION);",
      "\tLocalFree(szTitle);",
      "\treturn;",
      "#else",
      "\tif (module != NULL)"
    ],
    "golden_answer": [
      "LPCTSTR szDefaultModule = \"LIBTIFF\";",
      "\tLPCTSTR szTmpModule = (module == NULL) ? szDefaultModule : module;",
      "\tLPTSTR szTitle, szTmp;",
      "\tsize_t buffer_size, remaining_size;",
      "\tint chars_written;",
      "",
      "\t// Calculate the total buffer size needed and allocate memory.",
      "\tbuffer_size = (strlen(szTmpModule) + strlen(szTitleText) + strlen(fmt) + 128) * sizeof(char);",
      "\tif ((szTitle = (LPTSTR)LocalAlloc(LMEM_FIXED, buffer_size)) == NULL)",
      "\t\treturn;",
      "",
      "\t// Use snprintf to safely write the title string.",
      "\t// It returns the number of characters that *would* have been written.",
      "\tchars_written = snprintf(szTitle, buffer_size, szTitleText, szTmpModule);",
      "",
      "\t// Check for encoding errors or truncation.",
      "\tif (chars_written < 0 || (size_t)chars_written >= buffer_size) {",
      "\t\t// An error occurred or the buffer was too small. Clean up and exit.",
      "\t\tLocalFree(szTitle);",
      "\t\treturn;",
      "\t}",
      "",
      "\t// Calculate the starting position and remaining size for the message string.",
      "\t// The new position is after the title string and its null terminator.",
      "\tszTmp = szTitle + chars_written + 1;",
      "\tremaining_size = buffer_size - (chars_written + 1);",
      "",
      "\t// Use vsnprintf to safely write the message string into the remaining space.",
      "\tchars_written = vsnprintf(szTmp, remaining_size, fmt, ap);",
      "",
      "\t// Check for encoding errors or truncation in the second write.",
      "\tif (chars_written < 0 || (size_t)chars_written >= remaining_size) {",
      "\t\t// An error occurred or the remaining buffer was too small. Clean up and exit.",
      "\t\tLocalFree(szTitle);",
      "\t\treturn;",
      "\t}",
      "",
      "\tMessageBoxA(GetFocus(), szTmp, szTitle, MB_OK | MB_ICONEXCLAMATION);",
      "\tLocalFree(szTitle);",
      "\treturn;",
      "#else",
      "\tif (module != NULL)"
    ]
  },
  "snippet_026": {
    "original_content": [
      "    const char *mode;",
      "{",
      "    char name[46];      /* allow for up to 128-bit integers */",
      "",
      "    if (fd < 0) return (gzFile)Z_NULL;",
      "    sprintf(name, \"<fd:%d>\", fd); /* for debugging */",
      "",
      "    return gz_open (name, mode, fd);",
      "}",
      "",
      "/* ==========================================================================="
    ],
    "golden_answer": [
      "const char *mode;",
      "{",
      "    char name[46];      /* allow for up to 128-bit integers */",
      "    int len;",
      "",
      "    if (fd < 0) return (gzFile)Z_NULL;",
      "",
      "    /* Use snprintf for buffer safety. It requires the buffer size",
      "     * to prevent writing past the end of the 'name' array. */",
      "    len = snprintf(name, sizeof(name), \"<fd:%d>\", fd);",
      "",
      "    /*",
      "     * Check the return value of snprintf:",
      "     * 1. A negative value indicates an encoding error.",
      "     * 2. A value >= sizeof(name) indicates the output was truncated.",
      "     * In either case, we cannot safely proceed.",
      "     */",
      "    if (len < 0 || len >= sizeof(name)) {",
      "        return (gzFile)Z_NULL; /* Return an error */",
      "    }",
      "",
      "    return gz_open (name, mode, fd);",
      "}",
      "",
      "/* ==========================================================================="
    ]
  },
  "snippet_027": {
    "original_content": [
      "    int len;",
      "",
      "    buf[sizeof(buf) - 1] = 0;",
      "    va_start(va, format);",
      "#ifdef NO_vsnprintf",
      "#  ifdef HAS_vsprintf_void",
      "    (void)vsprintf(buf, format, va);",
      "    va_end(va);",
      "    for (len = 0; len < sizeof(buf); len++)",
      "        if (buf[len] == 0) break;",
      "#  else",
      "    len = vsprintf(buf, format, va);",
      "    va_end(va);",
      "#  endif",
      "#else",
      "#  ifdef HAS_vsnprintf_void",
      "    (void)vsnprintf(buf, sizeof(buf), format, va);"
    ],
    "golden_answer": [
      "int len;",
      "",
      "    va_start(va, format);",
      "    // Use vsnprintf for buffer safety. It takes the buffer size as an argument",
      "    // and prevents writing past the end of the buffer.",
      "    len = vsnprintf(buf, sizeof(buf), format, va);",
      "    va_end(va);",
      "",
      "    // Appropriately handle the return value of vsnprintf.",
      "    // Per the C99 standard:",
      "    // 1. If len < 0, an encoding error occurred.",
      "    // 2. If len >= sizeof(buf), the buffer was too small and the output was truncated.",
      "    // 3. Otherwise, the operation was successful.",
      "",
      "    if (len < 0) {",
      "        // An encoding error occurred. Treat the buffer as an empty string for safety.",
      "        // You might also want to log this error.",
      "        len = 0;",
      "        buf[0] = '\\0';",
      "    } else if (len >= sizeof(buf)) {",
      "        // The output was truncated. The buffer is full but guaranteed to be",
      "        // null-terminated by vsnprintf.",
      "        // The value of 'len' is the number of characters that *would have been* written.",
      "        // For code that expects 'len' to be the actual string length, we can",
      "        // cap it at the buffer's capacity.",
      "        len = sizeof(buf) - 1;",
      "    }",
      "    // If the operation was successful (0 <= len < sizeof(buf)), 'len' already holds",
      "    // the correct number of characters written, and no further action is needed."
    ]
  },
  "snippet_028": {
    "original_content": [
      "    char buf[Z_PRINTF_BUFSIZE];",
      "    int len;",
      "",
      "    buf[sizeof(buf) - 1] = 0;",
      "#ifdef NO_snprintf",
      "#  ifdef HAS_sprintf_void",
      "    sprintf(buf, format, a1, a2, a3, a4, a5, a6, a7, a8,",
      "            a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);",
      "    for (len = 0; len < sizeof(buf); len++)",
      "        if (buf[len] == 0) break;",
      "#  else",
      "    len = sprintf(buf, format, a1, a2, a3, a4, a5, a6, a7, a8,",
      "                a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);",
      "#  endif",
      "#else",
      "#  ifdef HAS_snprintf_void",
      "    snprintf(buf, sizeof(buf), format, a1, a2, a3, a4, a5, a6, a7, a8,"
    ],
    "golden_answer": [
      "char buf[Z_PRINTF_BUFSIZE];",
      "    int len;",
      "",
      "    // Use snprintf for buffer safety. It takes the buffer size as an argument",
      "    // to prevent overflows and guarantees null-termination if the buffer size > 0.",
      "    len = snprintf(buf, sizeof(buf), format, a1, a2, a3, a4, a5, a6, a7, a8,",
      "                   a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);",
      "",
      "    // Properly handle the return value of snprintf.",
      "    // The 'len' variable should reflect the actual number of characters written",
      "    // to the buffer, excluding the null terminator.",
      "    if (len < 0) {",
      "        // An encoding error occurred. Treat the result as an empty string.",
      "        len = 0;",
      "        // Ensure buffer is a valid empty string in case its contents are indeterminate.",
      "        if (sizeof(buf) > 0) {",
      "            buf[0] = '\\0';",
      "        }",
      "    } else if ((size_t)len >= sizeof(buf)) {",
      "        // The output was truncated. The actual length of the content in the buffer",
      "        // is sizeof(buf) - 1.",
      "        len = sizeof(buf) - 1;",
      "    }",
      "    // If 0 <= len < sizeof(buf), the string was written completely and 'len'",
      "    // already holds the correct length, so no further action is needed."
    ]
  },
  "snippet_029": {
    "original_content": [
      "    Operation variations (changes in library functionality):",
      "     20: PKZIP_BUG_WORKAROUND -- slightly more permissive inflate",
      "     21: FASTEST -- deflate algorithm with only one, lowest compression level",
      "     22,23: 0 (reserved)",
      "",
      "    The sprintf variant used by gzprintf (zero is best):",
      "     24: 0 = vs*, 1 = s* -- 1 means limited to 20 arguments after the format",
      "     25: 0 = *nprintf, 1 = *printf -- 1 means gzprintf() not secure!",
      "     26: 0 = returns value, 1 = void -- 1 means inferred string length returned",
      "",
      "    Remainder:"
    ],
    "golden_answer": [
      "#include <stdio.h>",
      "#include <string.h>",
      "",
      "void describe_variation(int code, const char* description) {",
      "    // A fixed-size buffer, vulnerable to overflow.",
      "    char buffer[128];",
      "",
      "    // DANGEROUS: sprintf does not check buffer boundaries.",
      "    sprintf(buffer, \"Variation %d: %s -- A detailed explanation of the feature goes here.\", code, description);",
      "",
      "    // The buffer is then used, e.g., printed to the console.",
      "    printf(\"%s\\n\", buffer);",
      "}",
      "",
      "int main() {",
      "    describe_variation(20, \"PKZIP_BUG_WORKAROUND\");",
      "    return 0;",
      "}"
    ]
  }
}